/**
 * SORACOM API
 * SORACOM API v1
 *
 * The version of the OpenAPI document: VERSION_PLACEHOLDER
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 *
 * @export
 * @interface APIAuditLogEntry
 */
export interface APIAuditLogEntry {
    /**
     * The kind of the API (e.g. `/v1/auth`).
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    apiKind?: string;
    /**
     * The operator ID that called the API.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    operatorId?: string;
    /**
     * The IP address of the caller.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    remoteIpAddress?: string;
    /**
     * The request path that has been called.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    requestPath?: string;
    /**
     * The timestamp of the API call. This can be used as the `last_evaluated_key` request parameter, for pagination.
     * @type {number}
     * @memberof APIAuditLogEntry
     */
    requestedTimeEpochMs?: number;
    /**
     * The SAM username that called the API, if this parameter is empty, it means the caller user is the root user.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    userName?: string;
}
/**
 *
 * @export
 * @interface APICallError
 */
export interface APICallError {
    /**
     *
     * @type {APICallErrorMessage}
     * @memberof APICallError
     */
    errorMessage?: APICallErrorMessage;
    /**
     *
     * @type {number}
     * @memberof APICallError
     */
    httpStatus?: number;
}
/**
 *
 * @export
 * @interface APICallErrorMessage
 */
export interface APICallErrorMessage {
    /**
     * エラーコード
     * @type {string}
     * @memberof APICallErrorMessage
     */
    code: string;
    /**
     * エラーメッセージ。リクエスト時にX-Soracom-Langヘッダーに言語(en,ja)を設定するとその言語のメッセージがセットされます。
     * @type {string}
     * @memberof APICallErrorMessage
     */
    message: string;
}
/**
 *
 * @export
 * @interface APIKeyResponse
 */
export interface APIKeyResponse {
    /**
     *
     * @type {string}
     * @memberof APIKeyResponse
     */
    apiKey?: string;
}
/**
 *
 * @export
 * @interface ActionConfig
 */
export interface ActionConfig {
    /**
     *
     * @type {ActionConfigProperty}
     * @memberof ActionConfig
     */
    properties: ActionConfigProperty;
    /**
     *
     * @type {string}
     * @memberof ActionConfig
     */
    type: ActionConfigTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ActionConfigTypeEnum {
    ChangeSpeedClassAction = "ChangeSpeedClassAction",
    InvokeAwsLambdaAction = "InvokeAWSLambdaAction",
    ExecuteWebRequestAction = "ExecuteWebRequestAction",
    SendMailAction = "SendMailAction",
    SendMailToOperatorAction = "SendMailToOperatorAction",
    ActivationAction = "ActivationAction",
    DeactivationAction = "DeactivationAction"
}
/**
 *
 * @export
 * @interface ActionConfigProperty
 */
export interface ActionConfigProperty {
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    accessKey?: string;
    /**
     * Only for ExecuteWebRequestAction (Optional)
     * @type {string}
     * @memberof ActionConfigProperty
     */
    body?: string;
    /**
     * Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    contentType?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    endpoint?: string;
    /**
     * Run in the minutes after the timing of executionDateTimeConst
     * @type {number}
     * @memberof ActionConfigProperty
     */
    executionDateTimeConst: number;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    functionName?: string;
    /**
     * Only for ExecuteWebRequestAction (Optional)
     * @type {object}
     * @memberof ActionConfigProperty
     */
    headers?: object;
    /**
     * Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    httpMethod?: ActionConfigPropertyHttpMethodEnum;
    /**
     * Only for SendMailAction, SendMailToOperatorAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    message?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter1?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter2?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter3?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter4?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter5?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    secretAccessKey?: string;
    /**
     * Only for ChangeSpeedClassAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    speedClass?: ActionConfigPropertySpeedClassEnum;
    /**
     * Only for SendMailAction, SendMailToOperatorAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    title?: string;
    /**
     * Only for SendMailAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    to?: string;
    /**
     * Access URL and parameters. Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    url?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ActionConfigPropertyHttpMethodEnum {
    Get = "GET",
    Post = "POST",
    Put = "PUT",
    Delete = "DELETE"
}
/**
    * @export
    * @enum {string}
    */
export declare enum ActionConfigPropertySpeedClassEnum {
    Minimum = "s1.minimum",
    Slow = "s1.slow",
    Standard = "s1.standard",
    Fast = "s1.fast"
}
/**
 *
 * @export
 * @interface AirStatsResponse
 */
export interface AirStatsResponse {
    /**
     *
     * @type {{ [key: string]: DataTrafficStats; }}
     * @memberof AirStatsResponse
     */
    dataTrafficStatsMap?: {
        [key: string]: DataTrafficStats;
    };
    /**
     *
     * @type {string}
     * @memberof AirStatsResponse
     */
    date?: string;
    /**
     *
     * @type {number}
     * @memberof AirStatsResponse
     */
    unixtime?: number;
}
/**
 *
 * @export
 * @interface AttachRoleRequest
 */
export interface AttachRoleRequest {
    /**
     *
     * @type {string}
     * @memberof AttachRoleRequest
     */
    roleId?: string;
}
/**
 *
 * @export
 * @interface AttributeUpdate
 */
export interface AttributeUpdate {
    /**
     *
     * @type {string}
     * @memberof AttributeUpdate
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof AttributeUpdate
     */
    value?: string;
}
/**
 *
 * @export
 * @interface AuthKeyResponse
 */
export interface AuthKeyResponse {
    /**
     *
     * @type {string}
     * @memberof AuthKeyResponse
     */
    authKeyId?: string;
    /**
     *
     * @type {number}
     * @memberof AuthKeyResponse
     */
    createDateTime?: number;
    /**
     *
     * @type {number}
     * @memberof AuthKeyResponse
     */
    lastUsedDateTime?: number;
}
/**
 *
 * @export
 * @interface AuthRequest
 */
export interface AuthRequest {
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    authKey?: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    authKeyId?: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    mfaOTPCode?: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    password?: string;
    /**
     *
     * @type {number}
     * @memberof AuthRequest
     */
    tokenTimeoutSeconds?: number;
    /**
     *
     * @type {string}
     * @memberof AuthRequest
     */
    userName?: string;
}
/**
 *
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     *
     * @type {string}
     * @memberof AuthResponse
     */
    apiKey?: string;
    /**
     *
     * @type {string}
     * @memberof AuthResponse
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof AuthResponse
     */
    token?: string;
    /**
     *
     * @type {string}
     * @memberof AuthResponse
     */
    userName?: string;
}
/**
 *
 * @export
 * @interface AvailableLongTermDiscountModel
 */
export interface AvailableLongTermDiscountModel {
    /**
     * Contract months
     * @type {number}
     * @memberof AvailableLongTermDiscountModel
     */
    contractTermMonth?: number;
    /**
     * Unit price
     * @type {number}
     * @memberof AvailableLongTermDiscountModel
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof AvailableLongTermDiscountModel
     */
    volumeDiscountPaymentType?: AvailableLongTermDiscountModelVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof AvailableLongTermDiscountModel
     */
    volumeDiscountType?: AvailableLongTermDiscountModelVolumeDiscountTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum AvailableLongTermDiscountModelVolumeDiscountPaymentTypeEnum {
    Monthly = "MONTHLY",
    Prepayment = "PREPAYMENT"
}
/**
    * @export
    * @enum {string}
    */
export declare enum AvailableLongTermDiscountModelVolumeDiscountTypeEnum {
    BasicChargeV2 = "SORACOM_AIR_BASIC_CHARGE_V2",
    BasicCharge = "SORACOM_AIR_BASIC_CHARGE",
    MonthlyFixedBasicCharge = "SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE"
}
/**
 *
 * @export
 * @interface AvailableLongTermDiscountResponse
 */
export interface AvailableLongTermDiscountResponse {
    /**
     * List of available long term discounts
     * @type {Array<AvailableLongTermDiscountModel>}
     * @memberof AvailableLongTermDiscountResponse
     */
    availableLongTermDiscounts?: Array<AvailableLongTermDiscountModel>;
}
/**
 *
 * @export
 * @interface BeamStatsResponse
 */
export interface BeamStatsResponse {
    /**
     *
     * @type {{ [key: string]: SoracomBeamStats; }}
     * @memberof BeamStatsResponse
     */
    beamStatsMap?: {
        [key: string]: SoracomBeamStats;
    };
    /**
     *
     * @type {string}
     * @memberof BeamStatsResponse
     */
    date?: string;
    /**
     *
     * @type {number}
     * @memberof BeamStatsResponse
     */
    unixtime?: number;
}
/**
 *
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * The Cell Identity (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.3)
     * @type {number}
     * @memberof Cell
     */
    ci?: number;
    /**
     * The E-UTRAN Cell Identifer (for LTE networks), a 28 bit value represented in decimal form as a long. (See 3GPP TS 23.003 19.6)
     * @type {number}
     * @memberof Cell
     */
    eci?: number;
    /**
     * The Location Area Code (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.1)
     * @type {number}
     * @memberof Cell
     */
    lac?: number;
    /**
     * The Mobile Country Code, a 3 digit number.
     * @type {number}
     * @memberof Cell
     */
    mcc?: number;
    /**
     * The Mobile Network Code, a 2 or 3 digit number. If the value returned is only 1 digit in length, then you should prepend the value with a leading zero.
     * @type {number}
     * @memberof Cell
     */
    mnc?: number;
    /**
     * The Routing Area Code (for 2G and 3G networks), an 8 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.2)
     * @type {number}
     * @memberof Cell
     */
    rac?: number;
    /**
     * The Radio Access Technology or type of network that the device is connected to. Possible values are \"gsm\" for 2G or 3G networks, or \"lte\" for LTE networks. Unfortunately, it is not possible to differentiate 2G from 3G, or LTE from LTE Cat-M1.
     * @type {string}
     * @memberof Cell
     */
    radioType?: string;
    /**
     * The Service Area Code (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 12.5)
     * @type {number}
     * @memberof Cell
     */
    sac?: number;
    /**
     * The Tracking Area Code (for LTE networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 19.4.2.3)
     * @type {number}
     * @memberof Cell
     */
    tac?: number;
}
/**
 *
 * @export
 * @interface CellIdentifier
 */
export interface CellIdentifier {
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    cid?: string;
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    ecid?: string;
    /**
     * optionally link the result to the request
     * @type {string}
     * @memberof CellIdentifier
     */
    identifier?: string;
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    lac?: string;
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    mcc?: string;
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    mnc?: string;
    /**
     *
     * @type {string}
     * @memberof CellIdentifier
     */
    tac?: string;
}
/**
 *
 * @export
 * @interface CellLocation
 */
export interface CellLocation {
    /**
     * Average signal strength from all observations for the cell network. This is an integer value, in dBm.
     * @type {number}
     * @memberof CellLocation
     */
    avgStrength?: number;
    /**
     * Timestamp of the time when this record was first created.
     * @type {string}
     * @memberof CellLocation
     */
    created?: string;
    /**
     * Whether or not this cell is a position estimate based on observations subject to change in the future (`0`) or an exact location entered from a knowledgeable source (`1`).
     * @type {number}
     * @memberof CellLocation
     */
    exact?: number;
    /**
     * Latitude
     * @type {number}
     * @memberof CellLocation
     */
    lat?: number;
    /**
     * Longitude
     * @type {number}
     * @memberof CellLocation
     */
    lon?: number;
    /**
     * Estimate of radio range, in meters. This is an estimate on how large each cell area is, as a radius around the estimated position and is based on the observations or a knowledgeable source.
     * @type {number}
     * @memberof CellLocation
     */
    range?: number;
    /**
     * Total number of observations used to calculate the estimated position, range and avg_strength.
     * @type {number}
     * @memberof CellLocation
     */
    samples?: number;
    /**
     * Timestamp of the time when this record was most recently modified.
     * @type {string}
     * @memberof CellLocation
     */
    updated?: string;
}
/**
 *
 * @export
 * @interface CompanyInformationModel
 */
export interface CompanyInformationModel {
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    addressLine1?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    addressLine2?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    building?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    city?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    companyName: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    contactPersonName: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    countryCode: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    department: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    phoneNumber: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    vatIdentificationNumber?: string;
    /**
     *
     * @type {string}
     * @memberof CompanyInformationModel
     */
    zipCode: string;
}
/**
 *
 * @export
 * @interface Config
 */
export interface Config {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Config
     */
    properties?: {
        [key: string]: string;
    };
    /**
     *
     * @type {string}
     * @memberof Config
     */
    type?: string;
}
/**
 *
 * @export
 * @interface ContractUpdatedResponse
 */
export interface ContractUpdatedResponse {
    /**
     *
     * @type {object}
     * @memberof ContractUpdatedResponse
     */
    contractDetail?: object;
    /**
     *
     * @type {string}
     * @memberof ContractUpdatedResponse
     */
    contractName?: string;
}
/**
 *
 * @export
 * @interface ContractUpdatingRequest
 */
export interface ContractUpdatingRequest {
    /**
     *
     * @type {object}
     * @memberof ContractUpdatingRequest
     */
    contractDetail?: object;
    /**
     *
     * @type {string}
     * @memberof ContractUpdatingRequest
     */
    contractName?: string;
}
/**
 *
 * @export
 * @interface CouponResponse
 */
export interface CouponResponse {
    /**
     * Amount
     * @type {number}
     * @memberof CouponResponse
     */
    amount?: number;
    /**
     * Balance
     * @type {number}
     * @memberof CouponResponse
     */
    balance?: number;
    /**
     * Item
     * @type {string}
     * @memberof CouponResponse
     */
    billItemName?: string;
    /**
     * Coupon code
     * @type {string}
     * @memberof CouponResponse
     */
    couponCode?: string;
    /**
     * Expiry month
     * @type {string}
     * @memberof CouponResponse
     */
    expiryYearMonth?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof CouponResponse
     */
    orderId?: string;
}
/**
 *
 * @export
 * @interface CreateAndUpdateCredentialsModel
 */
export interface CreateAndUpdateCredentialsModel {
    /**
     *
     * @type {object}
     * @memberof CreateAndUpdateCredentialsModel
     */
    credentials?: object;
    /**
     *
     * @type {string}
     * @memberof CreateAndUpdateCredentialsModel
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof CreateAndUpdateCredentialsModel
     */
    type?: CreateAndUpdateCredentialsModelTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum CreateAndUpdateCredentialsModelTypeEnum {
    AwsCredentials = "aws-credentials",
    AzureCredentials = "azure-credentials",
    Psk = "psk",
    X509 = "x509"
}
/**
 *
 * @export
 * @interface CreateEstimatedCouponRequest
 */
export interface CreateEstimatedCouponRequest {
    /**
     * Amount
     * @type {number}
     * @memberof CreateEstimatedCouponRequest
     */
    amount: number;
}
/**
 *
 * @export
 * @interface CreateEstimatedOrderRequest
 */
export interface CreateEstimatedOrderRequest {
    /**
     * Order item list
     * @type {Array<OrderItemModel>}
     * @memberof CreateEstimatedOrderRequest
     */
    orderItemList?: Array<OrderItemModel>;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof CreateEstimatedOrderRequest
     */
    shippingAddressId?: string;
}
/**
 *
 * @export
 * @interface CreateEstimatedVolumeDiscountRequest
 */
export interface CreateEstimatedVolumeDiscountRequest {
    /**
     * Contract months
     * @type {number}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    contractTermMonth: number;
    /**
     * Quantity
     * @type {number}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    quantity: number;
    /**
     * Start date
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    startDate?: string;
    /**
     * Payment type
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    volumeDiscountPaymentType: CreateEstimatedVolumeDiscountRequestVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    volumeDiscountType: CreateEstimatedVolumeDiscountRequestVolumeDiscountTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum CreateEstimatedVolumeDiscountRequestVolumeDiscountPaymentTypeEnum {
    Monthly = "MONTHLY",
    Prepayment = "PREPAYMENT"
}
/**
    * @export
    * @enum {string}
    */
export declare enum CreateEstimatedVolumeDiscountRequestVolumeDiscountTypeEnum {
    BasicChargeV2 = "SORACOM_AIR_BASIC_CHARGE_V2",
    BasicCharge = "SORACOM_AIR_BASIC_CHARGE",
    MonthlyFixedBasicCharge = "SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE"
}
/**
 *
 * @export
 * @interface CreateEventHandlerRequest
 */
export interface CreateEventHandlerRequest {
    /**
     *
     * @type {Array<ActionConfig>}
     * @memberof CreateEventHandlerRequest
     */
    actionConfigList: Array<ActionConfig>;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    name?: string;
    /**
     *
     * @type {RuleConfig}
     * @memberof CreateEventHandlerRequest
     */
    ruleConfig: RuleConfig;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    status: CreateEventHandlerRequestStatusEnum;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetGroupId?: string;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetImsi?: string;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetOperatorId?: string;
    /**
     *
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetSimId?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum CreateEventHandlerRequestStatusEnum {
    Inactive = "inactive",
    Active = "active"
}
/**
 *
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof CreateGroupRequest
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CreateOrUpdateRoleRequest
 */
export interface CreateOrUpdateRoleRequest {
    /**
     *
     * @type {string}
     * @memberof CreateOrUpdateRoleRequest
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof CreateOrUpdateRoleRequest
     */
    permission: string;
}
/**
 *
 * @export
 * @interface CreatePortMappingRequest
 */
export interface CreatePortMappingRequest {
    /**
     *
     * @type {PortMappingDestination}
     * @memberof CreatePortMappingRequest
     */
    destination: PortMappingDestination;
    /**
     * Specify the duration, in seconds, that remote access should be enabled.
     * @type {number}
     * @memberof CreatePortMappingRequest
     */
    duration?: number;
    /**
     *
     * @type {PortMappingSource}
     * @memberof CreatePortMappingRequest
     */
    source?: PortMappingSource;
    /**
     * Specify whether access uses TLS.
     * @type {boolean}
     * @memberof CreatePortMappingRequest
     */
    tlsRequired?: boolean;
}
/**
 *
 * @export
 * @interface CreateRoleResponse
 */
export interface CreateRoleResponse {
    /**
     *
     * @type {string}
     * @memberof CreateRoleResponse
     */
    roleId?: string;
}
/**
 *
 * @export
 * @interface CreateSoraletRequest
 */
export interface CreateSoraletRequest {
    /**
     *
     * @type {string}
     * @memberof CreateSoraletRequest
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof CreateSoraletRequest
     */
    soraletId: string;
}
/**
 *
 * @export
 * @interface CreateUserPasswordRequest
 */
export interface CreateUserPasswordRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserPasswordRequest
     */
    password?: string;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    description?: string;
}
/**
 *
 * @export
 * @interface CreateVirtualPrivateGatewayRequest
 */
export interface CreateVirtualPrivateGatewayRequest {
    /**
     *
     * @type {string}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    deviceSubnetCidrRange?: string;
    /**
     *
     * @type {number}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    type: number;
    /**
     *
     * @type {boolean}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    useInternetGateway?: boolean;
}
/**
 *
 * @export
 * @interface CreateVpcPeeringConnectionRequest
 */
export interface CreateVpcPeeringConnectionRequest {
    /**
     *
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    destinationCidrBlock?: string;
    /**
     *
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerOwnerId?: string;
    /**
     *
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerRegion?: string;
    /**
     *
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerVpcId?: string;
}
/**
 *
 * @export
 * @interface CredentialsModel
 */
export interface CredentialsModel {
    /**
     *
     * @type {number}
     * @memberof CredentialsModel
     */
    createDateTime?: number;
    /**
     *
     * @type {object}
     * @memberof CredentialsModel
     */
    credentials?: object;
    /**
     *
     * @type {string}
     * @memberof CredentialsModel
     */
    credentialsId?: string;
    /**
     *
     * @type {string}
     * @memberof CredentialsModel
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof CredentialsModel
     */
    lastUsedDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof CredentialsModel
     */
    type?: CredentialsModelTypeEnum;
    /**
     *
     * @type {number}
     * @memberof CredentialsModel
     */
    updateDateTime?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum CredentialsModelTypeEnum {
    AwsCredentials = "aws-credentials",
    AzureCredentials = "azure-credentials",
    Psk = "psk",
    X509 = "x509"
}
/**
 *
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     *
     * @type {string}
     * @memberof CreditCard
     */
    cvc?: string;
    /**
     *
     * @type {number}
     * @memberof CreditCard
     */
    expireMonth?: number;
    /**
     *
     * @type {number}
     * @memberof CreditCard
     */
    expireYear?: number;
    /**
     *
     * @type {string}
     * @memberof CreditCard
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof CreditCard
     */
    number?: string;
}
/**
 *
 * @export
 * @interface DailyBill
 */
export interface DailyBill {
    /**
     * 金額
     * @type {number}
     * @memberof DailyBill
     */
    amount?: number;
    /**
     * 年月日
     * @type {string}
     * @memberof DailyBill
     */
    date?: string;
}
/**
 *
 * @export
 * @interface DailyBillResponse
 */
export interface DailyBillResponse {
    /**
     * 日ごとの利用料リスト
     * @type {Array<DailyBill>}
     * @memberof DailyBillResponse
     */
    billList?: Array<DailyBill>;
}
/**
 *
 * @export
 * @interface DataEntry
 */
export interface DataEntry {
    /**
     *
     * @type {string}
     * @memberof DataEntry
     */
    content?: string;
    /**
     *
     * @type {string}
     * @memberof DataEntry
     */
    contentType?: string;
    /**
     *
     * @type {number}
     * @memberof DataEntry
     */
    time?: number;
}
/**
 *
 * @export
 * @interface DataSourceResourceMetadata
 */
export interface DataSourceResourceMetadata {
    /**
     *
     * @type {Array<string>}
     * @memberof DataSourceResourceMetadata
     */
    attributeNames?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof DataSourceResourceMetadata
     */
    lastModifiedTime?: number;
    /**
     *
     * @type {string}
     * @memberof DataSourceResourceMetadata
     */
    resourceId?: string;
    /**
     *
     * @type {string}
     * @memberof DataSourceResourceMetadata
     */
    resourceType?: string;
}
/**
 *
 * @export
 * @interface DataTrafficStats
 */
export interface DataTrafficStats {
    /**
     *
     * @type {number}
     * @memberof DataTrafficStats
     */
    downloadByteSizeTotal?: number;
    /**
     *
     * @type {number}
     * @memberof DataTrafficStats
     */
    downloadPacketSizeTotal?: number;
    /**
     *
     * @type {number}
     * @memberof DataTrafficStats
     */
    uploadByteSizeTotal?: number;
    /**
     *
     * @type {number}
     * @memberof DataTrafficStats
     */
    uploadPacketSizeTotal?: number;
}
/**
 *
 * @export
 * @interface Device
 */
export interface Device {
    /**
     *
     * @type {string}
     * @memberof Device
     */
    deviceId?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    endpoint?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    firmwareVersion?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    ipAddress?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    lastRegistrationUpdate?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    manufacturer?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    modelNumber?: string;
    /**
     *
     * @type {object}
     * @memberof Device
     */
    objects?: object;
    /**
     *
     * @type {boolean}
     * @memberof Device
     */
    online?: boolean;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    registrationId?: string;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    registrationLifeTime?: number;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    serialNumber?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Device
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface DeviceObjectModel
 */
export interface DeviceObjectModel {
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    createdTime?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    format?: DeviceObjectModelFormatEnum;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    objectId?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    objectName?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceObjectModel
     */
    scope?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum DeviceObjectModelFormatEnum {
    Xml = "xml",
    Json = "json"
}
/**
 *
 * @export
 * @interface EmailsModel
 */
export interface EmailsModel {
    /**
     *
     * @type {number}
     * @memberof EmailsModel
     */
    createDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof EmailsModel
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof EmailsModel
     */
    emailId?: string;
    /**
     *
     * @type {number}
     * @memberof EmailsModel
     */
    updateDateTime?: number;
    /**
     * Whether the email address was verified by token.
     * @type {boolean}
     * @memberof EmailsModel
     */
    verified?: boolean;
}
/**
 *
 * @export
 * @interface EnableMFAOTPResponse
 */
export interface EnableMFAOTPResponse {
    /**
     *
     * @type {string}
     * @memberof EnableMFAOTPResponse
     */
    totpUri?: string;
}
/**
 *
 * @export
 * @interface EstimatedCouponModel
 */
export interface EstimatedCouponModel {
    /**
     * Amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    amount?: number;
    /**
     * Currency
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    currency?: EstimatedCouponModelCurrencyEnum;
    /**
     * Expiry month
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    expiryYearMonth?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    orderId?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    totalAmount?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum EstimatedCouponModelCurrencyEnum {
    Jpy = "JPY",
    Usd = "USD"
}
/**
 *
 * @export
 * @interface EstimatedOrderItemModel
 */
export interface EstimatedOrderItemModel {
    /**
     *
     * @type {ProductModel}
     * @memberof EstimatedOrderItemModel
     */
    product?: ProductModel;
    /**
     * Product amount
     * @type {number}
     * @memberof EstimatedOrderItemModel
     */
    productAmount?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof EstimatedOrderItemModel
     */
    quantity?: number;
}
/**
 *
 * @export
 * @interface EstimatedOrderModel
 */
export interface EstimatedOrderModel {
    /**
     * Email address
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    email?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    orderId?: string;
    /**
     * Order item list
     * @type {Array<EstimatedOrderItemModel>}
     * @memberof EstimatedOrderModel
     */
    orderItemList?: Array<EstimatedOrderItemModel>;
    /**
     *
     * @type {ShippingAddressModel}
     * @memberof EstimatedOrderModel
     */
    shippingAddress?: ShippingAddressModel;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    shippingAddressId?: string;
    /**
     * Shipping cost
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    shippingCost?: number;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    totalAmount?: number;
}
/**
 *
 * @export
 * @interface EstimatedVolumeDiscountModel
 */
export interface EstimatedVolumeDiscountModel {
    /**
     * Currency
     * @type {string}
     * @memberof EstimatedVolumeDiscountModel
     */
    currency?: EstimatedVolumeDiscountModelCurrencyEnum;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedVolumeDiscountModel
     */
    orderId?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedVolumeDiscountModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedVolumeDiscountModel
     */
    totalAmount?: number;
    /**
     *
     * @type {VolumeDiscountModel}
     * @memberof EstimatedVolumeDiscountModel
     */
    volumeDiscount?: VolumeDiscountModel;
}
/**
    * @export
    * @enum {string}
    */
export declare enum EstimatedVolumeDiscountModelCurrencyEnum {
    Jpy = "JPY",
    Usd = "USD"
}
/**
 *
 * @export
 * @interface EventHandlerModel
 */
export interface EventHandlerModel {
    /**
     *
     * @type {Array<ActionConfig>}
     * @memberof EventHandlerModel
     */
    actionConfigList: Array<ActionConfig>;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    handlerId: string;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    name: string;
    /**
     *
     * @type {RuleConfig}
     * @memberof EventHandlerModel
     */
    ruleConfig: RuleConfig;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    status: EventHandlerModelStatusEnum;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetGroupId?: string;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetImsi?: string;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetOperatorId?: string;
    /**
     *
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetSimId?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum EventHandlerModelStatusEnum {
    Inactive = "inactive",
    Active = "active"
}
/**
 *
 * @export
 * @interface ExecuteSoraletRequest
 */
export interface ExecuteSoraletRequest {
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    contentType: string;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    direction: ExecuteSoraletRequestDirectionEnum;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    encodingType?: ExecuteSoraletRequestEncodingTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    payload: string;
    /**
     *
     * @type {{ [key: string]: SoraletDataSource; }}
     * @memberof ExecuteSoraletRequest
     */
    source: {
        [key: string]: SoraletDataSource;
    };
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    userdata?: string;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    version: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ExecuteSoraletRequestDirectionEnum {
    Uplink = "uplink",
    Downlink = "downlink"
}
/**
    * @export
    * @enum {string}
    */
export declare enum ExecuteSoraletRequestEncodingTypeEnum {
    Text = "text",
    Binary = "binary"
}
/**
 *
 * @export
 * @interface ExecuteSoraletResponse
 */
export interface ExecuteSoraletResponse {
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    body?: string;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    contentType?: string;
    /**
     *
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    encodingType?: string;
    /**
     *
     * @type {number}
     * @memberof ExecuteSoraletResponse
     */
    resultCode?: number;
}
/**
 *
 * @export
 * @interface ExpiryTime
 */
export interface ExpiryTime {
    /**
     *
     * @type {string}
     * @memberof ExpiryTime
     */
    expiryAction?: ExpiryTimeExpiryActionEnum;
    /**
     * The timestamp (in Unix milliseconds) of a date and time set using the Expiration function. If no Expiration function is set, null is returned.
     * @type {number}
     * @memberof ExpiryTime
     */
    expiryTime: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ExpiryTimeExpiryActionEnum {
    DoNothing = "doNothing",
    DeleteSession = "deleteSession",
    Deactivate = "deactivate",
    Suspend = "suspend",
    Terminate = "terminate"
}
/**
 *
 * @export
 * @interface ExportRequest
 */
export interface ExportRequest {
    /**
     *
     * @type {number}
     * @memberof ExportRequest
     */
    from?: number;
    /**
     *
     * @type {string}
     * @memberof ExportRequest
     */
    period?: ExportRequestPeriodEnum;
    /**
     *
     * @type {number}
     * @memberof ExportRequest
     */
    to?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ExportRequestPeriodEnum {
    Month = "month",
    Day = "day",
    Minutes = "minutes"
}
/**
 *
 * @export
 * @interface FileEntry
 */
export interface FileEntry {
    /**
     * Content length of the file
     * @type {number}
     * @memberof FileEntry
     */
    contentLength?: number;
    /**
     * Content type of the file
     * @type {string}
     * @memberof FileEntry
     */
    contentType?: string;
    /**
     * Created time of the file
     * @type {number}
     * @memberof FileEntry
     */
    createdTime?: number;
    /**
     * Parent directory name
     * @type {string}
     * @memberof FileEntry
     */
    directory?: string;
    /**
     * Etag of the file
     * @type {string}
     * @memberof FileEntry
     */
    etag?: string;
    /**
     * Absolute path of the file
     * @type {string}
     * @memberof FileEntry
     */
    filePath?: string;
    /**
     * File name
     * @type {string}
     * @memberof FileEntry
     */
    filename?: string;
    /**
     * Whether the entry is directory or not
     * @type {boolean}
     * @memberof FileEntry
     */
    isDirectory?: boolean;
    /**
     * Last modified time of the file
     * @type {number}
     * @memberof FileEntry
     */
    lastModifiedTime?: number;
}
/**
 *
 * @export
 * @interface FileExportResponse
 */
export interface FileExportResponse {
    /**
     * ファイル出力ID(リクエストにexport_mode=asyncを指定した場合）
     * @type {string}
     * @memberof FileExportResponse
     */
    exportedFileId?: string;
    /**
     * 出力済みファイル取得パス(リクエストにexport_mode=asyncを付与した場合）
     * @type {string}
     * @memberof FileExportResponse
     */
    exportedFilePath?: string;
    /**
     * ファイルダウンロードURL(export_mode指定なし、もしくはexport_mode=syncの場合
     * @type {string}
     * @memberof FileExportResponse
     */
    url?: string;
}
/**
 *
 * @export
 * @interface FunnelConfiguration
 */
export interface FunnelConfiguration {
    /**
     *
     * @type {string}
     * @memberof FunnelConfiguration
     */
    credentialsId?: string;
    /**
     *
     * @type {FunnelDestination}
     * @memberof FunnelConfiguration
     */
    destination?: FunnelDestination;
    /**
     *
     * @type {boolean}
     * @memberof FunnelConfiguration
     */
    enabled?: boolean;
}
/**
 *
 * @export
 * @interface FunnelDestination
 */
export interface FunnelDestination {
    /**
     *
     * @type {string}
     * @memberof FunnelDestination
     */
    provider?: string;
    /**
     *
     * @type {string}
     * @memberof FunnelDestination
     */
    resourceUrl?: string;
    /**
     *
     * @type {string}
     * @memberof FunnelDestination
     */
    service?: string;
}
/**
 *
 * @export
 * @interface Gadget
 */
export interface Gadget {
    /**
     *
     * @type {object}
     * @memberof Gadget
     */
    attributes?: object;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {object}
     * @memberof Gadget
     */
    lastSeen?: object;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    productId?: string;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    serialNumber?: string;
    /**
     *
     * @type {string}
     * @memberof Gadget
     */
    status?: GadgetStatusEnum;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Gadget
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof Gadget
     */
    terminationEnabled?: boolean;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GadgetStatusEnum {
    Active = "active",
    Terminated = "terminated"
}
/**
 *
 * @export
 * @interface GadgetRegistrationRequest
 */
export interface GadgetRegistrationRequest {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof GadgetRegistrationRequest
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface GatePeer
 */
export interface GatePeer {
    /**
     *
     * @type {string}
     * @memberof GatePeer
     */
    innerIpAddress?: string;
    /**
     *
     * @type {string}
     * @memberof GatePeer
     */
    outerIpAddress?: string;
    /**
     *
     * @type {boolean}
     * @memberof GatePeer
     */
    ownedByCustomer?: boolean;
}
/**
 *
 * @export
 * @interface GenerateOperatorsAuthKeyResponse
 */
export interface GenerateOperatorsAuthKeyResponse {
    /**
     *
     * @type {string}
     * @memberof GenerateOperatorsAuthKeyResponse
     */
    authKey?: string;
    /**
     *
     * @type {string}
     * @memberof GenerateOperatorsAuthKeyResponse
     */
    authKeyId?: string;
}
/**
 *
 * @export
 * @interface GenerateTokenRequest
 */
export interface GenerateTokenRequest {
    /**
     * 新しい API トークンの有効期限の長さ（秒単位）。 指定しなければデフォルトは 86400 [秒]（24時間）。 最大値は 172800 [秒]（48時間）。
     * @type {number}
     * @memberof GenerateTokenRequest
     */
    tokenTimeoutSeconds?: number;
}
/**
 *
 * @export
 * @interface GenerateTokenResponse
 */
export interface GenerateTokenResponse {
    /**
     *
     * @type {string}
     * @memberof GenerateTokenResponse
     */
    token: string;
}
/**
 *
 * @export
 * @interface GenerateUserAuthKeyResponse
 */
export interface GenerateUserAuthKeyResponse {
    /**
     *
     * @type {string}
     * @memberof GenerateUserAuthKeyResponse
     */
    authKey?: string;
    /**
     *
     * @type {string}
     * @memberof GenerateUserAuthKeyResponse
     */
    authKeyId?: string;
}
/**
 *
 * @export
 * @interface GetBillingHistoryResponse
 */
export interface GetBillingHistoryResponse {
    /**
     * 月ごとの利用料リスト
     * @type {Array<MonthlyBill>}
     * @memberof GetBillingHistoryResponse
     */
    billList?: Array<MonthlyBill>;
}
/**
 *
 * @export
 * @interface GetDefaultPermissionsResponse
 */
export interface GetDefaultPermissionsResponse {
    /**
     *
     * @type {string}
     * @memberof GetDefaultPermissionsResponse
     */
    defaultPermissions?: string;
}
/**
 *
 * @export
 * @interface GetExportedFileResponse
 */
export interface GetExportedFileResponse {
    /**
     * ファイル出力ステータス
     * @type {string}
     * @memberof GetExportedFileResponse
     */
    status?: GetExportedFileResponseStatusEnum;
    /**
     * ファイルダウンロードURL
     * @type {string}
     * @memberof GetExportedFileResponse
     */
    url?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetExportedFileResponseStatusEnum {
    Processing = "processing",
    Exported = "exported",
    Failed = "failed"
}
/**
 *
 * @export
 * @interface GetLatestBill
 */
export interface GetLatestBill {
    /**
     * 金額
     * @type {number}
     * @memberof GetLatestBill
     */
    amount?: number;
    /**
     * 利用額計算を実施した時間
     * @type {string}
     * @memberof GetLatestBill
     */
    lastEvaluatedTime?: string;
}
/**
 *
 * @export
 * @interface GetOperatorResponse
 */
export interface GetOperatorResponse {
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    createDate: string;
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    operatorId: string;
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    rootOperatorId: string;
    /**
     *
     * @type {string}
     * @memberof GetOperatorResponse
     */
    updateDate: string;
}
/**
 *
 * @export
 * @interface GetOrderResponse
 */
export interface GetOrderResponse {
    /**
     * Email address
     * @type {string}
     * @memberof GetOrderResponse
     */
    email?: string;
    /**
     * Order date and time
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderDateTime?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderId?: string;
    /**
     * Order item list
     * @type {Array<EstimatedOrderItemModel>}
     * @memberof GetOrderResponse
     */
    orderItemList?: Array<EstimatedOrderItemModel>;
    /**
     * Order status
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderStatus?: GetOrderResponseOrderStatusEnum;
    /**
     *
     * @type {ShippingAddressModel}
     * @memberof GetOrderResponse
     */
    shippingAddress?: ShippingAddressModel;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof GetOrderResponse
     */
    shippingAddressId?: string;
    /**
     * Shipping cost
     * @type {number}
     * @memberof GetOrderResponse
     */
    shippingCost?: number;
    /**
     * Shipping label number
     * @type {string}
     * @memberof GetOrderResponse
     */
    shippingLabelNumber?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof GetOrderResponse
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof GetOrderResponse
     */
    totalAmount?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetOrderResponseOrderStatusEnum {
    Ordering = "ordering",
    Ordered = "ordered",
    Kitting = "kitting",
    Shipped = "shipped",
    Received = "received",
    Cancelling = "cancelling",
    Cancelled = "cancelled",
    Failed = "failed"
}
/**
 *
 * @export
 * @interface GetPaymentMethodResult
 */
export interface GetPaymentMethodResult {
    /**
     * Error code (only if payment information is invalid)
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    errorCode?: GetPaymentMethodResultErrorCodeEnum;
    /**
     * Error message (only if payment information is invalid)
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    errorMessage?: string;
    /**
     * Payment information
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    properties?: string;
    /**
     * Provider type
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    providerType?: GetPaymentMethodResultProviderTypeEnum;
    /**
     * Update date
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    updateDate?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetPaymentMethodResultErrorCodeEnum {
    Success = "success",
    Processing = "processing",
    InvalidRequest = "invalid_request",
    InvalidNumber = "invalid_number",
    IncorrectNumber = "incorrect_number",
    InvalidName = "invalid_name",
    InvalidExpiryMonth = "invalid_expiry_month",
    InvalidExpiryYear = "invalid_expiry_year",
    InvalidExpiry = "invalid_expiry",
    IncorrectExpiry = "incorrect_expiry",
    InvalidCvc = "invalid_cvc",
    IncorrectCvc = "incorrect_cvc",
    CardDeclined = "card_declined",
    Missing = "missing",
    ProcessingError = "processing_error"
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetPaymentMethodResultProviderTypeEnum {
    WebPay = "WebPay"
}
/**
 *
 * @export
 * @interface GetPaymentTransactionResult
 */
export interface GetPaymentTransactionResult {
    /**
     *
     * @type {PaymentAmount}
     * @memberof GetPaymentTransactionResult
     */
    amount?: PaymentAmount;
    /**
     *
     * @type {PaymentDescription}
     * @memberof GetPaymentTransactionResult
     */
    description?: PaymentDescription;
    /**
     * Message
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    message?: string;
    /**
     * Message code
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    messageCode?: GetPaymentTransactionResultMessageCodeEnum;
    /**
     * Status
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    status?: GetPaymentTransactionResultStatusEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetPaymentTransactionResultMessageCodeEnum {
    Success = "success",
    Processing = "processing",
    InvalidRequest = "invalid_request",
    InvalidNumber = "invalid_number",
    IncorrectNumber = "incorrect_number",
    InvalidName = "invalid_name",
    InvalidExpiryMonth = "invalid_expiry_month",
    InvalidExpiryYear = "invalid_expiry_year",
    InvalidExpiry = "invalid_expiry",
    IncorrectExpiry = "incorrect_expiry",
    InvalidCvc = "invalid_cvc",
    IncorrectCvc = "incorrect_cvc",
    CardDeclined = "card_declined",
    Missing = "missing",
    ProcessingError = "processing_error"
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetPaymentTransactionResultStatusEnum {
    Success = "success",
    Error = "error"
}
/**
 *
 * @export
 * @interface GetShippingAddressResponse
 */
export interface GetShippingAddressResponse {
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    addressLine1: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    addressLine2?: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    building?: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    city: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    companyName?: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    department?: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    fullName?: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    phoneNumber: string;
    /**
     * 配送先ID
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    shippingAddressId: string;
    /**
     * 配送先エリア
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    shippingArea: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    state: string;
    /**
     *
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    zipCode: string;
}
/**
 *
 * @export
 * @interface GetUserPasswordResponse
 */
export interface GetUserPasswordResponse {
    /**
     *
     * @type {boolean}
     * @memberof GetUserPasswordResponse
     */
    hasPassword?: boolean;
}
/**
 *
 * @export
 * @interface GetUserPermissionResponse
 */
export interface GetUserPermissionResponse {
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof GetUserPermissionResponse
     */
    permission: string;
}
/**
 *
 * @export
 * @interface GetVolumeDiscountResponse
 */
export interface GetVolumeDiscountResponse {
    /**
     * Contract date time
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    contractDateTime?: string;
    /**
     * Contract ID
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    contractId?: string;
    /**
     * Contract months
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    contractTermMonth?: number;
    /**
     * End date
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    endDate?: string;
    /**
     * Initial cost
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    initialCost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    quantity?: number;
    /**
     * Start date
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    startDate?: string;
    /**
     * Status
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    status?: GetVolumeDiscountResponseStatusEnum;
    /**
     * Unit price
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    volumeDiscountPaymentType?: GetVolumeDiscountResponseVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    volumeDiscountType?: GetVolumeDiscountResponseVolumeDiscountTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetVolumeDiscountResponseStatusEnum {
    Active = "active",
    Expired = "expired"
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetVolumeDiscountResponseVolumeDiscountPaymentTypeEnum {
    Monthly = "MONTHLY",
    Prepayment = "PREPAYMENT"
}
/**
    * @export
    * @enum {string}
    */
export declare enum GetVolumeDiscountResponseVolumeDiscountTypeEnum {
    BasicChargeV2 = "SORACOM_AIR_BASIC_CHARGE_V2",
    BasicCharge = "SORACOM_AIR_BASIC_CHARGE",
    MonthlyFixedBasicCharge = "SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE"
}
/**
 *
 * @export
 * @interface GlobalSimAppletPLMNRecord
 */
export interface GlobalSimAppletPLMNRecord {
    /**
     *
     * @type {number}
     * @memberof GlobalSimAppletPLMNRecord
     */
    containerId: number;
    /**
     *
     * @type {string}
     * @memberof GlobalSimAppletPLMNRecord
     */
    mcc: string;
    /**
     *
     * @type {string}
     * @memberof GlobalSimAppletPLMNRecord
     */
    mnc?: string;
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Group
     */
    configuration?: {
        [key: string]: string;
    };
    /**
     *
     * @type {number}
     * @memberof Group
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    groupId?: string;
    /**
     *
     * @type {number}
     * @memberof Group
     */
    lastModifiedTime?: number;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    operatorId?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof Group
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface GroupConfigurationUpdateRequest
 */
export interface GroupConfigurationUpdateRequest {
    /**
     *
     * @type {string}
     * @memberof GroupConfigurationUpdateRequest
     */
    key: string;
    /**
     *
     * @type {string}
     * @memberof GroupConfigurationUpdateRequest
     */
    value: string;
}
/**
 *
 * @export
 * @interface HarvestExportedDataStatsResponse
 */
export interface HarvestExportedDataStatsResponse {
    /**
     * exportedBytes
     * @type {number}
     * @memberof HarvestExportedDataStatsResponse
     */
    exportedBytes?: number;
    /**
     * yearMonth
     * @type {string}
     * @memberof HarvestExportedDataStatsResponse
     */
    yearMonth?: string;
}
/**
 * The IMEI of a modem or device that is allowed to use the subscriber/SIM, which is set using the IMEI Lock function. When enabled, the value returned is a string of length 15, which contain the IMEI number. If IMEI Lock is not enabled, null is returned.
 * @export
 * @interface ImeiLock
 */
export interface ImeiLock {
    /**
     *
     * @type {string}
     * @memberof ImeiLock
     */
    imei?: string;
}
/**
 *
 * @export
 * @interface IndividualInformationModel
 */
export interface IndividualInformationModel {
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    addressLine1?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    addressLine2?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    building?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    city?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    countryCode?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    fullName: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    phoneNumber?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof IndividualInformationModel
     */
    zipCode?: string;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     *
     * @type {string}
     * @memberof InlineObject
     */
    value?: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     *
     * @type {string}
     * @memberof InlineObject1
     */
    groupId?: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * A flag to indicate if it should cause a switch to the subscription after the download has finished. If it is set to true, the downloaded subscriber will be enabled immediately.
     * @type {boolean}
     * @memberof InlineObject2
     */
    enable?: boolean;
    /**
     * Name of the sbscription plan
     * @type {string}
     * @memberof InlineObject2
     */
    subscription: string;
}
/**
 *
 * @export
 * @interface IpAddressMapEntry
 */
export interface IpAddressMapEntry {
    /**
     *
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    ipAddress?: string;
    /**
     *
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    type?: IpAddressMapEntryTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum IpAddressMapEntryTypeEnum {
    Static = "static",
    Dynamic = "dynamic",
    CustomerGatePeer = "customerGatePeer",
    GatePeer = "gatePeer"
}
/**
 *
 * @export
 * @interface IssueAddEmailTokenRequest
 */
export interface IssueAddEmailTokenRequest {
    /**
     * Email address to be added
     * @type {string}
     * @memberof IssueAddEmailTokenRequest
     */
    email: string;
    /**
     * Password of the operator
     * @type {string}
     * @memberof IssueAddEmailTokenRequest
     */
    password: string;
}
/**
 *
 * @export
 * @interface IssueEmailChangeTokenRequest
 */
export interface IssueEmailChangeTokenRequest {
    /**
     *
     * @type {string}
     * @memberof IssueEmailChangeTokenRequest
     */
    email: string;
}
/**
 *
 * @export
 * @interface IssuePasswordResetTokenRequest
 */
export interface IssuePasswordResetTokenRequest {
    /**
     *
     * @type {string}
     * @memberof IssuePasswordResetTokenRequest
     */
    email: string;
}
/**
 *
 * @export
 * @interface IssueSubscriberTransferTokenRequest
 */
export interface IssueSubscriberTransferTokenRequest {
    /**
     * 移管先オペレーターEmail
     * @type {string}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferDestinationOperatorEmail: string;
    /**
     * 移管先オペレーターID
     * @type {string}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferDestinationOperatorId: string;
    /**
     * 移管するIMSIリスト
     * @type {Array<string>}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferImsi: Array<string>;
}
/**
 *
 * @export
 * @interface IssueSubscriberTransferTokenResponse
 */
export interface IssueSubscriberTransferTokenResponse {
    /**
     * トークン
     * @type {string}
     * @memberof IssueSubscriberTransferTokenResponse
     */
    token: string;
}
/**
 *
 * @export
 * @interface JunctionInspectionConfiguration
 */
export interface JunctionInspectionConfiguration {
    /**
     *
     * @type {boolean}
     * @memberof JunctionInspectionConfiguration
     */
    enabled?: boolean;
    /**
     *
     * @type {FunnelConfiguration}
     * @memberof JunctionInspectionConfiguration
     */
    report?: FunnelConfiguration;
}
/**
 *
 * @export
 * @interface JunctionMirroringConfiguration
 */
export interface JunctionMirroringConfiguration {
    /**
     *
     * @type {{ [key: string]: JunctionMirroringPeer; }}
     * @memberof JunctionMirroringConfiguration
     */
    peers?: {
        [key: string]: JunctionMirroringPeer;
    };
}
/**
 *
 * @export
 * @interface JunctionMirroringPeer
 */
export interface JunctionMirroringPeer {
    /**
     *
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    description?: string;
    /**
     *
     * @type {boolean}
     * @memberof JunctionMirroringPeer
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    ipAddress?: string;
    /**
     *
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    protocol?: JunctionMirroringPeerProtocolEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum JunctionMirroringPeerProtocolEnum {
    Gre = "gre"
}
/**
 *
 * @export
 * @interface JunctionRedirectionConfiguration
 */
export interface JunctionRedirectionConfiguration {
    /**
     *
     * @type {string}
     * @memberof JunctionRedirectionConfiguration
     */
    description?: string;
    /**
     *
     * @type {boolean}
     * @memberof JunctionRedirectionConfiguration
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof JunctionRedirectionConfiguration
     */
    gateway?: string;
}
/**
 *
 * @export
 * @interface LagoonDashboardPermissionsResponse
 */
export interface LagoonDashboardPermissionsResponse {
    /**
     *
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponse
     */
    dashboardId?: number;
    /**
     *
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponse
     */
    dashboardTitle?: string;
    /**
     *
     * @type {Array<LagoonDashboardPermissionsResponsePermissions>}
     * @memberof LagoonDashboardPermissionsResponse
     */
    permissions?: Array<LagoonDashboardPermissionsResponsePermissions>;
}
/**
 *
 * @export
 * @interface LagoonDashboardPermissionsResponsePermissions
 */
export interface LagoonDashboardPermissionsResponsePermissions {
    /**
     *
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    dashboardId?: number;
    /**
     *
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    dashboardTitle?: string;
    /**
     *
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    permissionName?: LagoonDashboardPermissionsResponsePermissionsPermissionNameEnum;
    /**
     *
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    userEmail?: string;
    /**
     *
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    userId?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonDashboardPermissionsResponsePermissionsPermissionNameEnum {
    View = "View",
    Edit = "Edit",
    Admin = "Admin"
}
/**
 *
 * @export
 * @interface LagoonDashboardPermissionsUpdatingRequest
 */
export interface LagoonDashboardPermissionsUpdatingRequest {
    /**
     *
     * @type {Array<LagoonDashboardPermissionsUpdatingRequestPermissions>}
     * @memberof LagoonDashboardPermissionsUpdatingRequest
     */
    permissions?: Array<LagoonDashboardPermissionsUpdatingRequestPermissions>;
}
/**
 *
 * @export
 * @interface LagoonDashboardPermissionsUpdatingRequestPermissions
 */
export interface LagoonDashboardPermissionsUpdatingRequestPermissions {
    /**
     *
     * @type {string}
     * @memberof LagoonDashboardPermissionsUpdatingRequestPermissions
     */
    permission?: string;
    /**
     *
     * @type {number}
     * @memberof LagoonDashboardPermissionsUpdatingRequestPermissions
     */
    userId?: number;
}
/**
 *
 * @export
 * @interface LagoonLicensePackStatusResponse
 */
export interface LagoonLicensePackStatusResponse {
    /**
     *
     * @type {string}
     * @memberof LagoonLicensePackStatusResponse
     */
    licensePackName?: string;
    /**
     *
     * @type {number}
     * @memberof LagoonLicensePackStatusResponse
     */
    quantity?: number;
}
/**
 *
 * @export
 * @interface LagoonLicensePacksUpdatingRequest
 */
export interface LagoonLicensePacksUpdatingRequest {
    /**
     *
     * @type {Array<LagoonLicensePacksUpdatingRequestLicensePackQuantities>}
     * @memberof LagoonLicensePacksUpdatingRequest
     */
    licensePackQuantities?: Array<LagoonLicensePacksUpdatingRequestLicensePackQuantities>;
}
/**
 *
 * @export
 * @interface LagoonLicensePacksUpdatingRequestLicensePackQuantities
 */
export interface LagoonLicensePacksUpdatingRequestLicensePackQuantities {
    /**
     *
     * @type {number}
     * @memberof LagoonLicensePacksUpdatingRequestLicensePackQuantities
     */
    desiredQuantity?: number;
    /**
     *
     * @type {string}
     * @memberof LagoonLicensePacksUpdatingRequestLicensePackQuantities
     */
    licensePackName?: string;
}
/**
 *
 * @export
 * @interface LagoonPlanChangingRequest
 */
export interface LagoonPlanChangingRequest {
    /**
     *
     * @type {string}
     * @memberof LagoonPlanChangingRequest
     */
    plan?: LagoonPlanChangingRequestPlanEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonPlanChangingRequestPlanEnum {
    Maker = "maker",
    Pro = "pro",
    Free = "free"
}
/**
 *
 * @export
 * @interface LagoonRegistrationRequest
 */
export interface LagoonRegistrationRequest {
    /**
     *
     * @type {string}
     * @memberof LagoonRegistrationRequest
     */
    plan?: LagoonRegistrationRequestPlanEnum;
    /**
     * This password is used by the initial user\'s login.
     * @type {string}
     * @memberof LagoonRegistrationRequest
     */
    userPassword?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonRegistrationRequestPlanEnum {
    Maker = "maker"
}
/**
 *
 * @export
 * @interface LagoonRegistrationResponse
 */
export interface LagoonRegistrationResponse {
    /**
     * This email address is used on login with the initial user.
     * @type {string}
     * @memberof LagoonRegistrationResponse
     */
    lagoonUserEmail?: string;
}
/**
 *
 * @export
 * @interface LagoonUser
 */
export interface LagoonUser {
    /**
     * This value used on login.
     * @type {string}
     * @memberof LagoonUser
     */
    email?: string;
    /**
     *
     * @type {number}
     * @memberof LagoonUser
     */
    id?: number;
    /**
     * The last login datetime.
     * @type {string}
     * @memberof LagoonUser
     */
    lastSeenAt?: string;
    /**
     * The last login datetime as age.
     * @type {string}
     * @memberof LagoonUser
     */
    lastSeenAtAge?: string;
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUser
     */
    role?: LagoonUserRoleEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonUserRoleEnum {
    Viewer = "Viewer",
    Editor = "Editor"
}
/**
 *
 * @export
 * @interface LagoonUserCreationRequest
 */
export interface LagoonUserCreationRequest {
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    role?: LagoonUserCreationRequestRoleEnum;
    /**
     *
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    userEmail?: string;
    /**
     *
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    userPassword?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonUserCreationRequestRoleEnum {
    Viewer = "Viewer",
    Editor = "Editor"
}
/**
 *
 * @export
 * @interface LagoonUserCreationResponse
 */
export interface LagoonUserCreationResponse {
    /**
     * Lagoon user ID assigned to the created user.
     * @type {number}
     * @memberof LagoonUserCreationResponse
     */
    id?: number;
}
/**
 *
 * @export
 * @interface LagoonUserEmailUpdatingRequest
 */
export interface LagoonUserEmailUpdatingRequest {
    /**
     *
     * @type {string}
     * @memberof LagoonUserEmailUpdatingRequest
     */
    userEmail?: string;
}
/**
 *
 * @export
 * @interface LagoonUserPasswordUpdatingRequest
 */
export interface LagoonUserPasswordUpdatingRequest {
    /**
     *
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    newPassword?: string;
    /**
     *
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    oldPassword?: string;
    /**
     *
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    userEmail?: string;
}
/**
 *
 * @export
 * @interface LagoonUserPermissionUpdatingRequest
 */
export interface LagoonUserPermissionUpdatingRequest {
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUserPermissionUpdatingRequest
     */
    role?: LagoonUserPermissionUpdatingRequestRoleEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LagoonUserPermissionUpdatingRequestRoleEnum {
    Viewer = "Viewer",
    Editor = "Editor"
}
/**
 *
 * @export
 * @interface LastSeen
 */
export interface LastSeen {
    /**
     *
     * @type {number}
     * @memberof LastSeen
     */
    rssi?: number;
    /**
     *
     * @type {number}
     * @memberof LastSeen
     */
    snr?: number;
    /**
     *
     * @type {string}
     * @memberof LastSeen
     */
    time?: string;
}
/**
 *
 * @export
 * @interface ListCouponResponse
 */
export interface ListCouponResponse {
    /**
     * Coupons
     * @type {Array<CouponResponse>}
     * @memberof ListCouponResponse
     */
    couponList?: Array<CouponResponse>;
}
/**
 *
 * @export
 * @interface ListOrderResponse
 */
export interface ListOrderResponse {
    /**
     * List of confirmed orders
     * @type {Array<GetOrderResponse>}
     * @memberof ListOrderResponse
     */
    orderList?: Array<GetOrderResponse>;
}
/**
 *
 * @export
 * @interface ListOrderedSubscriberResponse
 */
export interface ListOrderedSubscriberResponse {
    /**
     * List of ordered SIMs
     * @type {Array<OrderedSubscriber>}
     * @memberof ListOrderedSubscriberResponse
     */
    orderedSubscriberList?: Array<OrderedSubscriber>;
}
/**
 *
 * @export
 * @interface ListPaymentStatementResponse
 */
export interface ListPaymentStatementResponse {
    /**
     * Payment statements
     * @type {Array<PaymentStatementResponse>}
     * @memberof ListPaymentStatementResponse
     */
    paymentStatementsList?: Array<PaymentStatementResponse>;
}
/**
 *
 * @export
 * @interface ListProductResponse
 */
export interface ListProductResponse {
    /**
     *
     * @type {Array<ProductModel>}
     * @memberof ListProductResponse
     */
    productList?: Array<ProductModel>;
    /**
     *
     * @type {Array<ShippingCostModel>}
     * @memberof ListProductResponse
     */
    shippingCostList?: Array<ShippingCostModel>;
}
/**
 *
 * @export
 * @interface ListRolesResponse
 */
export interface ListRolesResponse {
    /**
     *
     * @type {number}
     * @memberof ListRolesResponse
     */
    createDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof ListRolesResponse
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof ListRolesResponse
     */
    roleId?: string;
    /**
     *
     * @type {number}
     * @memberof ListRolesResponse
     */
    updateDateTime?: number;
}
/**
 *
 * @export
 * @interface ListShippingAddressResponse
 */
export interface ListShippingAddressResponse {
    /**
     *
     * @type {Array<GetShippingAddressResponse>}
     * @memberof ListShippingAddressResponse
     */
    shippingAddresses?: Array<GetShippingAddressResponse>;
}
/**
 *
 * @export
 * @interface ListSubOperatorsResponse
 */
export interface ListSubOperatorsResponse {
    /**
     *
     * @type {string}
     * @memberof ListSubOperatorsResponse
     */
    operatorId?: string;
}
/**
 *
 * @export
 * @interface ListVolumeDiscountResponse
 */
export interface ListVolumeDiscountResponse {
    /**
     * Contracted long term discounts
     * @type {Array<GetVolumeDiscountResponse>}
     * @memberof ListVolumeDiscountResponse
     */
    volumeDiscountList?: Array<GetVolumeDiscountResponse>;
}
/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     *
     * @type {object}
     * @memberof LogEntry
     */
    body?: object;
    /**
     *
     * @type {string}
     * @memberof LogEntry
     */
    resourceId?: string;
    /**
     *
     * @type {string}
     * @memberof LogEntry
     */
    resourceType?: LogEntryResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof LogEntry
     */
    service?: LogEntryServiceEnum;
    /**
     *
     * @type {number}
     * @memberof LogEntry
     */
    time?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LogEntryResourceTypeEnum {
    Subscriber = "Subscriber",
    EventHandler = "EventHandler",
    VirtualPrivateGateway = "VirtualPrivateGateway"
}
/**
    * @export
    * @enum {string}
    */
export declare enum LogEntryServiceEnum {
    Air = "Air",
    Beam = "Beam",
    Canal = "Canal",
    Direct = "Direct",
    Door = "Door",
    Endorse = "Endorse",
    Funnel = "Funnel",
    Gate = "Gate"
}
/**
 *
 * @export
 * @interface LoraData
 */
export interface LoraData {
    /**
     *
     * @type {string}
     * @memberof LoraData
     */
    data?: string;
    /**
     *
     * @type {number}
     * @memberof LoraData
     */
    fPort?: number;
}
/**
 *
 * @export
 * @interface LoraDevice
 */
export interface LoraDevice {
    /**
     *
     * @type {string}
     * @memberof LoraDevice
     */
    deviceId?: string;
    /**
     *
     * @type {string}
     * @memberof LoraDevice
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof LoraDevice
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {LastSeen}
     * @memberof LoraDevice
     */
    lastSeen?: LastSeen;
    /**
     *
     * @type {string}
     * @memberof LoraDevice
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof LoraDevice
     */
    status?: LoraDeviceStatusEnum;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof LoraDevice
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof LoraDevice
     */
    terminationEnabled?: boolean;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LoraDeviceStatusEnum {
    Active = "active",
    Ready = "ready",
    Terminated = "terminated",
    Instock = "instock"
}
/**
 *
 * @export
 * @interface LoraGateway
 */
export interface LoraGateway {
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    address?: string;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    createdTime?: string;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    gatewayId?: string;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    networkSetId?: string;
    /**
     *
     * @type {boolean}
     * @memberof LoraGateway
     */
    online?: boolean;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    operatorId?: string;
    /**
     *
     * @type {boolean}
     * @memberof LoraGateway
     */
    owned?: boolean;
    /**
     *
     * @type {string}
     * @memberof LoraGateway
     */
    status?: LoraGatewayStatusEnum;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof LoraGateway
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof LoraGateway
     */
    terminationEnabled?: boolean;
}
/**
    * @export
    * @enum {string}
    */
export declare enum LoraGatewayStatusEnum {
    Active = "active",
    Terminated = "terminated",
    Ready = "ready",
    Instock = "instock"
}
/**
 *
 * @export
 * @interface LoraNetworkSet
 */
export interface LoraNetworkSet {
    /**
     *
     * @type {Set<string>}
     * @memberof LoraNetworkSet
     */
    allowedOperators?: Set<string>;
    /**
     *
     * @type {string}
     * @memberof LoraNetworkSet
     */
    createdTime?: string;
    /**
     *
     * @type {string}
     * @memberof LoraNetworkSet
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {string}
     * @memberof LoraNetworkSet
     */
    networkSetId?: string;
    /**
     *
     * @type {string}
     * @memberof LoraNetworkSet
     */
    operatorId?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof LoraNetworkSet
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface MFAAuthenticationRequest
 */
export interface MFAAuthenticationRequest {
    /**
     *
     * @type {string}
     * @memberof MFAAuthenticationRequest
     */
    mfaOTPCode?: string;
}
/**
 *
 * @export
 * @interface MFAIssueRevokingTokenRequest
 */
export interface MFAIssueRevokingTokenRequest {
    /**
     *
     * @type {string}
     * @memberof MFAIssueRevokingTokenRequest
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof MFAIssueRevokingTokenRequest
     */
    password?: string;
}
/**
 *
 * @export
 * @interface MFARevokingTokenVerifyRequest
 */
export interface MFARevokingTokenVerifyRequest {
    /**
     *
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    backupCode?: string;
    /**
     *
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    token?: string;
}
/**
 *
 * @export
 * @interface MFAStatusOfUseResponse
 */
export interface MFAStatusOfUseResponse {
    /**
     *
     * @type {string}
     * @memberof MFAStatusOfUseResponse
     */
    status?: string;
}
/**
 *
 * @export
 * @interface MappingEntries
 */
export interface MappingEntries {
    /**
     *
     * @type {Array<GlobalSimAppletPLMNRecord>}
     * @memberof MappingEntries
     */
    mappingEntries?: Array<GlobalSimAppletPLMNRecord>;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    fields?: string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 *
 * @export
 * @interface MonthlyBill
 */
export interface MonthlyBill {
    /**
     * 金額
     * @type {number}
     * @memberof MonthlyBill
     */
    amount?: number;
    /**
     * 直近の課金ステータス
     * @type {string}
     * @memberof MonthlyBill
     */
    paymentStatus?: MonthlyBillPaymentStatusEnum;
    /**
     * 課金詳細取得用のID
     * @type {string}
     * @memberof MonthlyBill
     */
    paymentTransactionId?: string;
    /**
     * 年月
     * @type {string}
     * @memberof MonthlyBill
     */
    yearMonth?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum MonthlyBillPaymentStatusEnum {
    LessThanMinimumCharge = "lessThanMinimumCharge",
    Paying = "paying",
    Paid = "paid",
    Refunding = "refunding",
    Refunded = "refunded",
    Fail = "fail"
}
/**
 *
 * @export
 * @interface NapterAuditLogDirection
 */
export interface NapterAuditLogDirection {
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogDirection
     */
    destinationIPAddress?: string;
    /**
     *
     * @type {number}
     * @memberof NapterAuditLogDirection
     */
    destinationPort?: number;
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogDirection
     */
    sourceIPAddress?: string;
    /**
     *
     * @type {number}
     * @memberof NapterAuditLogDirection
     */
    sourcePort?: number;
}
/**
 *
 * @export
 * @interface NapterAuditLogEntry
 */
export interface NapterAuditLogEntry {
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    connectionId?: string;
    /**
     *
     * @type {number}
     * @memberof NapterAuditLogEntry
     */
    createdAt?: number;
    /**
     *
     * @type {NapterAuditLogDirection}
     * @memberof NapterAuditLogEntry
     */
    direction?: NapterAuditLogDirection;
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    imsi?: string;
    /**
     *
     * @type {boolean}
     * @memberof NapterAuditLogEntry
     */
    isTLS?: boolean;
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    type?: NapterAuditLogEntryTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum NapterAuditLogEntryTypeEnum {
    Access = "ACCESS",
    Denied = "DENIED",
    Connected = "CONNECTED",
    Closed = "CLOSED",
    Refused = "REFUSED",
    Created = "CREATED",
    Deleted = "DELETED",
    Expired = "EXPIRED"
}
/**
 *
 * @export
 * @interface NapterAuditLogsExportedDataStatsResponse
 */
export interface NapterAuditLogsExportedDataStatsResponse {
    /**
     * exportedBytes
     * @type {number}
     * @memberof NapterAuditLogsExportedDataStatsResponse
     */
    exportedBytes?: number;
    /**
     * yearMonth
     * @type {string}
     * @memberof NapterAuditLogsExportedDataStatsResponse
     */
    yearMonth?: string;
}
/**
 *
 * @export
 * @interface ObjectInstance
 */
export interface ObjectInstance {
    /**
     *
     * @type {number}
     * @memberof ObjectInstance
     */
    id?: number;
    /**
     *
     * @type {boolean}
     * @memberof ObjectInstance
     */
    observed?: boolean;
    /**
     *
     * @type {{ [key: string]: ResourceInstance; }}
     * @memberof ObjectInstance
     */
    resources?: {
        [key: string]: ResourceInstance;
    };
}
/**
 *
 * @export
 * @interface OpenGateRequest
 */
export interface OpenGateRequest {
    /**
     *
     * @type {boolean}
     * @memberof OpenGateRequest
     */
    privacySeparatorEnabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof OpenGateRequest
     */
    vxlanId?: number;
}
/**
 *
 * @export
 * @interface OperatorMFAVerifyingResponse
 */
export interface OperatorMFAVerifyingResponse {
    /**
     *
     * @type {Array<string>}
     * @memberof OperatorMFAVerifyingResponse
     */
    backupCodes?: Array<string>;
}
/**
 *
 * @export
 * @interface OrderItemModel
 */
export interface OrderItemModel {
    /**
     * Product code
     * @type {string}
     * @memberof OrderItemModel
     */
    productCode?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderItemModel
     */
    quantity?: number;
}
/**
 *
 * @export
 * @interface OrderedSubscriber
 */
export interface OrderedSubscriber {
    /**
     * IMSI
     * @type {string}
     * @memberof OrderedSubscriber
     */
    imsi?: string;
    /**
     * MSISDN
     * @type {string}
     * @memberof OrderedSubscriber
     */
    msisdn?: string;
    /**
     * serialNumber
     * @type {string}
     * @memberof OrderedSubscriber
     */
    serialNumber?: string;
}
/**
 *
 * @export
 * @interface PacketCaptureSession
 */
export interface PacketCaptureSession {
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    createdTime?: string;
    /**
     *
     * @type {number}
     * @memberof PacketCaptureSession
     */
    duration?: number;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    endedTime?: string;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    failedReason?: string;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    prefix?: string;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    startedTime?: string;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    status?: PacketCaptureSessionStatusEnum;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSession
     */
    url?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum PacketCaptureSessionStatusEnum {
    Requested = "REQUESTED",
    Accepted = "ACCEPTED",
    Capturing = "CAPTURING",
    PostProcessing = "POST_PROCESSING",
    Done = "DONE",
    Failed = "FAILED"
}
/**
 *
 * @export
 * @interface PacketCaptureSessionRequest
 */
export interface PacketCaptureSessionRequest {
    /**
     *
     * @type {number}
     * @memberof PacketCaptureSessionRequest
     */
    duration: number;
    /**
     *
     * @type {string}
     * @memberof PacketCaptureSessionRequest
     */
    prefix?: string;
}
/**
 *
 * @export
 * @interface PaymentAmount
 */
export interface PaymentAmount {
    /**
     *
     * @type {number}
     * @memberof PaymentAmount
     */
    taxAmount?: number;
    /**
     *
     * @type {number}
     * @memberof PaymentAmount
     */
    totalAmount?: number;
}
/**
 *
 * @export
 * @interface PaymentDescription
 */
export interface PaymentDescription {
    /**
     *
     * @type {string}
     * @memberof PaymentDescription
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PaymentDescription
     */
    itemList?: Array<string>;
}
/**
 *
 * @export
 * @interface PaymentStatementResponse
 */
export interface PaymentStatementResponse {
    /**
     * Amount
     * @type {number}
     * @memberof PaymentStatementResponse
     */
    amount?: number;
    /**
     * Payment date time
     * @type {number}
     * @memberof PaymentStatementResponse
     */
    paymentDateTime?: number;
    /**
     * Payment instrument
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentInstrument?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentMethod?: string;
    /**
     * Payment statement ID
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentStatementId?: string;
    /**
     * Payment statement information
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentStatementInfo?: string;
}
/**
 *
 * @export
 * @interface Placement
 */
export interface Placement {
    /**
     *
     * @type {string}
     * @memberof Placement
     */
    region?: string;
}
/**
 *
 * @export
 * @interface PortMapping
 */
export interface PortMapping {
    /**
     *
     * @type {PortMappingDestination}
     * @memberof PortMapping
     */
    destination?: PortMappingDestination;
    /**
     * The duration that remote access is enabled, in seconds.
     * @type {number}
     * @memberof PortMapping
     */
    duration?: number;
    /**
     * SORACOM Napter endpoint (IP address and port number) for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    endpoint?: string;
    /**
     * SORACOM Napter hostname for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    hostname?: string;
    /**
     * SORACOM Napter IP Address for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    ipAddress?: string;
    /**
     * SORACOM Napter port number for remote access.
     * @type {number}
     * @memberof PortMapping
     */
    port?: number;
    /**
     *
     * @type {PortMappingSource}
     * @memberof PortMapping
     */
    source?: PortMappingSource;
    /**
     * Indicates TLS is required.
     * @type {boolean}
     * @memberof PortMapping
     */
    tlsRequired?: boolean;
}
/**
 *
 * @export
 * @interface PortMappingDestination
 */
export interface PortMappingDestination {
    /**
     * The target IMSI of the subscriber.
     * @type {string}
     * @memberof PortMappingDestination
     */
    imsi: string;
    /**
     * The port on your device used for access.
     * @type {number}
     * @memberof PortMappingDestination
     */
    port: number;
}
/**
 *
 * @export
 * @interface PortMappingSource
 */
export interface PortMappingSource {
    /**
     * The range of IP addresses in CIDR notation which will be allowed to access the port mapping.
     * @type {Array<string>}
     * @memberof PortMappingSource
     */
    ipRanges?: Array<string>;
}
/**
 *
 * @export
 * @interface PreviousSessionStatus
 */
export interface PreviousSessionStatus {
    /**
     *
     * @type {Cell}
     * @memberof PreviousSessionStatus
     */
    cell?: Cell;
    /**
     * The time when the previous session was created.
     * @type {number}
     * @memberof PreviousSessionStatus
     */
    createdTime?: number;
    /**
     * Thetime when the previous session was deleted.
     * @type {number}
     * @memberof PreviousSessionStatus
     */
    deletedTime?: number;
    /**
     * Array of IP address of the DNS servers.
     * @type {Array<string>}
     * @memberof PreviousSessionStatus
     */
    dnsServers?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    gatewayPrivateIpAddress?: string;
    /**
     *
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    imei?: string;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    vpgId?: string;
}
/**
 *
 * @export
 * @interface ProductModel
 */
export interface ProductModel {
    /**
     * Count
     * @type {number}
     * @memberof ProductModel
     */
    count?: number;
    /**
     * Max quantity
     * @type {number}
     * @memberof ProductModel
     */
    maxQuantity?: number;
    /**
     * Price
     * @type {number}
     * @memberof ProductModel
     */
    price?: number;
    /**
     * Product code
     * @type {string}
     * @memberof ProductModel
     */
    productCode?: string;
    /**
     * URL of product page
     * @type {string}
     * @memberof ProductModel
     */
    productInfoURL?: string;
    /**
     * Product name
     * @type {string}
     * @memberof ProductModel
     */
    productName?: string;
    /**
     * Product type
     * @type {string}
     * @memberof ProductModel
     */
    productType?: ProductModelProductTypeEnum;
    /**
     * Properties
     * @type {{ [key: string]: string; }}
     * @memberof ProductModel
     */
    properties?: {
        [key: string]: string;
    };
}
/**
    * @export
    * @enum {string}
    */
export declare enum ProductModelProductTypeEnum {
    Sim = "sim",
    NetworkModule = "network_module"
}
/**
 *
 * @export
 * @interface PutIpAddressMapEntryRequest
 */
export interface PutIpAddressMapEntryRequest {
    /**
     *
     * @type {string}
     * @memberof PutIpAddressMapEntryRequest
     */
    ipAddress: string;
    /**
     *
     * @type {string}
     * @memberof PutIpAddressMapEntryRequest
     */
    key: string;
}
/**
 *
 * @export
 * @interface RegisterGatePeerRequest
 */
export interface RegisterGatePeerRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterGatePeerRequest
     */
    innerIpAddress?: string;
    /**
     *
     * @type {string}
     * @memberof RegisterGatePeerRequest
     */
    outerIpAddress: string;
}
/**
 *
 * @export
 * @interface RegisterLoraDeviceRequest
 */
export interface RegisterLoraDeviceRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterLoraDeviceRequest
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof RegisterLoraDeviceRequest
     */
    registrationSecret?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof RegisterLoraDeviceRequest
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface RegisterOperatorsRequest
 */
export interface RegisterOperatorsRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterOperatorsRequest
     */
    email: string;
    /**
     * パスワードは以下の条件を満たしている必要があります：長さ 8 文字以上100 文字以内、アルファベット小文字 (a-z) を 1 文字以上使用、アルファベット大文字 (A-Z) を 1 文字以上使用、数字を 1 文字以上使用。記号なども使用できます。
     * @type {string}
     * @memberof RegisterOperatorsRequest
     */
    password: string;
}
/**
 *
 * @export
 * @interface RegisterPayerInformationModel
 */
export interface RegisterPayerInformationModel {
    /**
     * Company name
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    companyName?: string;
    /**
     * Department
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    department?: string;
    /**
     * Full name
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    fullName?: string;
}
/**
 *
 * @export
 * @interface RegisterSimRequest
 */
export interface RegisterSimRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterSimRequest
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof RegisterSimRequest
     */
    registrationSecret: string;
    /**
     *
     * @type {Array<TagUpdateRequest>}
     * @memberof RegisterSimRequest
     */
    tags?: Array<TagUpdateRequest>;
}
/**
 *
 * @export
 * @interface RegisterSubscribersRequest
 */
export interface RegisterSubscribersRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterSubscribersRequest
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof RegisterSubscribersRequest
     */
    registrationSecret: string;
    /**
     *
     * @type {Array<TagUpdateRequest>}
     * @memberof RegisterSubscribersRequest
     */
    tags?: Array<TagUpdateRequest>;
}
/**
 *
 * @export
 * @interface ResourceInstance
 */
export interface ResourceInstance {
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof ResourceInstance
     */
    id?: number;
    /**
     *
     * @type {boolean}
     * @memberof ResourceInstance
     */
    mandatory?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ResourceInstance
     */
    multiple?: boolean;
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof ResourceInstance
     */
    observed?: boolean;
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    operations?: ResourceInstanceOperationsEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    rangeEnumeration?: string;
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    type?: ResourceInstanceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceInstance
     */
    units?: string;
    /**
     *
     * @type {object}
     * @memberof ResourceInstance
     */
    value?: object;
    /**
     *
     * @type {object}
     * @memberof ResourceInstance
     */
    values?: object;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ResourceInstanceOperationsEnum {
    None = "NONE",
    R = "R",
    W = "W",
    Rw = "RW",
    E = "E",
    Re = "RE",
    We = "WE",
    Rwe = "RWE"
}
/**
    * @export
    * @enum {string}
    */
export declare enum ResourceInstanceTypeEnum {
    String = "STRING",
    Integer = "INTEGER",
    Float = "FLOAT",
    Boolean = "BOOLEAN",
    Opaque = "OPAQUE",
    Time = "TIME",
    Objlnk = "OBJLNK"
}
/**
 *
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     *
     * @type {number}
     * @memberof RoleResponse
     */
    createDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof RoleResponse
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof RoleResponse
     */
    permission?: string;
    /**
     *
     * @type {string}
     * @memberof RoleResponse
     */
    roleId?: string;
    /**
     *
     * @type {number}
     * @memberof RoleResponse
     */
    updateDateTime?: number;
}
/**
 *
 * @export
 * @interface RoutingFilterEntry
 */
export interface RoutingFilterEntry {
    /**
     * Whether to allow or deny the outbound packets with a destination in the specified range
     * @type {string}
     * @memberof RoutingFilterEntry
     */
    action: RoutingFilterEntryActionEnum;
    /**
     * IPv4 address range in CIDR format, e.g. a.b.c.d/x
     * @type {string}
     * @memberof RoutingFilterEntry
     */
    ipRange: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum RoutingFilterEntryActionEnum {
    Allow = "allow",
    Deny = "deny"
}
/**
 *
 * @export
 * @interface RuleConfig
 */
export interface RuleConfig {
    /**
     *
     * @type {RuleConfigProperty}
     * @memberof RuleConfig
     */
    properties: RuleConfigProperty;
    /**
     *
     * @type {string}
     * @memberof RuleConfig
     */
    type: RuleConfigTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum RuleConfigTypeEnum {
    SubscriberDailyTrafficRule = "SubscriberDailyTrafficRule",
    SubscriberMonthlyTrafficRule = "SubscriberMonthlyTrafficRule",
    SubscriberCumulativeTrafficRule = "SubscriberCumulativeTrafficRule",
    SubscriberFirstTrafficRule = "SubscriberFirstTrafficRule",
    DailyTotalTrafficRule = "DailyTotalTrafficRule",
    MonthlyTotalTrafficRule = "MonthlyTotalTrafficRule",
    SubscriberStatusAttributeRule = "SubscriberStatusAttributeRule",
    SubscriberSpeedClassAttributeRule = "SubscriberSpeedClassAttributeRule",
    SubscriberExpiredRule = "SubscriberExpiredRule",
    SimDailyTotalTrafficRule = "SimDailyTotalTrafficRule",
    SimMonthlyTotalTrafficRule = "SimMonthlyTotalTrafficRule",
    SimCumulativeTotalTrafficRule = "SimCumulativeTotalTrafficRule",
    SimStatusAttributeRule = "SimStatusAttributeRule",
    SimSpeedClassAttributeRule = "SimSpeedClassAttributeRule",
    SimExpiredRule = "SimExpiredRule",
    SimSubscriptionStatusRule = "SimSubscriptionStatusRule"
}
/**
 *
 * @export
 * @interface RuleConfigProperty
 */
export interface RuleConfigProperty {
    /**
     *
     * @type {string}
     * @memberof RuleConfigProperty
     */
    inactiveTimeoutDateConst?: RuleConfigPropertyInactiveTimeoutDateConstEnum;
    /**
     *
     * @type {number}
     * @memberof RuleConfigProperty
     */
    inactiveTimeoutOffsetMinutes?: number;
    /**
     *
     * @type {number}
     * @memberof RuleConfigProperty
     */
    limitTotalTrafficMegaByte: number;
    /**
     *
     * @type {boolean}
     * @memberof RuleConfigProperty
     */
    runOnceAmongTarget?: boolean;
    /**
     * Only for SimSubscriptionStatusRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetOtaStatus?: RuleConfigPropertyTargetOtaStatusEnum;
    /**
     * Only for SubscriberSpeedClassAttributeRule, SimSpeedClassAttributeRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetSpeedClass?: RuleConfigPropertyTargetSpeedClassEnum;
    /**
     * Only for SubscriberStatusAttributeRule, SimStatusAttributeRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetStatus?: RuleConfigPropertyTargetStatusEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum RuleConfigPropertyInactiveTimeoutDateConstEnum {
    Immediately = "IMMEDIATELY",
    BeginningOfNextMonth = "BEGINNING_OF_NEXT_MONTH",
    BeginningOfNextDay = "BEGINNING_OF_NEXT_DAY",
    AfterOneDay = "AFTER_ONE_DAY",
    Never = "NEVER"
}
/**
    * @export
    * @enum {string}
    */
export declare enum RuleConfigPropertyTargetOtaStatusEnum {
    Started = "started",
    Finished = "finished",
    Failed = "failed"
}
/**
    * @export
    * @enum {string}
    */
export declare enum RuleConfigPropertyTargetSpeedClassEnum {
    Minimum = "s1.minimum",
    Slow = "s1.slow",
    Standard = "s1.standard",
    Fast = "s1.fast"
}
/**
    * @export
    * @enum {string}
    */
export declare enum RuleConfigPropertyTargetStatusEnum {
    Ready = "ready",
    Active = "active",
    Inactive = "inactive",
    Suspended = "suspended",
    Terminated = "terminated"
}
/**
 *
 * @export
 * @interface SessionEvent
 */
export interface SessionEvent {
    /**
     * The Access Point Name confirured.
     * @type {string}
     * @memberof SessionEvent
     */
    apn?: string;
    /**
     * First IP address of DNS servers.
     * @type {string}
     * @memberof SessionEvent
     */
    dns0?: string;
    /**
     * Second IP address of DNS servers.
     * @type {string}
     * @memberof SessionEvent
     */
    dns1?: string;
    /**
     * The type of behavior for the event. Possible values are \"Created\" indicates the device created a new session, \"Modified\" indicates that an existing connection was modified, \"Deleted\" indicates a network connection was closed.
     * @type {string}
     * @memberof SessionEvent
     */
    event?: string;
    /**
     *
     * @type {string}
     * @memberof SessionEvent
     */
    gatewayPrivateIpAddress?: string;
    /**
     *
     * @type {string}
     * @memberof SessionEvent
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof SessionEvent
     */
    imei?: string;
    /**
     * The IMSI of the SIM.
     * @type {string}
     * @memberof SessionEvent
     */
    imsi?: string;
    /**
     * The operator ID of the session event.
     * @type {string}
     * @memberof SessionEvent
     */
    operatorId?: string;
    /**
     * The timestamp of the session event.
     * @type {number}
     * @memberof SessionEvent
     */
    time?: number;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof SessionEvent
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof SessionEvent
     */
    vpgId?: string;
}
/**
 *
 * @export
 * @interface SessionStatus
 */
export interface SessionStatus {
    /**
     *
     * @type {Cell}
     * @memberof SessionStatus
     */
    cell?: Cell;
    /**
     * Array of IP address of the DNS servers.
     * @type {Array<string>}
     * @memberof SessionStatus
     */
    dnsServers?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SessionStatus
     */
    gatewayPrivateIpAddress?: string;
    /**
     *
     * @type {string}
     * @memberof SessionStatus
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof SessionStatus
     */
    imei?: string;
    /**
     *
     * @type {number}
     * @memberof SessionStatus
     */
    lastUpdatedAt?: number;
    /**
     * Whether or not the SIM is online.
     * @type {boolean}
     * @memberof SessionStatus
     */
    online?: boolean;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof SessionStatus
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof SessionStatus
     */
    vpgId?: string;
}
/**
 *
 * @export
 * @interface SetDeviceObjectModelScopeRequest
 */
export interface SetDeviceObjectModelScopeRequest {
    /**
     *
     * @type {string}
     * @memberof SetDeviceObjectModelScopeRequest
     */
    scope?: string;
}
/**
 *
 * @export
 * @interface SetGroupRequest
 */
export interface SetGroupRequest {
    /**
     *
     * @type {string}
     * @memberof SetGroupRequest
     */
    groupId?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof SetGroupRequest
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface SetImeiLockRequest
 */
export interface SetImeiLockRequest {
    /**
     *
     * @type {string}
     * @memberof SetImeiLockRequest
     */
    imei?: string;
}
/**
 *
 * @export
 * @interface SetNetworkSetRequest
 */
export interface SetNetworkSetRequest {
    /**
     *
     * @type {string}
     * @memberof SetNetworkSetRequest
     */
    networkSetId?: string;
}
/**
 *
 * @export
 * @interface SetSystemNotificationsRequest
 */
export interface SetSystemNotificationsRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof SetSystemNotificationsRequest
     */
    emailIdList: Array<string>;
    /**
     * Password of the operator. This is necessary when type is primary.
     * @type {string}
     * @memberof SetSystemNotificationsRequest
     */
    password?: string;
}
/**
 *
 * @export
 * @interface SetUserPermissionRequest
 */
export interface SetUserPermissionRequest {
    /**
     *
     * @type {string}
     * @memberof SetUserPermissionRequest
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof SetUserPermissionRequest
     */
    permission: string;
}
/**
 *
 * @export
 * @interface ShippingAddressModel
 */
export interface ShippingAddressModel {
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    addressLine1: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    addressLine2?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    building?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    city: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    companyName?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    countryCode?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    department?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    fullName?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    phoneNumber?: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    state: string;
    /**
     *
     * @type {string}
     * @memberof ShippingAddressModel
     */
    zipCode: string;
}
/**
 * Shipping cost
 * @export
 * @interface ShippingCostModel
 */
export interface ShippingCostModel {
    /**
     * (Japan coverage only) Shipping area
     * @type {string}
     * @memberof ShippingCostModel
     */
    shippingArea?: ShippingCostModelShippingAreaEnum;
    /**
     * Shipping Area name
     * @type {string}
     * @memberof ShippingCostModel
     */
    shippingAreaName?: string;
    /**
     * Shipping Cost
     * @type {number}
     * @memberof ShippingCostModel
     */
    shippingCost?: number;
    /**
     * Size
     * @type {number}
     * @memberof ShippingCostModel
     */
    size?: number;
}
/**
    * @export
    * @enum {string}
    */
export declare enum ShippingCostModelShippingAreaEnum {
    Hokkaido = "hokkaido",
    KitaTohoku = "kita_tohoku",
    MinamiTohoku = "minami_tohoku",
    Kanto = "kanto",
    Shinetsu = "shinetsu",
    Chubu = "chubu",
    Hokuriku = "hokuriku",
    Kansai = "kansai",
    Chugoku = "chugoku",
    Shikoku = "shikoku",
    Kyushu = "kyushu",
    Okinawa = "okinawa"
}
/**
 *
 * @export
 * @interface SigfoxData
 */
export interface SigfoxData {
    /**
     *
     * @type {string}
     * @memberof SigfoxData
     */
    data?: string;
}
/**
 *
 * @export
 * @interface SigfoxDevice
 */
export interface SigfoxDevice {
    /**
     *
     * @type {string}
     * @memberof SigfoxDevice
     */
    deviceId?: string;
    /**
     *
     * @type {string}
     * @memberof SigfoxDevice
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof SigfoxDevice
     */
    lastModifiedTime?: string;
    /**
     *
     * @type {LastSeen}
     * @memberof SigfoxDevice
     */
    lastSeen?: LastSeen;
    /**
     *
     * @type {string}
     * @memberof SigfoxDevice
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof SigfoxDevice
     */
    status?: SigfoxDeviceStatusEnum;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof SigfoxDevice
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof SigfoxDevice
     */
    terminationEnabled?: boolean;
}
/**
    * @export
    * @enum {string}
    */
export declare enum SigfoxDeviceStatusEnum {
    Active = "active",
    Ready = "ready",
    Terminated = "terminated",
    Instock = "instock"
}
/**
 *
 * @export
 * @interface SigfoxRegistrationRequest
 */
export interface SigfoxRegistrationRequest {
    /**
     *
     * @type {string}
     * @memberof SigfoxRegistrationRequest
     */
    registrationSecret?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof SigfoxRegistrationRequest
     */
    tags?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface Sim
 */
export interface Sim {
    /**
     *
     * @type {number}
     * @memberof Sim
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    groupId?: string;
    /**
     *
     * @type {number}
     * @memberof Sim
     */
    lastModifiedTime?: number;
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    otaSerialNumber?: string;
    /**
     *
     * @type {{ [key: string]: SimProfile; }}
     * @memberof Sim
     */
    profiles?: {
        [key: string]: SimProfile;
    };
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    simId?: string;
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    speedClass?: string;
    /**
     *
     * @type {string}
     * @memberof Sim
     */
    type?: SimTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum SimTypeEnum {
    Uicc = "uicc",
    Euicc = "euicc"
}
/**
 *
 * @export
 * @interface SimProfile
 */
export interface SimProfile {
    /**
     *
     * @type {string}
     * @memberof SimProfile
     */
    iccid?: string;
    /**
     *
     * @type {{ [key: string]: Subscriber; }}
     * @memberof SimProfile
     */
    subscribers?: {
        [key: string]: Subscriber;
    };
}
/**
 *
 * @export
 * @interface SmsForwardingReport
 */
export interface SmsForwardingReport {
    /**
     *
     * @type {string}
     * @memberof SmsForwardingReport
     */
    messageId?: string;
}
/**
 *
 * @export
 * @interface SmsForwardingRequest
 */
export interface SmsForwardingRequest {
    /**
     * Encoding type of the message body. `1` indicates the body is `DCS_7BIT` that only supports single byte characters. `2` is `DCS_UCS2` that supports multi-byte text. When omitted, it is treated as `2` (`DCS_UCS2`).
     * @type {number}
     * @memberof SmsForwardingRequest
     */
    encodingType?: number;
    /**
     *
     * @type {string}
     * @memberof SmsForwardingRequest
     */
    payload?: string;
}
/**
 *
 * @export
 * @interface SoracomBeamStats
 */
export interface SoracomBeamStats {
    /**
     *
     * @type {number}
     * @memberof SoracomBeamStats
     */
    count?: number;
}
/**
 *
 * @export
 * @interface Soralet
 */
export interface Soralet {
    /**
     *
     * @type {number}
     * @memberof Soralet
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof Soralet
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Soralet
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof Soralet
     */
    soraletId?: string;
    /**
     *
     * @type {number}
     * @memberof Soralet
     */
    updatedTime?: number;
}
/**
 *
 * @export
 * @interface SoraletDataSource
 */
export interface SoraletDataSource {
    /**
     *
     * @type {string}
     * @memberof SoraletDataSource
     */
    resourceId: string;
    /**
     *
     * @type {string}
     * @memberof SoraletDataSource
     */
    resourceType: string;
}
/**
 *
 * @export
 * @interface SoraletLog
 */
export interface SoraletLog {
    /**
     *
     * @type {number}
     * @memberof SoraletLog
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof SoraletLog
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof SoraletLog
     */
    operatorId?: string;
    /**
     *
     * @type {string}
     * @memberof SoraletLog
     */
    soraletId?: string;
    /**
     *
     * @type {number}
     * @memberof SoraletLog
     */
    version?: number;
}
/**
 *
 * @export
 * @interface SoraletVersion
 */
export interface SoraletVersion {
    /**
     *
     * @type {number}
     * @memberof SoraletVersion
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof SoraletVersion
     */
    hash?: string;
    /**
     *
     * @type {string}
     * @memberof SoraletVersion
     */
    operatorId?: string;
    /**
     *
     * @type {number}
     * @memberof SoraletVersion
     */
    size?: number;
    /**
     *
     * @type {string}
     * @memberof SoraletVersion
     */
    soraletId?: string;
    /**
     *
     * @type {string}
     * @memberof SoraletVersion
     */
    srn?: string;
    /**
     *
     * @type {number}
     * @memberof SoraletVersion
     */
    version?: number;
}
/**
 *
 * @export
 * @interface Subscriber
 */
export interface Subscriber {
    /**
     * The Access Point Name confirured.
     * @type {string}
     * @memberof Subscriber
     */
    apn?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Subscriber
     */
    bundles?: Array<string>;
    /**
     * The timestamp that the SIM was created.
     * @type {number}
     * @memberof Subscriber
     */
    createdAt?: number;
    /**
     * The timestamp of a date and time where the SIM was expired.
     * @type {number}
     * @memberof Subscriber
     */
    expiredAt?: number;
    /**
     * The timestamp of a date and time where the SIM was expired.
     * @type {number}
     * @memberof Subscriber
     */
    expiredTime?: number;
    /**
     *
     * @type {string}
     * @memberof Subscriber
     */
    expiryAction?: SubscriberExpiryActionEnum;
    /**
     * The SIM group ID where the SIM belongs to.
     * @type {string}
     * @memberof Subscriber
     */
    groupId?: string;
    /**
     * The ICCID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    iccid?: string;
    /**
     *
     * @type {ImeiLock}
     * @memberof Subscriber
     */
    imeiLock?: ImeiLock;
    /**
     * The IMSI of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    imsi?: string;
    /**
     *
     * @type {string}
     * @memberof Subscriber
     */
    ipAddress?: string;
    /**
     * The timestamp when the SIM information was modified.
     * @type {number}
     * @memberof Subscriber
     */
    lastModifiedAt?: number;
    /**
     * The timestamp (in Unix milliseconds) of the last instance where the Napter On-Demand Remote Access service was used with the subscriber. If Napter has never been used with the subscriber, null is returned.
     * @type {number}
     * @memberof Subscriber
     */
    lastPortMappingCreatedTime?: number;
    /**
     * The form factor of the physical SIM. Possible values are \"mini\" for 2FF SIM card, \"micro\" for 3FF SIM card, \"nano\" for 4FF SIM card, \"trio\" for a Universal 3-in-1 (2FF/3FF/4FF) SIM card, or \"embedded\" for MFF2 or Embedded SIM (eSIM).
     * @type {string}
     * @memberof Subscriber
     */
    moduleType?: string;
    /**
     * The MSISDN of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    msisdn?: string;
    /**
     * The Operator ID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    operatorId?: string;
    /**
     * Whether or not the subscription supports SMS functionality. 0 = SMS not supported; 1 = SMS supported.
     * @type {number}
     * @memberof Subscriber
     */
    plan?: number;
    /**
     *
     * @type {PreviousSessionStatus}
     * @memberof Subscriber
     */
    previousSession?: PreviousSessionStatus;
    /**
     * The timestamp (in Unix milliseconds) that the subscriber was manually registered to your account. When purchasing SIMs directly through the User Console, SIMs will automatically be registered to your account, and null is returned.
     * @type {number}
     * @memberof Subscriber
     */
    registeredTime?: number;
    /**
     * The serial number of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    serialNumber?: string;
    /**
     *
     * @type {SessionStatus}
     * @memberof Subscriber
     */
    sessionStatus?: SessionStatus;
    /**
     * The SIM ID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    simId?: string;
    /**
     * The speed class of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    speedClass?: string;
    /**
     * The subscription status of the subscriber. Possible values are \"ready\", \"active\", \"inactive\", \"standby\", \"suspended\", or \"terminated\".
     * @type {string}
     * @memberof Subscriber
     */
    status?: string;
    /**
     * The name of the subscription for the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    subscription?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof Subscriber
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof Subscriber
     */
    terminationEnabled?: boolean;
    /**
     * The speed class of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    type?: string;
}
/**
    * @export
    * @enum {string}
    */
export declare enum SubscriberExpiryActionEnum {
    DoNothing = "doNothing",
    DeleteSession = "deleteSession",
    Deactivate = "deactivate",
    Suspend = "suspend",
    Terminate = "terminate"
}
/**
 *
 * @export
 * @interface SubscriptionContainer
 */
export interface SubscriptionContainer {
    /**
     *
     * @type {number}
     * @memberof SubscriptionContainer
     */
    containerId?: number;
    /**
     *
     * @type {boolean}
     * @memberof SubscriptionContainer
     */
    downloaded?: boolean;
    /**
     *
     * @type {{ [key: string]: Subscriber; }}
     * @memberof SubscriptionContainer
     */
    subscriber?: {
        [key: string]: Subscriber;
    };
}
/**
 *
 * @export
 * @interface SubscriptionContainerStatus
 */
export interface SubscriptionContainerStatus {
    /**
     *
     * @type {Array<SubscriptionContainer>}
     * @memberof SubscriptionContainerStatus
     */
    containers?: Array<SubscriptionContainer>;
    /**
     *
     * @type {{ [key: string]: SubscriptionContainerStatusCountryMapping; }}
     * @memberof SubscriptionContainerStatus
     */
    countryMapping?: {
        [key: string]: SubscriptionContainerStatusCountryMapping;
    };
}
/**
 *
 * @export
 * @interface SubscriptionContainerStatusCountryMapping
 */
export interface SubscriptionContainerStatusCountryMapping {
    /**
     *
     * @type {SubscriptionContainerStatusMappingRecord}
     * @memberof SubscriptionContainerStatusCountryMapping
     */
    mappingRecord?: SubscriptionContainerStatusMappingRecord;
    /**
     *
     * @type {string}
     * @memberof SubscriptionContainerStatusCountryMapping
     */
    plmnCode?: string;
}
/**
 *
 * @export
 * @interface SubscriptionContainerStatusMappingRecord
 */
export interface SubscriptionContainerStatusMappingRecord {
    /**
     *
     * @type {number}
     * @memberof SubscriptionContainerStatusMappingRecord
     */
    containerId?: number;
    /**
     *
     * @type {string}
     * @memberof SubscriptionContainerStatusMappingRecord
     */
    subscription?: string;
}
/**
 *
 * @export
 * @interface SupportTokenResponse
 */
export interface SupportTokenResponse {
    /**
     *
     * @type {string}
     * @memberof SupportTokenResponse
     */
    token: string;
}
/**
 *
 * @export
 * @interface SystemNotificationsModel
 */
export interface SystemNotificationsModel {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemNotificationsModel
     */
    emailIdList?: Array<string>;
    /**
     * primary / recovery / billing
     * @type {string}
     * @memberof SystemNotificationsModel
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof SystemNotificationsModel
     */
    updateDateTime?: number;
}
/**
 *
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     *
     * @type {string}
     * @memberof TagUpdateRequest
     */
    tagName: string;
    /**
     *
     * @type {string}
     * @memberof TagUpdateRequest
     */
    tagValue: string;
}
/**
 *
 * @export
 * @interface TrafficVolumeRanking
 */
export interface TrafficVolumeRanking {
    /**
     *
     * @type {string}
     * @memberof TrafficVolumeRanking
     */
    imsi?: string;
    /**
     *
     * @type {number}
     * @memberof TrafficVolumeRanking
     */
    trafficVolume?: number;
}
/**
 *
 * @export
 * @interface UpdateDefaultPermissionsRequest
 */
export interface UpdateDefaultPermissionsRequest {
    /**
     * JSON string of permissions
     * @type {string}
     * @memberof UpdateDefaultPermissionsRequest
     */
    permissions: string;
}
/**
 *
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     *
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    currentPassword: string;
    /**
     *
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    newPassword: string;
}
/**
 *
 * @export
 * @interface UpdatePermissionRequest
 */
export interface UpdatePermissionRequest {
    /**
     *
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    operatorId?: string;
}
/**
 *
 * @export
 * @interface UpdateSpeedClassRequest
 */
export interface UpdateSpeedClassRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateSpeedClassRequest
     */
    speedClass: UpdateSpeedClassRequestSpeedClassEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum UpdateSpeedClassRequestSpeedClassEnum {
    Minimum = "s1.minimum",
    Slow = "s1.slow",
    Standard = "s1.standard",
    Fast = "s1.fast"
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    description?: string;
}
/**
 *
 * @export
 * @interface UserDetailResponse
 */
export interface UserDetailResponse {
    /**
     *
     * @type {Array<AuthKeyResponse>}
     * @memberof UserDetailResponse
     */
    authKeyList?: Array<AuthKeyResponse>;
    /**
     *
     * @type {number}
     * @memberof UserDetailResponse
     */
    createDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof UserDetailResponse
     */
    description?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserDetailResponse
     */
    hasPassword?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserDetailResponse
     */
    permission?: string;
    /**
     *
     * @type {Array<ListRolesResponse>}
     * @memberof UserDetailResponse
     */
    roleList?: Array<ListRolesResponse>;
    /**
     *
     * @type {number}
     * @memberof UserDetailResponse
     */
    updateDateTime?: number;
    /**
     *
     * @type {string}
     * @memberof UserDetailResponse
     */
    userName?: string;
}
/**
 *
 * @export
 * @interface VerifyAddEmailTokenRequest
 */
export interface VerifyAddEmailTokenRequest {
    /**
     * Token sent by email
     * @type {string}
     * @memberof VerifyAddEmailTokenRequest
     */
    token: string;
}
/**
 *
 * @export
 * @interface VerifyEmailChangeTokenRequest
 */
export interface VerifyEmailChangeTokenRequest {
    /**
     *
     * @type {string}
     * @memberof VerifyEmailChangeTokenRequest
     */
    token: string;
}
/**
 *
 * @export
 * @interface VerifyOperatorsRequest
 */
export interface VerifyOperatorsRequest {
    /**
     *
     * @type {string}
     * @memberof VerifyOperatorsRequest
     */
    token: string;
}
/**
 *
 * @export
 * @interface VerifyPasswordResetTokenRequest
 */
export interface VerifyPasswordResetTokenRequest {
    /**
     *
     * @type {string}
     * @memberof VerifyPasswordResetTokenRequest
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof VerifyPasswordResetTokenRequest
     */
    token: string;
}
/**
 *
 * @export
 * @interface VerifySubscriberTransferTokenRequest
 */
export interface VerifySubscriberTransferTokenRequest {
    /**
     * トークン
     * @type {string}
     * @memberof VerifySubscriberTransferTokenRequest
     */
    token: string;
}
/**
 *
 * @export
 * @interface VerifySubscriberTransferTokenResponse
 */
export interface VerifySubscriberTransferTokenResponse {
    /**
     * 移管されたIMSIリスト
     * @type {Array<string>}
     * @memberof VerifySubscriberTransferTokenResponse
     */
    transferredImsi: Array<string>;
}
/**
 *
 * @export
 * @interface VirtualPrivateGateway
 */
export interface VirtualPrivateGateway {
    /**
     *
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    createdTime?: number;
    /**
     *
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    id?: string;
    /**
     *
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    lastModifiedTime?: number;
    /**
     *
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    operatorId?: string;
    /**
     *
     * @type {Placement}
     * @memberof VirtualPrivateGateway
     */
    placement?: Placement;
    /**
     *
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    status?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    tags?: {
        [key: string]: string;
    };
    /**
     *
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    type?: number;
    /**
     *
     * @type {boolean}
     * @memberof VirtualPrivateGateway
     */
    useInternetGateway?: boolean;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    virtualInterfaces?: {
        [key: string]: string;
    };
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    vpcPeeringConnections?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface VolumeDiscountModel
 */
export interface VolumeDiscountModel {
    /**
     * Contract months
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    contractTermMonth?: number;
    /**
     * End date
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    endDate?: string;
    /**
     * Initial cost
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    initialCost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    quantity?: number;
    /**
     * Start date
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    startDate?: string;
    /**
     * Unit price
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    volumeDiscountPaymentType?: VolumeDiscountModelVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    volumeDiscountType?: VolumeDiscountModelVolumeDiscountTypeEnum;
}
/**
    * @export
    * @enum {string}
    */
export declare enum VolumeDiscountModelVolumeDiscountPaymentTypeEnum {
    Monthly = "MONTHLY",
    Prepayment = "PREPAYMENT"
}
/**
    * @export
    * @enum {string}
    */
export declare enum VolumeDiscountModelVolumeDiscountTypeEnum {
    BasicChargeV2 = "SORACOM_AIR_BASIC_CHARGE_V2",
    BasicCharge = "SORACOM_AIR_BASIC_CHARGE",
    MonthlyFixedBasicCharge = "SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE"
}
/**
 *
 * @export
 * @interface VpcPeeringConnection
 */
export interface VpcPeeringConnection {
    /**
     *
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    destinationCidrBlock?: string;
    /**
     *
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    peerOwnerId?: string;
    /**
     *
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    peerVpcId?: string;
}
/**
 * AuditLogApi - axios parameter creator
 * @export
 */
export declare const AuditLogApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiAuditLogs: (apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogs: (resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * AuditLogApi - functional programming interface
 * @export
 */
export declare const AuditLogApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIAuditLogEntry>>>;
    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NapterAuditLogEntry>>>;
};
/**
 * AuditLogApi - factory interface
 * @export
 */
export declare const AuditLogApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<APIAuditLogEntry>>;
    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<NapterAuditLogEntry>>;
};
/**
 * AuditLogApi - interface
 * @export
 * @interface AuditLogApi
 */
export interface AuditLogApiInterface {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApiInterface
     */
    getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<APIAuditLogEntry>>;
    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApiInterface
     */
    getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<NapterAuditLogEntry>>;
}
/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export declare class AuditLogApi extends BaseAPI implements AuditLogApiInterface {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<APIAuditLogEntry[]>>;
    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<NapterAuditLogEntry[]>>;
}
/**
 * AuthApi - axios parameter creator
 * @export
 */
export declare const AuthApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auth: (auth: AuthRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuePasswordResetToken: (email: IssuePasswordResetTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPasswordResetToken: (request: VerifyPasswordResetTokenRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * AuthApi - functional programming interface
 * @export
 */
export declare const AuthApiFp: (configuration?: Configuration) => {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auth(auth: AuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>>;
    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * AuthApi - factory interface
 * @export
 */
export declare const AuthApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auth(auth: AuthRequest, options?: any): AxiosPromise<AuthResponse>;
    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): AxiosPromise<void>;
};
/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    auth(auth: AuthRequest, options?: any): AxiosPromise<AuthResponse>;
    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): AxiosPromise<void>;
}
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export declare class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    auth(auth: AuthRequest, options?: any): Promise<import("axios").AxiosResponse<AuthResponse>>;
    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * BillingApi - axios parameter creator
 * @export
 */
export declare const BillingApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBilling: (yyyyMM: string, exportMode?: 'async' | 'sync', options?: any) => Promise<RequestArgs>;
    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportLatestBilling: (exportMode?: 'async' | 'sync', options?: any) => Promise<RequestArgs>;
    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBilling: (yyyyMM: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingHistory: (options?: any) => Promise<RequestArgs>;
    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingPerDay: (yyyyMM: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestBilling: (options?: any) => Promise<RequestArgs>;
};
/**
 * BillingApi - functional programming interface
 * @export
 */
export declare const BillingApiFp: (configuration?: Configuration) => {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>>;
    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>>;
    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBilling(yyyyMM: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyBill>>;
    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingHistory(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBillingHistoryResponse>>;
    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingPerDay(yyyyMM: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DailyBillResponse>>;
    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestBilling(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLatestBill>>;
};
/**
 * BillingApi - factory interface
 * @export
 */
export declare const BillingApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBilling(yyyyMM: string, options?: any): AxiosPromise<MonthlyBill>;
    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingHistory(options?: any): AxiosPromise<GetBillingHistoryResponse>;
    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingPerDay(yyyyMM: string, options?: any): AxiosPromise<DailyBillResponse>;
    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestBilling(options?: any): AxiosPromise<GetLatestBill>;
};
/**
 * BillingApi - interface
 * @export
 * @interface BillingApi
 */
export interface BillingApiInterface {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBilling(yyyyMM: string, options?: any): AxiosPromise<MonthlyBill>;
    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBillingHistory(options?: any): AxiosPromise<GetBillingHistoryResponse>;
    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBillingPerDay(yyyyMM: string, options?: any): AxiosPromise<DailyBillResponse>;
    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getLatestBilling(options?: any): AxiosPromise<GetLatestBill>;
}
/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export declare class BillingApi extends BaseAPI implements BillingApiInterface {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): Promise<import("axios").AxiosResponse<FileExportResponse>>;
    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): Promise<import("axios").AxiosResponse<FileExportResponse>>;
    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getBilling(yyyyMM: string, options?: any): Promise<import("axios").AxiosResponse<MonthlyBill>>;
    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getBillingHistory(options?: any): Promise<import("axios").AxiosResponse<GetBillingHistoryResponse>>;
    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getBillingPerDay(yyyyMM: string, options?: any): Promise<import("axios").AxiosResponse<DailyBillResponse>>;
    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getLatestBilling(options?: any): Promise<import("axios").AxiosResponse<GetLatestBill>>;
}
/**
 * CellLocationApi - axios parameter creator
 * @export
 */
export declare const CellLocationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchGetCellLocations: (body: Array<CellIdentifier>, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCellLocation: (mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * CellLocationApi - functional programming interface
 * @export
 */
export declare const CellLocationApiFp: (configuration?: Configuration) => {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchGetCellLocations(body: Array<CellIdentifier>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CellLocation>>>;
    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellLocation>>;
};
/**
 * CellLocationApi - factory interface
 * @export
 */
export declare const CellLocationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchGetCellLocations(body: Array<CellIdentifier>, options?: any): AxiosPromise<Array<CellLocation>>;
    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): AxiosPromise<CellLocation>;
};
/**
 * CellLocationApi - interface
 * @export
 * @interface CellLocationApi
 */
export interface CellLocationApiInterface {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApiInterface
     */
    batchGetCellLocations(body: Array<CellIdentifier>, options?: any): AxiosPromise<Array<CellLocation>>;
    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApiInterface
     */
    getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): AxiosPromise<CellLocation>;
}
/**
 * CellLocationApi - object-oriented interface
 * @export
 * @class CellLocationApi
 * @extends {BaseAPI}
 */
export declare class CellLocationApi extends BaseAPI implements CellLocationApiInterface {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApi
     */
    batchGetCellLocations(body: Array<CellIdentifier>, options?: any): Promise<import("axios").AxiosResponse<CellLocation[]>>;
    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApi
     */
    getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): Promise<import("axios").AxiosResponse<CellLocation>>;
}
/**
 * CredentialApi - axios parameter creator
 * @export
 */
export declare const CredentialApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCredential: (credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential: (credentialsId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials: (options?: any) => Promise<RequestArgs>;
    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential: (credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any) => Promise<RequestArgs>;
};
/**
 * CredentialApi - functional programming interface
 * @export
 */
export declare const CredentialApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsModel>>;
    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(credentialsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CredentialsModel>>>;
    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsModel>>;
};
/**
 * CredentialApi - factory interface
 * @export
 */
export declare const CredentialApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;
    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(credentialsId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(options?: any): AxiosPromise<Array<CredentialsModel>>;
    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;
};
/**
 * CredentialApi - interface
 * @export
 * @interface CredentialApi
 */
export interface CredentialApiInterface {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;
    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    deleteCredential(credentialsId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    listCredentials(options?: any): AxiosPromise<Array<CredentialsModel>>;
    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;
}
/**
 * CredentialApi - object-oriented interface
 * @export
 * @class CredentialApi
 * @extends {BaseAPI}
 */
export declare class CredentialApi extends BaseAPI implements CredentialApiInterface {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<import("axios").AxiosResponse<CredentialsModel>>;
    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    deleteCredential(credentialsId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    listCredentials(options?: any): Promise<import("axios").AxiosResponse<CredentialsModel[]>>;
    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<import("axios").AxiosResponse<CredentialsModel>>;
}
/**
 * DataEntryApi - axios parameter creator
 * @export
 */
export declare const DataEntryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataEntry: (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntries: (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntry: (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDataSourceResources: (resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * DataEntryApi - functional programming interface
 * @export
 */
export declare const DataEntryApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSourceResourceMetadata>>>;
};
/**
 * DataEntryApi - factory interface
 * @export
 */
export declare const DataEntryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataSourceResourceMetadata>>;
};
/**
 * DataEntryApi - interface
 * @export
 * @interface DataEntryApi
 */
export interface DataEntryApiInterface {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataSourceResourceMetadata>>;
}
/**
 * DataEntryApi - object-oriented interface
 * @export
 * @class DataEntryApi
 * @extends {BaseAPI}
 */
export declare class DataEntryApi extends BaseAPI implements DataEntryApiInterface {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataSourceResourceMetadata[]>>;
}
/**
 * DeviceApi - axios parameter creator
 * @export
 */
export declare const DeviceApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDevice: (device: Device, options?: any) => Promise<RequestArgs>;
    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceTag: (deviceId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDeviceResource: (deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromDevice: (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDevice: (deviceId: string, model?: boolean, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDevices: (tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResource: (deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any) => Promise<RequestArgs>;
    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResources: (deviceId: string, object: string, instance: string, model?: boolean, options?: any) => Promise<RequestArgs>;
    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeviceTags: (deviceId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResource: (deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any) => Promise<RequestArgs>;
    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResources: (deviceId: string, object: string, instance: string, model?: boolean, options?: any) => Promise<RequestArgs>;
    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceGroup: (deviceId: string, groupId?: InlineObject1, options?: any) => Promise<RequestArgs>;
    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResource: (deviceId: string, object: string, instance: string, resource: string, options?: any) => Promise<RequestArgs>;
    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResources: (deviceId: string, object: string, instance: string, options?: any) => Promise<RequestArgs>;
    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetDeviceGroup: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    writeDeviceResource: (deviceId: string, object: string, instance: string, resource: string, value: object, options?: any) => Promise<RequestArgs>;
};
/**
 * DeviceApi - functional programming interface
 * @export
 */
export declare const DeviceApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDevice(device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>>;
    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDevice(deviceId: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>>;
    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>>;
    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>>;
    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceInstance>>;
    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectInstance>>;
    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>>;
    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>>;
    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * DeviceApi - factory interface
 * @export
 */
export declare const DeviceApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDevice(device: Device, options?: any): AxiosPromise<Device>;
    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDevice(deviceId: string, options?: any): AxiosPromise<void>;
    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDevice(deviceId: string, model?: boolean, options?: any): AxiosPromise<Device>;
    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<Device>>;
    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<void>;
    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<void>;
    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Device>;
    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<ResourceInstance>;
    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<ObjectInstance>;
    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): AxiosPromise<Device>;
    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): AxiosPromise<void>;
    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): AxiosPromise<void>;
    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetDeviceGroup(deviceId: string, options?: any): AxiosPromise<Device>;
    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): AxiosPromise<void>;
};
/**
 * DeviceApi - interface
 * @export
 * @interface DeviceApi
 */
export interface DeviceApiInterface {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    createDevice(device: Device, options?: any): AxiosPromise<Device>;
    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    deleteDevice(deviceId: string, options?: any): AxiosPromise<void>;
    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    deleteDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDevice(deviceId: string, model?: boolean, options?: any): AxiosPromise<Device>;
    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<Device>>;
    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<void>;
    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<void>;
    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Device>;
    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<ResourceInstance>;
    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<ObjectInstance>;
    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): AxiosPromise<Device>;
    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): AxiosPromise<void>;
    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): AxiosPromise<void>;
    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unsetDeviceGroup(deviceId: string, options?: any): AxiosPromise<Device>;
    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): AxiosPromise<void>;
}
/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export declare class DeviceApi extends BaseAPI implements DeviceApiInterface {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    createDevice(device: Device, options?: any): Promise<import("axios").AxiosResponse<Device>>;
    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    deleteDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    deleteDeviceTag(deviceId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    getDevice(deviceId: string, model?: boolean, options?: any): Promise<import("axios").AxiosResponse<Device>>;
    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<import("axios").AxiosResponse<Device[]>>;
    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Device>>;
    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<import("axios").AxiosResponse<ResourceInstance>>;
    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<import("axios").AxiosResponse<ObjectInstance>>;
    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): Promise<import("axios").AxiosResponse<Device>>;
    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    unsetDeviceGroup(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<Device>>;
    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * DeviceObjectModelApi - axios parameter creator
 * @export
 */
export declare const DeviceObjectModelApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeviceObjectModel: (objectModelDefinition: DeviceObjectModel, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceObjectModel: (modelId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceObjectModel: (modelId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeviceObjectModels: (lastEvaluatedKey?: string, limit?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceObjectModelScope: (modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeviceObjectModel: (modelId: string, objectModelDefinition: DeviceObjectModel, options?: any) => Promise<RequestArgs>;
};
/**
 * DeviceObjectModelApi - functional programming interface
 * @export
 */
export declare const DeviceObjectModelApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>>;
    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceObjectModel(modelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceObjectModel(modelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>>;
    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceObjectModel>>>;
    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>>;
    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>>;
};
/**
 * DeviceObjectModelApi - factory interface
 * @export
 */
export declare const DeviceObjectModelApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceObjectModel(modelId: string, options?: any): AxiosPromise<void>;
    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceObjectModel(modelId: string, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<DeviceObjectModel>>;
    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;
};
/**
 * DeviceObjectModelApi - interface
 * @export
 * @interface DeviceObjectModelApi
 */
export interface DeviceObjectModelApiInterface {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    deleteDeviceObjectModel(modelId: string, options?: any): AxiosPromise<void>;
    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    getDeviceObjectModel(modelId: string, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<DeviceObjectModel>>;
    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): AxiosPromise<DeviceObjectModel>;
    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;
}
/**
 * DeviceObjectModelApi - object-oriented interface
 * @export
 * @class DeviceObjectModelApi
 * @extends {BaseAPI}
 */
export declare class DeviceObjectModelApi extends BaseAPI implements DeviceObjectModelApiInterface {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): Promise<import("axios").AxiosResponse<DeviceObjectModel>>;
    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    deleteDeviceObjectModel(modelId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    getDeviceObjectModel(modelId: string, options?: any): Promise<import("axios").AxiosResponse<DeviceObjectModel>>;
    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): Promise<import("axios").AxiosResponse<DeviceObjectModel[]>>;
    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): Promise<import("axios").AxiosResponse<DeviceObjectModel>>;
    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): Promise<import("axios").AxiosResponse<DeviceObjectModel>>;
}
/**
 * EmailApi - axios parameter creator
 * @export
 */
export declare const EmailApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail: (operatorId: string, emailId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail: (operatorId: string, emailId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueAddEmailToken: (request: IssueAddEmailTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEmails: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAddEmailToken: (request: VerifyAddEmailTokenRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * EmailApi - functional programming interface
 * @export
 */
export declare const EmailApiFp: (configuration?: Configuration) => {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(operatorId: string, emailId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(operatorId: string, emailId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailsModel>>;
    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEmails(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailsModel>>>;
    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * EmailApi - factory interface
 * @export
 */
export declare const EmailApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<EmailsModel>;
    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEmails(operatorId: string, options?: any): AxiosPromise<Array<EmailsModel>>;
    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): AxiosPromise<void>;
};
/**
 * EmailApi - interface
 * @export
 * @interface EmailApi
 */
export interface EmailApiInterface {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    deleteEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    getEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<EmailsModel>;
    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    listEmails(operatorId: string, options?: any): AxiosPromise<Array<EmailsModel>>;
    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): AxiosPromise<void>;
}
/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export declare class EmailApi extends BaseAPI implements EmailApiInterface {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    deleteEmail(operatorId: string, emailId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    getEmail(operatorId: string, emailId: string, options?: any): Promise<import("axios").AxiosResponse<EmailsModel>>;
    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    listEmails(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<EmailsModel[]>>;
    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * EventHandlerApi - axios parameter creator
 * @export
 */
export declare const EventHandlerApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventHandler: (req: CreateEventHandlerRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventHandler: (handlerId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIgnoreEventHandler: (imsi: string, handlerId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventHandler: (handlerId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlers: (target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlersBySubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setIgnoreEventHandler: (imsi: string, handlerId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventHandler: (handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * EventHandlerApi - functional programming interface
 * @export
 */
export declare const EventHandlerApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventHandler(req: CreateEventHandlerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventHandlerModel>>;
    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventHandler(handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventHandler(handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventHandlerModel>>;
    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventHandlerModel>>>;
    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlersBySubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventHandlerModel>>>;
    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * EventHandlerApi - factory interface
 * @export
 */
export declare const EventHandlerApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventHandler(req: CreateEventHandlerRequest, options?: any): AxiosPromise<EventHandlerModel>;
    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventHandler(handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventHandler(handlerId: string, options?: any): AxiosPromise<EventHandlerModel>;
    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): AxiosPromise<Array<EventHandlerModel>>;
    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventHandlersBySubscriber(imsi: string, options?: any): AxiosPromise<Array<EventHandlerModel>>;
    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): AxiosPromise<void>;
};
/**
 * EventHandlerApi - interface
 * @export
 * @interface EventHandlerApi
 */
export interface EventHandlerApiInterface {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    createEventHandler(req: CreateEventHandlerRequest, options?: any): AxiosPromise<EventHandlerModel>;
    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    deleteEventHandler(handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    getEventHandler(handlerId: string, options?: any): AxiosPromise<EventHandlerModel>;
    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): AxiosPromise<Array<EventHandlerModel>>;
    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    listEventHandlersBySubscriber(imsi: string, options?: any): AxiosPromise<Array<EventHandlerModel>>;
    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;
    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): AxiosPromise<void>;
}
/**
 * EventHandlerApi - object-oriented interface
 * @export
 * @class EventHandlerApi
 * @extends {BaseAPI}
 */
export declare class EventHandlerApi extends BaseAPI implements EventHandlerApiInterface {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    createEventHandler(req: CreateEventHandlerRequest, options?: any): Promise<import("axios").AxiosResponse<EventHandlerModel>>;
    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    deleteEventHandler(handlerId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    getEventHandler(handlerId: string, options?: any): Promise<import("axios").AxiosResponse<EventHandlerModel>>;
    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): Promise<import("axios").AxiosResponse<EventHandlerModel[]>>;
    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    listEventHandlersBySubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<EventHandlerModel[]>>;
    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * FileEntryApi - axios parameter creator
 * @export
 */
export declare const FileEntryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectory: (scope: 'private', path: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: (scope: 'private', path: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findFiles: (scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (scope: 'private' | 'public', path: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata: (scope: 'private' | 'public', path: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: (scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFile: (scope: 'private', path: string, body: any, contentType?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * FileEntryApi - functional programming interface
 * @export
 */
export declare const FileEntryApiFp: (configuration?: Configuration) => {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectory(scope: 'private', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(scope: 'private', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntry>>>;
    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(scope: 'private' | 'public', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata(scope: 'private' | 'public', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntry>>;
    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntry>>>;
    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FileEntryApi - factory interface
 * @export
 */
export declare const FileEntryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectory(scope: 'private', path: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(scope: 'private', path: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;
    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<void>;
    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<FileEntry>;
    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;
    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): AxiosPromise<void>;
};
/**
 * FileEntryApi - interface
 * @export
 * @interface FileEntryApi
 */
export interface FileEntryApiInterface {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    deleteDirectory(scope: 'private', path: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    deleteFile(scope: 'private', path: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;
    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    getFile(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<void>;
    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    getFileMetadata(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<FileEntry>;
    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;
    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): AxiosPromise<void>;
}
/**
 * FileEntryApi - object-oriented interface
 * @export
 * @class FileEntryApi
 * @extends {BaseAPI}
 */
export declare class FileEntryApi extends BaseAPI implements FileEntryApiInterface {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    deleteDirectory(scope: 'private', path: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    deleteFile(scope: 'private', path: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<FileEntry[]>>;
    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    getFile(scope: 'private' | 'public', path: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    getFileMetadata(scope: 'private' | 'public', path: string, options?: any): Promise<import("axios").AxiosResponse<FileEntry>>;
    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<FileEntry[]>>;
    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExportedFile: (exportedFileId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExportedFile(exportedFileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExportedFileResponse>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExportedFile(exportedFileId: string, options?: any): AxiosPromise<GetExportedFileResponse>;
};
/**
 * FilesApi - interface
 * @export
 * @interface FilesApi
 */
export interface FilesApiInterface {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    getExportedFile(exportedFileId: string, options?: any): AxiosPromise<GetExportedFileResponse>;
}
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI implements FilesApiInterface {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getExportedFile(exportedFileId: string, options?: any): Promise<import("axios").AxiosResponse<GetExportedFileResponse>>;
}
/**
 * GadgetApi - axios parameter creator
 * @export
 */
export declare const GadgetApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGadgetTag: (productId: string, serialNumber: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnGadget: (productId: string, serialNumber: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnGadget: (productId: string, serialNumber: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGadget: (productId: string, serialNumber: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGadgets: (productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGadgetTags: (productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGadget: (productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGadgetGroup: (productId: string, serialNumber: string, group: Group, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateGadget: (productId: string, serialNumber: string, options?: any) => Promise<RequestArgs>;
    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGadgetGroup: (productId: string, serialNumber: string, options?: any) => Promise<RequestArgs>;
};
/**
 * GadgetApi - functional programming interface
 * @export
 */
export declare const GadgetApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gadget>>>;
    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGadgetGroup(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>>;
};
/**
 * GadgetApi - factory interface
 * @export
 */
export declare const GadgetApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Gadget>>;
    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Gadget>;
    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): AxiosPromise<Gadget>;
    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): AxiosPromise<Gadget>;
    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGadgetGroup(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
};
/**
 * GadgetApi - interface
 * @export
 * @interface GadgetApi
 */
export interface GadgetApiInterface {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    getGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Gadget>>;
    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Gadget>;
    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): AxiosPromise<Gadget>;
    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): AxiosPromise<Gadget>;
    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    terminateGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    unsetGadgetGroup(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;
}
/**
 * GadgetApi - object-oriented interface
 * @export
 * @class GadgetApi
 * @extends {BaseAPI}
 */
export declare class GadgetApi extends BaseAPI implements GadgetApiInterface {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    getGadget(productId: string, serialNumber: string, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Gadget[]>>;
    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    terminateGadget(productId: string, serialNumber: string, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    unsetGadgetGroup(productId: string, serialNumber: string, options?: any): Promise<import("axios").AxiosResponse<Gadget>>;
}
/**
 * GroupApi - axios parameter creator
 * @export
 */
export declare const GroupApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: (tags: CreateGroupRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationNamespace: (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any) => Promise<RequestArgs>;
    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationParameter: (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup: (groupId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupTag: (groupId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup: (groupId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribersInGroup: (groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putConfigurationParameters: (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupTags: (groupId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
};
/**
 * GroupApi - functional programming interface
 * @export
 */
export declare const GroupApiFp: (configuration?: Configuration) => {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(tags: CreateGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupTag(groupId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>>;
    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
};
/**
 * GroupApi - factory interface
 * @export
 */
export declare const GroupApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(tags: CreateGroupRequest, options?: any): AxiosPromise<Group>;
    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): AxiosPromise<void>;
    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupTag(groupId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, options?: any): AxiosPromise<Group>;
    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Group>>;
    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Group>;
    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): AxiosPromise<Group>;
    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;
};
/**
 * GroupApi - interface
 * @export
 * @interface GroupApi
 */
export interface GroupApiInterface {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    createGroup(tags: CreateGroupRequest, options?: any): AxiosPromise<Group>;
    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): AxiosPromise<void>;
    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteGroup(groupId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteGroupTag(groupId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    getGroup(groupId: string, options?: any): AxiosPromise<Group>;
    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Group>>;
    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Group>;
    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): AxiosPromise<Group>;
    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;
}
/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export declare class GroupApi extends BaseAPI implements GroupApiInterface {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    createGroup(tags: CreateGroupRequest, options?: any): Promise<import("axios").AxiosResponse<Group>>;
    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteGroup(groupId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteGroupTag(groupId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getGroup(groupId: string, options?: any): Promise<import("axios").AxiosResponse<Group>>;
    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Group[]>>;
    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Group>>;
    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Group>>;
    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
}
/**
 * LagoonApi - axios parameter creator
 * @export
 */
export declare const LagoonApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLagoonUser: (request: LagoonUserCreationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLagoonUser: (lagoonUserId: number, options?: any) => Promise<RequestArgs>;
    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImageLink: (options?: any) => Promise<RequestArgs>;
    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeLagoonDashboardPermissions: (dashboardId: number, options?: any) => Promise<RequestArgs>;
    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonDashboardsPermissions: (options?: any) => Promise<RequestArgs>;
    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonLicensePackStatus: (options?: any) => Promise<RequestArgs>;
    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonUsers: (options?: any) => Promise<RequestArgs>;
    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLagoon: (request: LagoonRegistrationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLagoon: (options?: any) => Promise<RequestArgs>;
    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonDashboardPermissions: (dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonLicensePack: (req: LagoonLicensePacksUpdatingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonPlan: (req: LagoonPlanChangingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserEmail: (lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPassword: (lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPermission: (lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * LagoonApi - functional programming interface
 * @export
 */
export declare const LagoonApiFp: (configuration?: Configuration) => {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLagoonUser(request: LagoonUserCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LagoonUserCreationResponse>>;
    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLagoonUser(lagoonUserId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImageLink(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeLagoonDashboardPermissions(dashboardId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonDashboardsPermissions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonDashboardPermissionsResponse>>>;
    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonLicensePackStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonLicensePackStatusResponse>>>;
    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonUser>>>;
    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLagoon(request: LagoonRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LagoonRegistrationResponse>>;
    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLagoon(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * LagoonApi - factory interface
 * @export
 */
export declare const LagoonApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLagoonUser(request: LagoonUserCreationRequest, options?: any): AxiosPromise<LagoonUserCreationResponse>;
    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLagoonUser(lagoonUserId: number, options?: any): AxiosPromise<void>;
    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImageLink(options?: any): AxiosPromise<string>;
    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeLagoonDashboardPermissions(dashboardId: number, options?: any): AxiosPromise<void>;
    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonDashboardsPermissions(options?: any): AxiosPromise<Array<LagoonDashboardPermissionsResponse>>;
    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonLicensePackStatus(options?: any): AxiosPromise<Array<LagoonLicensePackStatusResponse>>;
    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLagoonUsers(options?: any): AxiosPromise<Array<LagoonUser>>;
    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLagoon(request: LagoonRegistrationRequest, options?: any): AxiosPromise<LagoonRegistrationResponse>;
    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLagoon(options?: any): AxiosPromise<void>;
    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): AxiosPromise<void>;
};
/**
 * LagoonApi - interface
 * @export
 * @interface LagoonApi
 */
export interface LagoonApiInterface {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    createLagoonUser(request: LagoonUserCreationRequest, options?: any): AxiosPromise<LagoonUserCreationResponse>;
    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    deleteLagoonUser(lagoonUserId: number, options?: any): AxiosPromise<void>;
    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    getImageLink(options?: any): AxiosPromise<string>;
    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    initializeLagoonDashboardPermissions(dashboardId: number, options?: any): AxiosPromise<void>;
    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonDashboardsPermissions(options?: any): AxiosPromise<Array<LagoonDashboardPermissionsResponse>>;
    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonLicensePackStatus(options?: any): AxiosPromise<Array<LagoonLicensePackStatusResponse>>;
    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonUsers(options?: any): AxiosPromise<Array<LagoonUser>>;
    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    registerLagoon(request: LagoonRegistrationRequest, options?: any): AxiosPromise<LagoonRegistrationResponse>;
    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    terminateLagoon(options?: any): AxiosPromise<void>;
    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): AxiosPromise<void>;
    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): AxiosPromise<void>;
}
/**
 * LagoonApi - object-oriented interface
 * @export
 * @class LagoonApi
 * @extends {BaseAPI}
 */
export declare class LagoonApi extends BaseAPI implements LagoonApiInterface {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    createLagoonUser(request: LagoonUserCreationRequest, options?: any): Promise<import("axios").AxiosResponse<LagoonUserCreationResponse>>;
    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    deleteLagoonUser(lagoonUserId: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    getImageLink(options?: any): Promise<import("axios").AxiosResponse<string>>;
    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    initializeLagoonDashboardPermissions(dashboardId: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    listLagoonDashboardsPermissions(options?: any): Promise<import("axios").AxiosResponse<LagoonDashboardPermissionsResponse[]>>;
    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    listLagoonLicensePackStatus(options?: any): Promise<import("axios").AxiosResponse<LagoonLicensePackStatusResponse[]>>;
    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    listLagoonUsers(options?: any): Promise<import("axios").AxiosResponse<LagoonUser[]>>;
    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    registerLagoon(request: LagoonRegistrationRequest, options?: any): Promise<import("axios").AxiosResponse<LagoonRegistrationResponse>>;
    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    terminateLagoon(options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * LogApi - axios parameter creator
 * @export
 */
export declare const LogApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogs: (resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * LogApi - functional programming interface
 * @export
 */
export declare const LogApiFp: (configuration?: Configuration) => {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogEntry>>>;
};
/**
 * LogApi - factory interface
 * @export
 */
export declare const LogApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LogEntry>>;
};
/**
 * LogApi - interface
 * @export
 * @interface LogApi
 */
export interface LogApiInterface {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApiInterface
     */
    getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LogEntry>>;
}
/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export declare class LogApi extends BaseAPI implements LogApiInterface {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<LogEntry[]>>;
}
/**
 * LoraDeviceApi - axios parameter creator
 * @export
 */
export declare const LoraDeviceApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraDeviceTag: (deviceId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromLoraDevice: (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraDevices: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraDeviceTags: (deviceId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLoraDevice: (deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToLoraDevice: (deviceId: string, data: LoraData, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraDeviceGroup: (deviceId: string, group: Group, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraDeviceGroup: (deviceId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * LoraDeviceApi - functional programming interface
 * @export
 */
export declare const LoraDeviceApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraDevice>>>;
    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraDeviceGroup(deviceId: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>>;
};
/**
 * LoraDeviceApi - factory interface
 * @export
 */
export declare const LoraDeviceApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraDevice>>;
    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): AxiosPromise<void>;
    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraDeviceGroup(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
};
/**
 * LoraDeviceApi - interface
 * @export
 * @interface LoraDeviceApi
 */
export interface LoraDeviceApiInterface {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    disableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    enableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    getLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraDevice>>;
    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): AxiosPromise<void>;
    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    setLoraDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    terminateLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    unsetLoraDeviceGroup(deviceId: string, options?: any): AxiosPromise<LoraDevice>;
}
/**
 * LoraDeviceApi - object-oriented interface
 * @export
 * @class LoraDeviceApi
 * @extends {BaseAPI}
 */
export declare class LoraDeviceApi extends BaseAPI implements LoraDeviceApiInterface {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    disableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    enableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    getLoraDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice[]>>;
    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    setLoraDeviceGroup(deviceId: string, group: Group, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    terminateLoraDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    unsetLoraDeviceGroup(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<LoraDevice>>;
}
/**
 * LoraGatewayApi - axios parameter creator
 * @export
 */
export declare const LoraGatewayApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraGatewayTag: (gatewayId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraGateway: (gatewayId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraGateway: (gatewayId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraGateway: (gatewayId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraGateways: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraGatewayTags: (gatewayId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraNetworkSet: (gatewayId: string, nsId?: SetNetworkSetRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraGateway: (gatewayId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraNetworkSet: (gatewayId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * LoraGatewayApi - functional programming interface
 * @export
 */
export declare const LoraGatewayApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraGateway>>>;
    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraNetworkSet(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>>;
};
/**
 * LoraGatewayApi - factory interface
 * @export
 */
export declare const LoraGatewayApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;
    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetLoraNetworkSet(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
};
/**
 * LoraGatewayApi - interface
 * @export
 * @interface LoraGatewayApi
 */
export interface LoraGatewayApiInterface {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    disableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    enableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    getLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;
    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    terminateLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    unsetLoraNetworkSet(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;
}
/**
 * LoraGatewayApi - object-oriented interface
 * @export
 * @class LoraGatewayApi
 * @extends {BaseAPI}
 */
export declare class LoraGatewayApi extends BaseAPI implements LoraGatewayApiInterface {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    disableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    enableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    getLoraGateway(gatewayId: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway[]>>;
    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    terminateLoraGateway(gatewayId: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    unsetLoraNetworkSet(gatewayId: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway>>;
}
/**
 * LoraNetworkSetApi - axios parameter creator
 * @export
 */
export declare const LoraNetworkSetApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPermissionToLoraNetworkSet: (nsId: string, operatorId: UpdatePermissionRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLoraNetworkSet: (loraNetworkSet: LoraNetworkSet, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSet: (nsId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSetTag: (nsId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraNetworkSet: (nsId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatewaysInLoraNetworkSet: (nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraNetworkSets: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraNetworkSetTags: (nsId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokePermissionFromLoraNetworkSet: (nsId: string, operatorId: UpdatePermissionRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * LoraNetworkSetApi - functional programming interface
 * @export
 */
export declare const LoraNetworkSetApiFp: (configuration?: Configuration) => {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>>;
    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>>;
    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSet(nsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraNetworkSet(nsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>>;
    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraGateway>>>;
    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraNetworkSet>>>;
    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>>;
    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>>;
};
/**
 * LoraNetworkSetApi - factory interface
 * @export
 */
export declare const LoraNetworkSetApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSet(nsId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoraNetworkSet(nsId: string, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;
    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraNetworkSet>>;
    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;
};
/**
 * LoraNetworkSetApi - interface
 * @export
 * @interface LoraNetworkSetApi
 */
export interface LoraNetworkSetApiInterface {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    deleteLoraNetworkSet(nsId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    getLoraNetworkSet(nsId: string, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;
    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraNetworkSet>>;
    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraNetworkSet>;
    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;
}
/**
 * LoraNetworkSetApi - object-oriented interface
 * @export
 * @class LoraNetworkSetApi
 * @extends {BaseAPI}
 */
export declare class LoraNetworkSetApi extends BaseAPI implements LoraNetworkSetApiInterface {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet>>;
    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet>>;
    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    deleteLoraNetworkSet(nsId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    getLoraNetworkSet(nsId: string, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet>>;
    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<LoraGateway[]>>;
    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet[]>>;
    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet>>;
    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<import("axios").AxiosResponse<LoraNetworkSet>>;
}
/**
 * OperatorApi - axios parameter creator
 * @export
 */
export declare const OperatorApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCoverageType: (operatorId: string, coverageType: string, options?: any) => Promise<RequestArgs>;
    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOperatorContract: (operatorId: string, request: ContractUpdatingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCompanyInformation: (operatorId: string, request: CompanyInformationModel, options?: any) => Promise<RequestArgs>;
    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIndividualInformation: (operatorId: string, request: IndividualInformationModel, options?: any) => Promise<RequestArgs>;
    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOperator: (request: RegisterOperatorsRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorAuthKey: (operatorId: string, authKeyId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorContract: (operatorId: string, contractName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableMFA: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAuthToken: (operatorId: string, request: GenerateTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateOperatorAuthKey: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateSupportToken: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyInformation: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualInformation: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMFAStatus: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperator: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueEmailChangeToken: (request: IssueEmailChangeTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueMFARevokingToken: (request: MFAIssueRevokingTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOperatorAuthKeys: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeMFA: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyInformation: (operatorId: string, request: CompanyInformationModel, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIndividualInformation: (operatorId: string, request: IndividualInformationModel, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOperatorPassword: (operatorId: string, request: UpdatePasswordRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmailChangeToken: (token: VerifyEmailChangeTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFA: (operatorId: string, request: MFAAuthenticationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFARevokingToken: (request: MFARevokingTokenVerifyRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyOperator: (token: VerifyOperatorsRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * OperatorApi - functional programming interface
 * @export
 */
export declare const OperatorApiFp: (configuration?: Configuration) => {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCoverageType(operatorId: string, coverageType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUpdatedResponse>>;
    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOperator(request: RegisterOperatorsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorContract(operatorId: string, contractName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableMFA(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMFAOTPResponse>>;
    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateTokenResponse>>;
    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateOperatorAuthKey(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateOperatorsAuthKeyResponse>>;
    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateSupportToken(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTokenResponse>>;
    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyInformation(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyInformationModel>>;
    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualInformation(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndividualInformationModel>>;
    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMFAStatus(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MFAStatusOfUseResponse>>;
    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperator(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOperatorResponse>>;
    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOperatorAuthKeys(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthKeyResponse>>>;
    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeMFA(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperatorMFAVerifyingResponse>>;
    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyOperator(token: VerifyOperatorsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * OperatorApi - factory interface
 * @export
 */
export declare const OperatorApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCoverageType(operatorId: string, coverageType: string, options?: any): AxiosPromise<void>;
    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): AxiosPromise<ContractUpdatedResponse>;
    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOperator(request: RegisterOperatorsRequest, options?: any): AxiosPromise<void>;
    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperatorContract(operatorId: string, contractName: string, options?: any): AxiosPromise<void>;
    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableMFA(operatorId: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;
    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): AxiosPromise<GenerateTokenResponse>;
    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateOperatorAuthKey(operatorId: string, options?: any): AxiosPromise<GenerateOperatorsAuthKeyResponse>;
    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateSupportToken(operatorId: string, options?: any): AxiosPromise<SupportTokenResponse>;
    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyInformation(operatorId: string, options?: any): AxiosPromise<CompanyInformationModel>;
    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualInformation(operatorId: string, options?: any): AxiosPromise<IndividualInformationModel>;
    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMFAStatus(operatorId: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;
    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperator(operatorId: string, options?: any): AxiosPromise<GetOperatorResponse>;
    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOperatorAuthKeys(operatorId: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;
    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeMFA(operatorId: string, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<OperatorMFAVerifyingResponse>;
    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyOperator(token: VerifyOperatorsRequest, options?: any): AxiosPromise<void>;
};
/**
 * OperatorApi - interface
 * @export
 * @interface OperatorApi
 */
export interface OperatorApiInterface {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    addCoverageType(operatorId: string, coverageType: string, options?: any): AxiosPromise<void>;
    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): AxiosPromise<ContractUpdatedResponse>;
    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createOperator(request: RegisterOperatorsRequest, options?: any): AxiosPromise<void>;
    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    deleteOperatorContract(operatorId: string, contractName: string, options?: any): AxiosPromise<void>;
    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    enableMFA(operatorId: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;
    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): AxiosPromise<GenerateTokenResponse>;
    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateOperatorAuthKey(operatorId: string, options?: any): AxiosPromise<GenerateOperatorsAuthKeyResponse>;
    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateSupportToken(operatorId: string, options?: any): AxiosPromise<SupportTokenResponse>;
    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getCompanyInformation(operatorId: string, options?: any): AxiosPromise<CompanyInformationModel>;
    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getIndividualInformation(operatorId: string, options?: any): AxiosPromise<IndividualInformationModel>;
    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getMFAStatus(operatorId: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;
    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getOperator(operatorId: string, options?: any): AxiosPromise<GetOperatorResponse>;
    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    listOperatorAuthKeys(operatorId: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;
    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    revokeMFA(operatorId: string, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;
    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<OperatorMFAVerifyingResponse>;
    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): AxiosPromise<void>;
    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyOperator(token: VerifyOperatorsRequest, options?: any): AxiosPromise<void>;
}
/**
 * OperatorApi - object-oriented interface
 * @export
 * @class OperatorApi
 * @extends {BaseAPI}
 */
export declare class OperatorApi extends BaseAPI implements OperatorApiInterface {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    addCoverageType(operatorId: string, coverageType: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): Promise<import("axios").AxiosResponse<ContractUpdatedResponse>>;
    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    createOperator(request: RegisterOperatorsRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    deleteOperatorContract(operatorId: string, contractName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    enableMFA(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<EnableMFAOTPResponse>>;
    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): Promise<import("axios").AxiosResponse<GenerateTokenResponse>>;
    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    generateOperatorAuthKey(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<GenerateOperatorsAuthKeyResponse>>;
    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    generateSupportToken(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<SupportTokenResponse>>;
    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    getCompanyInformation(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<CompanyInformationModel>>;
    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    getIndividualInformation(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<IndividualInformationModel>>;
    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    getMFAStatus(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<MFAStatusOfUseResponse>>;
    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    getOperator(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<GetOperatorResponse>>;
    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    listOperatorAuthKeys(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<AuthKeyResponse[]>>;
    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    revokeMFA(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): Promise<import("axios").AxiosResponse<OperatorMFAVerifyingResponse>>;
    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    verifyOperator(token: VerifyOperatorsRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * OrderApi - axios parameter creator
 * @export
 */
export declare const OrderApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder: (orderId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmCouponOrder: (orderId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmOrder: (orderId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmVolumeDiscountOrder: (orderId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCouponQuotation: (request: CreateEstimatedCouponRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQuotation: (request: CreateEstimatedOrderRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVolumeDiscountQuotation: (request: CreateEstimatedVolumeDiscountRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder: (orderId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAvailableDiscounts: (options?: any) => Promise<RequestArgs>;
    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrderedSubscribers: (orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders: (options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts: (options?: any) => Promise<RequestArgs>;
    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerOrderedSim: (orderId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * OrderApi - functional programming interface
 * @export
 */
export declare const OrderApiFp: (configuration?: Configuration) => {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmCouponOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponResponse>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmVolumeDiscountOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVolumeDiscountResponse>>;
    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedCouponModel>>;
    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQuotation(request: CreateEstimatedOrderRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedOrderModel>>;
    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedVolumeDiscountModel>>;
    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderResponse>>;
    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAvailableDiscounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableLongTermDiscountResponse>>;
    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrderedSubscriberResponse>>;
    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrderResponse>>;
    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProductResponse>>;
    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerOrderedSim(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
};
/**
 * OrderApi - factory interface
 * @export
 */
export declare const OrderApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(orderId: string, options?: any): AxiosPromise<string>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmCouponOrder(orderId: string, options?: any): AxiosPromise<CouponResponse>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmOrder(orderId: string, options?: any): AxiosPromise<string>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmVolumeDiscountOrder(orderId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;
    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): AxiosPromise<EstimatedCouponModel>;
    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQuotation(request: CreateEstimatedOrderRequest, options?: any): AxiosPromise<EstimatedOrderModel>;
    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): AxiosPromise<EstimatedVolumeDiscountModel>;
    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(orderId: string, options?: any): AxiosPromise<GetOrderResponse>;
    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAvailableDiscounts(options?: any): AxiosPromise<AvailableLongTermDiscountResponse>;
    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<ListOrderedSubscriberResponse>;
    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(options?: any): AxiosPromise<ListOrderResponse>;
    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts(options?: any): AxiosPromise<ListProductResponse>;
    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerOrderedSim(orderId: string, options?: any): AxiosPromise<string>;
};
/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    cancelOrder(orderId: string, options?: any): AxiosPromise<string>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmCouponOrder(orderId: string, options?: any): AxiosPromise<CouponResponse>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmOrder(orderId: string, options?: any): AxiosPromise<string>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmVolumeDiscountOrder(orderId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;
    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): AxiosPromise<EstimatedCouponModel>;
    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createQuotation(request: CreateEstimatedOrderRequest, options?: any): AxiosPromise<EstimatedOrderModel>;
    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): AxiosPromise<EstimatedVolumeDiscountModel>;
    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrder(orderId: string, options?: any): AxiosPromise<GetOrderResponse>;
    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listAvailableDiscounts(options?: any): AxiosPromise<AvailableLongTermDiscountResponse>;
    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<ListOrderedSubscriberResponse>;
    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listOrders(options?: any): AxiosPromise<ListOrderResponse>;
    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listProducts(options?: any): AxiosPromise<ListProductResponse>;
    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    registerOrderedSim(orderId: string, options?: any): AxiosPromise<string>;
}
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export declare class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    cancelOrder(orderId: string, options?: any): Promise<import("axios").AxiosResponse<string>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    confirmCouponOrder(orderId: string, options?: any): Promise<import("axios").AxiosResponse<CouponResponse>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    confirmOrder(orderId: string, options?: any): Promise<import("axios").AxiosResponse<string>>;
    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    confirmVolumeDiscountOrder(orderId: string, options?: any): Promise<import("axios").AxiosResponse<GetVolumeDiscountResponse>>;
    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): Promise<import("axios").AxiosResponse<EstimatedCouponModel>>;
    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    createQuotation(request: CreateEstimatedOrderRequest, options?: any): Promise<import("axios").AxiosResponse<EstimatedOrderModel>>;
    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): Promise<import("axios").AxiosResponse<EstimatedVolumeDiscountModel>>;
    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    getOrder(orderId: string, options?: any): Promise<import("axios").AxiosResponse<GetOrderResponse>>;
    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    listAvailableDiscounts(options?: any): Promise<import("axios").AxiosResponse<AvailableLongTermDiscountResponse>>;
    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<import("axios").AxiosResponse<ListOrderedSubscriberResponse>>;
    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    listOrders(options?: any): Promise<import("axios").AxiosResponse<ListOrderResponse>>;
    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    listProducts(options?: any): Promise<import("axios").AxiosResponse<ListProductResponse>>;
    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    registerOrderedSim(orderId: string, options?: any): Promise<import("axios").AxiosResponse<string>>;
}
/**
 * PaymentApi - axios parameter creator
 * @export
 */
export declare const PaymentApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePaymentMethod: (options?: any) => Promise<RequestArgs>;
    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportPaymentStatement: (paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any) => Promise<RequestArgs>;
    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayerInformation: (options?: any) => Promise<RequestArgs>;
    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod: (options?: any) => Promise<RequestArgs>;
    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTransaction: (paymentTransactionId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumeDiscount: (contractId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCoupons: (options?: any) => Promise<RequestArgs>;
    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentStatements: (options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVolumeDiscounts: (options?: any) => Promise<RequestArgs>;
    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerCoupon: (couponCode: string, options?: any) => Promise<RequestArgs>;
    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPayerInformation: (req: RegisterPayerInformationModel, options?: any) => Promise<RequestArgs>;
};
/**
 * PaymentApi - functional programming interface
 * @export
 */
export declare const PaymentApiFp: (configuration?: Configuration) => {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePaymentMethod(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>>;
    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayerInformation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterPayerInformationModel>>;
    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentMethodResult>>;
    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTransaction(paymentTransactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentTransactionResult>>;
    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumeDiscount(contractId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVolumeDiscountResponse>>;
    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCoupons(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCouponResponse>>;
    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentStatements(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentStatementResponse>>;
    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVolumeDiscounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVolumeDiscountResponse>>;
    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerCoupon(couponCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponResponse>>;
    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPayerInformation(req: RegisterPayerInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * PaymentApi - factory interface
 * @export
 */
export declare const PaymentApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePaymentMethod(options?: any): AxiosPromise<object>;
    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayerInformation(options?: any): AxiosPromise<RegisterPayerInformationModel>;
    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(options?: any): AxiosPromise<GetPaymentMethodResult>;
    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTransaction(paymentTransactionId: string, options?: any): AxiosPromise<GetPaymentTransactionResult>;
    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumeDiscount(contractId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;
    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCoupons(options?: any): AxiosPromise<ListCouponResponse>;
    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentStatements(options?: any): AxiosPromise<ListPaymentStatementResponse>;
    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVolumeDiscounts(options?: any): AxiosPromise<ListVolumeDiscountResponse>;
    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerCoupon(couponCode: string, options?: any): AxiosPromise<CouponResponse>;
    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPayerInformation(req: RegisterPayerInformationModel, options?: any): AxiosPromise<void>;
};
/**
 * PaymentApi - interface
 * @export
 * @interface PaymentApi
 */
export interface PaymentApiInterface {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    activatePaymentMethod(options?: any): AxiosPromise<object>;
    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPayerInformation(options?: any): AxiosPromise<RegisterPayerInformationModel>;
    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPaymentMethod(options?: any): AxiosPromise<GetPaymentMethodResult>;
    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPaymentTransaction(paymentTransactionId: string, options?: any): AxiosPromise<GetPaymentTransactionResult>;
    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getVolumeDiscount(contractId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;
    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listCoupons(options?: any): AxiosPromise<ListCouponResponse>;
    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listPaymentStatements(options?: any): AxiosPromise<ListPaymentStatementResponse>;
    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listVolumeDiscounts(options?: any): AxiosPromise<ListVolumeDiscountResponse>;
    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    registerCoupon(couponCode: string, options?: any): AxiosPromise<CouponResponse>;
    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    registerPayerInformation(req: RegisterPayerInformationModel, options?: any): AxiosPromise<void>;
}
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export declare class PaymentApi extends BaseAPI implements PaymentApiInterface {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    activatePaymentMethod(options?: any): Promise<import("axios").AxiosResponse<object>>;
    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): Promise<import("axios").AxiosResponse<FileExportResponse>>;
    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPayerInformation(options?: any): Promise<import("axios").AxiosResponse<RegisterPayerInformationModel>>;
    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentMethod(options?: any): Promise<import("axios").AxiosResponse<GetPaymentMethodResult>>;
    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentTransaction(paymentTransactionId: string, options?: any): Promise<import("axios").AxiosResponse<GetPaymentTransactionResult>>;
    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getVolumeDiscount(contractId: string, options?: any): Promise<import("axios").AxiosResponse<GetVolumeDiscountResponse>>;
    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    listCoupons(options?: any): Promise<import("axios").AxiosResponse<ListCouponResponse>>;
    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    listPaymentStatements(options?: any): Promise<import("axios").AxiosResponse<ListPaymentStatementResponse>>;
    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    listVolumeDiscounts(options?: any): Promise<import("axios").AxiosResponse<ListVolumeDiscountResponse>>;
    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    registerCoupon(couponCode: string, options?: any): Promise<import("axios").AxiosResponse<CouponResponse>>;
    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    registerPayerInformation(req: RegisterPayerInformationModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * PortMappingApi - axios parameter creator
 * @export
 */
export declare const PortMappingApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPortMapping: (portMapping: CreatePortMappingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePortMapping: (ipAddress: string, port: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappings: (limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappingsForSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
};
/**
 * PortMappingApi - functional programming interface
 * @export
 */
export declare const PortMappingApiFp: (configuration?: Configuration) => {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPortMapping(portMapping: CreatePortMappingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortMapping>>;
    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePortMapping(ipAddress: string, port: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortMapping>>>;
    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappingsForSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortMapping>>;
};
/**
 * PortMappingApi - factory interface
 * @export
 */
export declare const PortMappingApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPortMapping(portMapping: CreatePortMappingRequest, options?: any): AxiosPromise<PortMapping>;
    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePortMapping(ipAddress: string, port: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<PortMapping>>;
    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPortMappingsForSubscriber(imsi: string, options?: any): AxiosPromise<PortMapping>;
};
/**
 * PortMappingApi - interface
 * @export
 * @interface PortMappingApi
 */
export interface PortMappingApiInterface {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    createPortMapping(portMapping: CreatePortMappingRequest, options?: any): AxiosPromise<PortMapping>;
    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    deletePortMapping(ipAddress: string, port: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<PortMapping>>;
    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    listPortMappingsForSubscriber(imsi: string, options?: any): AxiosPromise<PortMapping>;
}
/**
 * PortMappingApi - object-oriented interface
 * @export
 * @class PortMappingApi
 * @extends {BaseAPI}
 */
export declare class PortMappingApi extends BaseAPI implements PortMappingApiInterface {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    createPortMapping(portMapping: CreatePortMappingRequest, options?: any): Promise<import("axios").AxiosResponse<PortMapping>>;
    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    deletePortMapping(ipAddress: string, port: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<PortMapping[]>>;
    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    listPortMappingsForSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<PortMapping>>;
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
export declare const QueryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDevices: (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) => Promise<RequestArgs>;
    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSigfoxDevices: (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) => Promise<RequestArgs>;
    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSims: (name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) => Promise<RequestArgs>;
    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscriberTrafficVolumeRanking: (from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any) => Promise<RequestArgs>;
    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscribers: (name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) => Promise<RequestArgs>;
};
/**
 * QueryApi - functional programming interface
 * @export
 */
export declare const QueryApiFp: (configuration?: Configuration) => {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>>;
    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SigfoxDevice>>>;
    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sim>>>;
    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrafficVolumeRanking>>>;
    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscriber>>>;
};
/**
 * QueryApi - factory interface
 * @export
 */
export declare const QueryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Device>>;
    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<SigfoxDevice>>;
    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Sim>>;
    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): AxiosPromise<Array<TrafficVolumeRanking>>;
    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Subscriber>>;
};
/**
 * QueryApi - interface
 * @export
 * @interface QueryApi
 */
export interface QueryApiInterface {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Device>>;
    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<SigfoxDevice>>;
    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Sim>>;
    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): AxiosPromise<Array<TrafficVolumeRanking>>;
    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Subscriber>>;
}
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export declare class QueryApi extends BaseAPI implements QueryApiInterface {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<import("axios").AxiosResponse<Device[]>>;
    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice[]>>;
    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<import("axios").AxiosResponse<Sim[]>>;
    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): Promise<import("axios").AxiosResponse<TrafficVolumeRanking[]>>;
    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<import("axios").AxiosResponse<Subscriber[]>>;
}
/**
 * RoleApi - axios parameter creator
 * @export
 */
export declare const RoleApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachRole: (operatorId: string, userName: string, request: AttachRoleRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: (operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: (operatorId: string, roleId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachRole: (operatorId: string, userName: string, roleId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: (operatorId: string, roleId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAttachedUsers: (operatorId: string, roleId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserRoles: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: (operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * RoleApi - functional programming interface
 * @export
 */
export declare const RoleApiFp: (configuration?: Configuration) => {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoleResponse>>;
    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachRole(operatorId: string, userName: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleResponse>>;
    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailResponse>>>;
    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListRolesResponse>>>;
    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserRoles(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * RoleApi - factory interface
 * @export
 */
export declare const RoleApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): AxiosPromise<void>;
    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<CreateRoleResponse>;
    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(operatorId: string, roleId: string, options?: any): AxiosPromise<void>;
    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachRole(operatorId: string, userName: string, roleId: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(operatorId: string, roleId: string, options?: any): AxiosPromise<RoleResponse>;
    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;
    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(operatorId: string, options?: any): AxiosPromise<Array<ListRolesResponse>>;
    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserRoles(operatorId: string, userName: string, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<void>;
};
/**
 * RoleApi - interface
 * @export
 * @interface RoleApi
 */
export interface RoleApiInterface {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): AxiosPromise<void>;
    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<CreateRoleResponse>;
    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    deleteRole(operatorId: string, roleId: string, options?: any): AxiosPromise<void>;
    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    detachRole(operatorId: string, userName: string, roleId: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    getRole(operatorId: string, roleId: string, options?: any): AxiosPromise<RoleResponse>;
    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;
    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listRoles(operatorId: string, options?: any): AxiosPromise<Array<ListRolesResponse>>;
    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listUserRoles(operatorId: string, userName: string, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<void>;
}
/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export declare class RoleApi extends BaseAPI implements RoleApiInterface {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<import("axios").AxiosResponse<CreateRoleResponse>>;
    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    deleteRole(operatorId: string, roleId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    detachRole(operatorId: string, userName: string, roleId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    getRole(operatorId: string, roleId: string, options?: any): Promise<import("axios").AxiosResponse<RoleResponse>>;
    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): Promise<import("axios").AxiosResponse<UserDetailResponse[]>>;
    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    listRoles(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<ListRolesResponse[]>>;
    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    listUserRoles(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<RoleResponse[]>>;
    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * ShippingAddressApi - axios parameter creator
 * @export
 */
export declare const ShippingAddressApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShippingAddress: (operatorId: string, model: ShippingAddressModel, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShippingAddress: (operatorId: string, shippingAddressId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShippingAddress: (operatorId: string, shippingAddressId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listShippingAddresses: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShippingAddress: (operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any) => Promise<RequestArgs>;
};
/**
 * ShippingAddressApi - functional programming interface
 * @export
 */
export declare const ShippingAddressApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingAddressResponse>>;
    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingAddressResponse>>;
    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listShippingAddresses(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListShippingAddressResponse>>;
    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ShippingAddressApi - factory interface
 * @export
 */
export declare const ShippingAddressApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): AxiosPromise<GetShippingAddressResponse>;
    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<GetShippingAddressResponse>;
    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listShippingAddresses(operatorId: string, options?: any): AxiosPromise<ListShippingAddressResponse>;
    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): AxiosPromise<void>;
};
/**
 * ShippingAddressApi - interface
 * @export
 * @interface ShippingAddressApi
 */
export interface ShippingAddressApiInterface {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): AxiosPromise<GetShippingAddressResponse>;
    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<void>;
    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<GetShippingAddressResponse>;
    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    listShippingAddresses(operatorId: string, options?: any): AxiosPromise<ListShippingAddressResponse>;
    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): AxiosPromise<void>;
}
/**
 * ShippingAddressApi - object-oriented interface
 * @export
 * @class ShippingAddressApi
 * @extends {BaseAPI}
 */
export declare class ShippingAddressApi extends BaseAPI implements ShippingAddressApiInterface {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): Promise<import("axios").AxiosResponse<GetShippingAddressResponse>>;
    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<import("axios").AxiosResponse<GetShippingAddressResponse>>;
    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    listShippingAddresses(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<ListShippingAddressResponse>>;
    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * SigfoxDeviceApi - axios parameter creator
 * @export
 */
export declare const SigfoxDeviceApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSigfoxDeviceTag: (deviceId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnSigfoxDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnSigfoxDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSigfoxDevice: (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSigfoxDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSigfoxDevices: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSigfoxDeviceTags: (deviceId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSigfoxDevice: (deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToSigfoxDevice: (deviceId: string, data: SigfoxData, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSigfoxDeviceGroup: (deviceId: string, group: Group, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSigfoxDevice: (deviceId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSigfoxDeviceGroup: (deviceId: string, options?: any) => Promise<RequestArgs>;
};
/**
 * SigfoxDeviceApi - functional programming interface
 * @export
 */
export declare const SigfoxDeviceApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SigfoxDevice>>>;
    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSigfoxDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>>;
};
/**
 * SigfoxDeviceApi - factory interface
 * @export
 */
export declare const SigfoxDeviceApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SigfoxDevice>>;
    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): AxiosPromise<void>;
    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSigfoxDeviceGroup(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
};
/**
 * SigfoxDeviceApi - interface
 * @export
 * @interface SigfoxDeviceApi
 */
export interface SigfoxDeviceApiInterface {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    disableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    enableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    getSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SigfoxDevice>>;
    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): AxiosPromise<void>;
    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    terminateSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    unsetSigfoxDeviceGroup(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;
}
/**
 * SigfoxDeviceApi - object-oriented interface
 * @export
 * @class SigfoxDeviceApi
 * @extends {BaseAPI}
 */
export declare class SigfoxDeviceApi extends BaseAPI implements SigfoxDeviceApiInterface {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    disableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    enableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    getSigfoxDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice[]>>;
    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    terminateSigfoxDevice(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    unsetSigfoxDeviceGroup(deviceId: string, options?: any): Promise<import("axios").AxiosResponse<SigfoxDevice>>;
}
/**
 * SimApi - axios parameter creator
 * @export
 */
export declare const SimApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSim: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile.
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSubscription: (simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any) => Promise<RequestArgs>;
    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSim: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimSession: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimTag: (simId: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriptionContainerCountryMappingEntry: (simId: string, iccid: string, mcc: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableSimTermination: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSimTermination: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSubscriptionContainer: (simId: string, iccid: string, containerId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSim: (simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSim: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSimSessionEvents: (simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSims: (limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscriptionContainers: (simId: string, iccid: string, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSimTags: (simId: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriptionContainerCountryMappingEntries: (simId: string, iccid: string, mappingEntries: MappingEntries, options?: any) => Promise<RequestArgs>;
    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSim: (simId: string, registerSimRequest: RegisterSimRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportSimLocalInfo: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsToSim: (simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimExpiryTime: (simId: string, request: ExpiryTime, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimGroup: (simId: string, group: SetGroupRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimImeiLock: (simId: string, imeiLock?: SetImeiLockRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimToStandby: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSim: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSim: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimExpiryTime: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimGroup: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimImeiLock: (simId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSimSpeedClass: (simId: string, speedClass: UpdateSpeedClassRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * SimApi - functional programming interface
 * @export
 */
export declare const SimApiFp: (configuration?: Configuration) => {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile.
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimProfile>>;
    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimSession(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimTag(simId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>>;
    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableSimTermination(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSimTermination(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>>;
    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionEvent>>>;
    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSims(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sim>>>;
    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscriptionContainers(simId: string, iccid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>>;
    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>>;
    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportSimLocalInfo(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>>;
    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimGroup(simId: string, group: SetGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimToStandby(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimExpiryTime(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimGroup(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimImeiLock(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>>;
};
/**
 * SimApi - factory interface
 * @export
 */
export declare const SimApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile.
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): AxiosPromise<SimProfile>;
    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimSession(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSimTag(simId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;
    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSims(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Sim>>;
    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscriptionContainers(simId: string, iccid: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Sim>;
    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportSimLocalInfo(simId: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): AxiosPromise<Sim>;
    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimGroup(simId: string, group: SetGroupRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSimToStandby(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimExpiryTime(simId: string, options?: any): AxiosPromise<void>;
    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimGroup(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetSimImeiLock(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Sim>;
};
/**
 * SimApi - interface
 * @export
 * @interface SimApi
 */
export interface SimApiInterface {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    activateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile.
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): AxiosPromise<SimProfile>;
    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deactivateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSimSession(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSimTag(simId: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    disableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    enableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    getSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;
    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSims(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Sim>>;
    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSubscriptionContainers(simId: string, iccid: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Sim>;
    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): AxiosPromise<SubscriptionContainerStatus>;
    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    reportSimLocalInfo(simId: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): AxiosPromise<Sim>;
    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimGroup(simId: string, group: SetGroupRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Sim>;
    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimToStandby(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    suspendSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    terminateSim(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimExpiryTime(simId: string, options?: any): AxiosPromise<void>;
    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimGroup(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimImeiLock(simId: string, options?: any): AxiosPromise<Sim>;
    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Sim>;
}
/**
 * SimApi - object-oriented interface
 * @export
 * @class SimApi
 * @extends {BaseAPI}
 */
export declare class SimApi extends BaseAPI implements SimApiInterface {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    activateSim(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile.
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): Promise<import("axios").AxiosResponse<SimProfile>>;
    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    deactivateSim(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    deleteSimSession(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    deleteSimTag(simId: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): Promise<import("axios").AxiosResponse<SubscriptionContainerStatus>>;
    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    disableSimTermination(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    enableSimTermination(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): Promise<import("axios").AxiosResponse<SubscriptionContainerStatus>>;
    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    getSim(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<SessionEvent[]>>;
    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    listSims(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Sim[]>>;
    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    listSubscriptionContainers(simId: string, iccid: string, options?: any): Promise<import("axios").AxiosResponse<SubscriptionContainerStatus>>;
    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): Promise<import("axios").AxiosResponse<SubscriptionContainerStatus>>;
    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    reportSimLocalInfo(simId: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<import("axios").AxiosResponse<SmsForwardingReport>>;
    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    setSimGroup(simId: string, group: SetGroupRequest, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    setSimToStandby(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    suspendSim(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    terminateSim(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    unsetSimExpiryTime(simId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    unsetSimGroup(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    unsetSimImeiLock(simId: string, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<import("axios").AxiosResponse<Sim>>;
}
/**
 * SoraletApi - axios parameter creator
 * @export
 */
export declare const SoraletApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSoralet: (request: CreateSoraletRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoralet: (soraletId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoraletVersion: (soraletId: string, version: number, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoralet: (soraletId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoraletLogs: (soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoraletVersions: (soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoralets: (sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testSoralet: (soraletId: string, request: ExecuteSoraletRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSoraletCode: (soraletId: string, body: any, contentType?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * SoraletApi - functional programming interface
 * @export
 */
export declare const SoraletApiFp: (configuration?: Configuration) => {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSoralet(request: CreateSoraletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoralet(soraletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoraletVersion(soraletId: string, version: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoralet(soraletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Soralet>>;
    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoraletLog>>>;
    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoraletVersion>>>;
    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Soralet>>>;
    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSoraletResponse>>;
    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoraletVersion>>;
};
/**
 * SoraletApi - factory interface
 * @export
 */
export declare const SoraletApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSoralet(request: CreateSoraletRequest, options?: any): AxiosPromise<void>;
    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoralet(soraletId: string, options?: any): AxiosPromise<void>;
    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSoraletVersion(soraletId: string, version: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoralet(soraletId: string, options?: any): AxiosPromise<Soralet>;
    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletLog>>;
    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletVersion>>;
    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Soralet>>;
    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): AxiosPromise<ExecuteSoraletResponse>;
    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): AxiosPromise<SoraletVersion>;
};
/**
 * SoraletApi - interface
 * @export
 * @interface SoraletApi
 */
export interface SoraletApiInterface {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    createSoralet(request: CreateSoraletRequest, options?: any): AxiosPromise<void>;
    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    deleteSoralet(soraletId: string, options?: any): AxiosPromise<void>;
    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    deleteSoraletVersion(soraletId: string, version: number, options?: any): AxiosPromise<void>;
    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    getSoralet(soraletId: string, options?: any): AxiosPromise<Soralet>;
    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletLog>>;
    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletVersion>>;
    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Soralet>>;
    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): AxiosPromise<ExecuteSoraletResponse>;
    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): AxiosPromise<SoraletVersion>;
}
/**
 * SoraletApi - object-oriented interface
 * @export
 * @class SoraletApi
 * @extends {BaseAPI}
 */
export declare class SoraletApi extends BaseAPI implements SoraletApiInterface {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    createSoralet(request: CreateSoraletRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    deleteSoralet(soraletId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    deleteSoraletVersion(soraletId: string, version: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    getSoralet(soraletId: string, options?: any): Promise<import("axios").AxiosResponse<Soralet>>;
    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<SoraletLog[]>>;
    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<SoraletVersion[]>>;
    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Soralet[]>>;
    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): Promise<import("axios").AxiosResponse<ExecuteSoraletResponse>>;
    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): Promise<import("axios").AxiosResponse<SoraletVersion>>;
}
/**
 * StatsApi - axios parameter creator
 * @export
 */
export declare const StatsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAirStats: (operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBeamStats: (operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStats: (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStatsOfSim: (simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeamStats: (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHarvestExportedDataStats: (operatorId: string, yearMonth?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogsExportedDataStats: (yearMonth?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * StatsApi - functional programming interface
 * @export
 */
export declare const StatsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>>;
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>>;
    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AirStatsResponse>>>;
    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AirStatsResponse>>>;
    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BeamStatsResponse>>>;
    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HarvestExportedDataStatsResponse>>;
    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NapterAuditLogsExportedDataStatsResponse>>;
};
/**
 * StatsApi - factory interface
 * @export
 */
export declare const StatsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;
    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;
    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<BeamStatsResponse>>;
    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): AxiosPromise<HarvestExportedDataStatsResponse>;
    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): AxiosPromise<NapterAuditLogsExportedDataStatsResponse>;
};
/**
 * StatsApi - interface
 * @export
 * @interface StatsApi
 */
export interface StatsApiInterface {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;
    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;
    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;
    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<BeamStatsResponse>>;
    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): AxiosPromise<HarvestExportedDataStatsResponse>;
    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): AxiosPromise<NapterAuditLogsExportedDataStatsResponse>;
}
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export declare class StatsApi extends BaseAPI implements StatsApiInterface {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<import("axios").AxiosResponse<FileExportResponse>>;
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<import("axios").AxiosResponse<FileExportResponse>>;
    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<import("axios").AxiosResponse<AirStatsResponse[]>>;
    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<import("axios").AxiosResponse<AirStatsResponse[]>>;
    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<import("axios").AxiosResponse<BeamStatsResponse[]>>;
    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): Promise<import("axios").AxiosResponse<HarvestExportedDataStatsResponse>>;
    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): Promise<import("axios").AxiosResponse<NapterAuditLogsExportedDataStatsResponse>>;
}
/**
 * SubscriberApi - axios parameter creator
 * @export
 */
export declare const SubscriberApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberSession: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTag: (imsi: string, tagName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTransferToken: (token: string, options?: any) => Promise<RequestArgs>;
    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTermination: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTermination: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSubscriber: (imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueSubscriberTransferToken: (request: IssueSubscriberTransferTokenRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessionEvents: (imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribers: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putBundles: (imsi: string, bundles: Array<string>, options?: any) => Promise<RequestArgs>;
    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriberTags: (imsi: string, tags: Array<TagUpdateRequest>, options?: any) => Promise<RequestArgs>;
    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSubscriber: (imsi: string, subscriber: RegisterSubscribersRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportLocalInfo: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSms: (imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsByMsisdn: (msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setExpiryTime: (imsi: string, request: ExpiryTime, options?: any) => Promise<RequestArgs>;
    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroup: (imsi: string, group: SetGroupRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setImeiLock: (imsi: string, imeiLock?: SetImeiLockRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSubscriberToStandby: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSubscriber: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetExpiryTime: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGroup: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetImeiLock: (imsi: string, options?: any) => Promise<RequestArgs>;
    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpeedClass: (imsi: string, speedClass: UpdateSpeedClassRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifySubscriberTransferToken: (token: VerifySubscriberTransferTokenRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * SubscriberApi - functional programming interface
 * @export
 */
export declare const SubscriberApiFp: (configuration?: Configuration) => {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberSession(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTag(imsi: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTransferToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTermination(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTermination(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>>;
    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueSubscriberTransferTokenResponse>>;
    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionEvent>>>;
    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscriber>>>;
    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putBundles(imsi: string, bundles: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportLocalInfo(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>>;
    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>>;
    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setExpiryTime(imsi: string, request: ExpiryTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroup(imsi: string, group: SetGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSubscriberToStandby(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetExpiryTime(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGroup(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetImeiLock(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>>;
    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifySubscriberTransferTokenResponse>>;
};
/**
 * SubscriberApi - factory interface
 * @export
 */
export declare const SubscriberApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberSession(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTag(imsi: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscriberTransferToken(token: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): AxiosPromise<IssueSubscriberTransferTokenResponse>;
    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;
    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Subscriber>>;
    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putBundles(imsi: string, bundles: Array<string>, options?: any): AxiosPromise<Subscriber>;
    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;
    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportLocalInfo(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setExpiryTime(imsi: string, request: ExpiryTime, options?: any): AxiosPromise<Subscriber>;
    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroup(imsi: string, group: SetGroupRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSubscriberToStandby(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetExpiryTime(imsi: string, options?: any): AxiosPromise<void>;
    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetGroup(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetImeiLock(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): AxiosPromise<VerifySubscriberTransferTokenResponse>;
};
/**
 * SubscriberApi - interface
 * @export
 * @interface SubscriberApi
 */
export interface SubscriberApiInterface {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    activateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deactivateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberSession(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberTag(imsi: string, tagName: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberTransferToken(token: string, options?: any): AxiosPromise<void>;
    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    disableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    enableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;
    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    getSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): AxiosPromise<IssueSubscriberTransferTokenResponse>;
    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;
    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Subscriber>>;
    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    putBundles(imsi: string, bundles: Array<string>, options?: any): AxiosPromise<Subscriber>;
    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;
    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    reportLocalInfo(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;
    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setExpiryTime(imsi: string, request: ExpiryTime, options?: any): AxiosPromise<Subscriber>;
    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setGroup(imsi: string, group: SetGroupRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setSubscriberToStandby(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    suspendSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    terminateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetExpiryTime(imsi: string, options?: any): AxiosPromise<void>;
    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetGroup(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetImeiLock(imsi: string, options?: any): AxiosPromise<Subscriber>;
    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Subscriber>;
    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): AxiosPromise<VerifySubscriberTransferTokenResponse>;
}
/**
 * SubscriberApi - object-oriented interface
 * @export
 * @class SubscriberApi
 * @extends {BaseAPI}
 */
export declare class SubscriberApi extends BaseAPI implements SubscriberApiInterface {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    activateSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    deactivateSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    deleteSubscriberSession(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    deleteSubscriberTag(imsi: string, tagName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    deleteSubscriberTransferToken(token: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    disableTermination(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    enableTermination(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<DataEntry[]>>;
    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    getSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): Promise<import("axios").AxiosResponse<IssueSubscriberTransferTokenResponse>>;
    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<SessionEvent[]>>;
    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber[]>>;
    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    putBundles(imsi: string, bundles: Array<string>, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    reportLocalInfo(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<import("axios").AxiosResponse<SmsForwardingReport>>;
    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<import("axios").AxiosResponse<SmsForwardingReport>>;
    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    setExpiryTime(imsi: string, request: ExpiryTime, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    setGroup(imsi: string, group: SetGroupRequest, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    setSubscriberToStandby(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    suspendSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    terminateSubscriber(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    unsetExpiryTime(imsi: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    unsetGroup(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    unsetImeiLock(imsi: string, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<import("axios").AxiosResponse<Subscriber>>;
    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): Promise<import("axios").AxiosResponse<VerifySubscriberTransferTokenResponse>>;
}
/**
 * SystemNotificationApi - axios parameter creator
 * @export
 */
export declare const SystemNotificationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSystemNotification: (operatorId: string, type: 'billing', options?: any) => Promise<RequestArgs>;
    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemNotification: (operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSystemNotifications: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSystemNotification: (operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * SystemNotificationApi - functional programming interface
 * @export
 */
export declare const SystemNotificationApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSystemNotification(operatorId: string, type: 'billing', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNotificationsModel>>;
    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSystemNotifications(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SystemNotificationsModel>>>;
    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNotificationsModel>>;
};
/**
 * SystemNotificationApi - factory interface
 * @export
 */
export declare const SystemNotificationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSystemNotification(operatorId: string, type: 'billing', options?: any): AxiosPromise<void>;
    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): AxiosPromise<SystemNotificationsModel>;
    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSystemNotifications(operatorId: string, options?: any): AxiosPromise<Array<SystemNotificationsModel>>;
    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): AxiosPromise<SystemNotificationsModel>;
};
/**
 * SystemNotificationApi - interface
 * @export
 * @interface SystemNotificationApi
 */
export interface SystemNotificationApiInterface {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    deleteSystemNotification(operatorId: string, type: 'billing', options?: any): AxiosPromise<void>;
    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): AxiosPromise<SystemNotificationsModel>;
    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    listSystemNotifications(operatorId: string, options?: any): AxiosPromise<Array<SystemNotificationsModel>>;
    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): AxiosPromise<SystemNotificationsModel>;
}
/**
 * SystemNotificationApi - object-oriented interface
 * @export
 * @class SystemNotificationApi
 * @extends {BaseAPI}
 */
export declare class SystemNotificationApi extends BaseAPI implements SystemNotificationApiInterface {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    deleteSystemNotification(operatorId: string, type: 'billing', options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): Promise<import("axios").AxiosResponse<SystemNotificationsModel>>;
    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    listSystemNotifications(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<SystemNotificationsModel[]>>;
    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): Promise<import("axios").AxiosResponse<SystemNotificationsModel>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (operatorId: string, userName: string, request: CreateUserRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPassword: (operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAuthKey: (operatorId: string, userName: string, authKeyId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserPassword: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableUserMFA: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateUserAuthKey: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPermissions: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthKey: (operatorId: string, userName: string, authKeyId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMFAStatus: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPermission: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasUserPassword: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserAuthKeys: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: (operatorId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeUserMFA: (operatorId: string, userName: string, options?: any) => Promise<RequestArgs>;
    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDefaultPermissions: (operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (operatorId: string, userName: string, request: UpdateUserRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword: (operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPermission: (operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserMFA: (operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
export declare const UserApiFp: (configuration?: Configuration) => {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserPassword(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableUserMFA(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMFAOTPResponse>>;
    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateUserAuthKey(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateUserAuthKeyResponse>>;
    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPermissions(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDefaultPermissionsResponse>>;
    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailResponse>>;
    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthKeyResponse>>;
    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMFAStatus(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MFAStatusOfUseResponse>>;
    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPermission(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPermissionResponse>>;
    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasUserPassword(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPasswordResponse>>;
    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserAuthKeys(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthKeyResponse>>>;
    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailResponse>>>;
    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeUserMFA(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
export declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): AxiosPromise<void>;
    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;
    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateUserAuthKey(operatorId: string, userName: string, options?: any): AxiosPromise<GenerateUserAuthKeyResponse>;
    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPermissions(operatorId: string, options?: any): AxiosPromise<GetDefaultPermissionsResponse>;
    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(operatorId: string, userName: string, options?: any): AxiosPromise<UserDetailResponse>;
    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<AuthKeyResponse>;
    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMFAStatus(operatorId: string, userName: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;
    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPermission(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPermissionResponse>;
    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPasswordResponse>;
    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserAuthKeys(operatorId: string, userName: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;
    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(operatorId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;
    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): AxiosPromise<void>;
    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): AxiosPromise<void>;
    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    enableUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;
    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    generateUserAuthKey(operatorId: string, userName: string, options?: any): AxiosPromise<GenerateUserAuthKeyResponse>;
    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getDefaultPermissions(operatorId: string, options?: any): AxiosPromise<GetDefaultPermissionsResponse>;
    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(operatorId: string, userName: string, options?: any): AxiosPromise<UserDetailResponse>;
    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<AuthKeyResponse>;
    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserMFAStatus(operatorId: string, userName: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;
    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserPermission(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPermissionResponse>;
    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    hasUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPasswordResponse>;
    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUserAuthKeys(operatorId: string, userName: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;
    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUsers(operatorId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;
    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    revokeUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<void>;
    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;
    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): AxiosPromise<void>;
    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<void>;
}
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export declare class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserPassword(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    enableUserMFA(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<EnableMFAOTPResponse>>;
    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    generateUserAuthKey(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<GenerateUserAuthKeyResponse>>;
    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getDefaultPermissions(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<GetDefaultPermissionsResponse>>;
    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<UserDetailResponse>>;
    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<import("axios").AxiosResponse<AuthKeyResponse>>;
    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserMFAStatus(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<MFAStatusOfUseResponse>>;
    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserPermission(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<GetUserPermissionResponse>>;
    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    hasUserPassword(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<GetUserPasswordResponse>>;
    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listUserAuthKeys(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<AuthKeyResponse[]>>;
    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listUsers(operatorId: string, options?: any): Promise<import("axios").AxiosResponse<UserDetailResponse[]>>;
    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeUserMFA(operatorId: string, userName: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * VirtualPrivateGatewayApi - axios parameter creator
 * @export
 */
export declare const VirtualPrivateGatewayApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeGate: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMirroringPeer: (vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any) => Promise<RequestArgs>;
    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPacketCaptureSession: (vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualPrivateGateway: (createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVpcPeeringConnection: (vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMirroringPeer: (vpgId: string, ipaddr: string, options?: any) => Promise<RequestArgs>;
    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePacketCaptureSession: (vpgId: string, sessionId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry: (vpgId: string, key: string, options?: any) => Promise<RequestArgs>;
    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVpcPeeringConnection: (vpgId: string, pcxId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPacketCaptureSession: (vpgId: string, sessionId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualPrivateGateway: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatePeers: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPacketCaptureSessions: (vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGatewayIpAddressMapEntries: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGateways: (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openGate: (vpgId: string, configurationParameters?: OpenGateRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putVirtualPrivateGatewayIpAddressMapEntry: (vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGatePeer: (vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInspectionConfiguration: (vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any) => Promise<RequestArgs>;
    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRedirectionConfiguration: (vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any) => Promise<RequestArgs>;
    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRoutingFilter: (vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any) => Promise<RequestArgs>;
    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateVirtualPrivateGateway: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterGatePeer: (vpgId: string, outerIpAddress: string, options?: any) => Promise<RequestArgs>;
    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetInspectionConfiguration: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetRedirectionConfiguration: (vpgId: string, options?: any) => Promise<RequestArgs>;
    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMirroringPeer: (vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any) => Promise<RequestArgs>;
};
/**
 * VirtualPrivateGatewayApi - functional programming interface
 * @export
 */
export declare const VirtualPrivateGatewayApiFp: (configuration?: Configuration) => {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeGate(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>>;
    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualPrivateGateway>>;
    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVpcPeeringConnectionRequest>>;
    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>>;
    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpAddressMapEntry>>;
    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>>;
    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualPrivateGateway(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatePeers(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GatePeer>>>;
    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PacketCaptureSession>>>;
    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IpAddressMapEntry>>>;
    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualPrivateGateway>>>;
    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpAddressMapEntry>>;
    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatePeer>>;
    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateVirtualPrivateGateway(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetInspectionConfiguration(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetRedirectionConfiguration(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * VirtualPrivateGatewayApi - factory interface
 * @export
 */
export declare const VirtualPrivateGatewayApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeGate(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): AxiosPromise<void>;
    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): AxiosPromise<VirtualPrivateGateway>;
    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): AxiosPromise<CreateVpcPeeringConnectionRequest>;
    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): AxiosPromise<void>;
    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): AxiosPromise<IpAddressMapEntry>;
    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): AxiosPromise<void>;
    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGatePeers(vpgId: string, options?: any): AxiosPromise<Array<GatePeer>>;
    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<PacketCaptureSession>>;
    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): AxiosPromise<Array<IpAddressMapEntry>>;
    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<VirtualPrivateGateway>>;
    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): AxiosPromise<void>;
    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): AxiosPromise<IpAddressMapEntry>;
    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): AxiosPromise<GatePeer>;
    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): AxiosPromise<void>;
    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): AxiosPromise<void>;
    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): AxiosPromise<void>;
    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): AxiosPromise<void>;
    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetInspectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsetRedirectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): AxiosPromise<void>;
};
/**
 * VirtualPrivateGatewayApi - interface
 * @export
 * @interface VirtualPrivateGatewayApi
 */
export interface VirtualPrivateGatewayApiInterface {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    closeGate(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): AxiosPromise<void>;
    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): AxiosPromise<VirtualPrivateGateway>;
    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): AxiosPromise<CreateVpcPeeringConnectionRequest>;
    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): AxiosPromise<void>;
    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): AxiosPromise<IpAddressMapEntry>;
    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): AxiosPromise<void>;
    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;
    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    getVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listGatePeers(vpgId: string, options?: any): AxiosPromise<Array<GatePeer>>;
    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<PacketCaptureSession>>;
    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): AxiosPromise<Array<IpAddressMapEntry>>;
    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<VirtualPrivateGateway>>;
    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): AxiosPromise<void>;
    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): AxiosPromise<IpAddressMapEntry>;
    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): AxiosPromise<GatePeer>;
    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): AxiosPromise<void>;
    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): AxiosPromise<void>;
    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): AxiosPromise<void>;
    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    terminateVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): AxiosPromise<void>;
    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unsetInspectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unsetRedirectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;
    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): AxiosPromise<void>;
}
/**
 * VirtualPrivateGatewayApi - object-oriented interface
 * @export
 * @class VirtualPrivateGatewayApi
 * @extends {BaseAPI}
 */
export declare class VirtualPrivateGatewayApi extends BaseAPI implements VirtualPrivateGatewayApiInterface {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    closeGate(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): Promise<import("axios").AxiosResponse<PacketCaptureSession>>;
    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): Promise<import("axios").AxiosResponse<VirtualPrivateGateway>>;
    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): Promise<import("axios").AxiosResponse<CreateVpcPeeringConnectionRequest>>;
    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<import("axios").AxiosResponse<PacketCaptureSession>>;
    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): Promise<import("axios").AxiosResponse<IpAddressMapEntry>>;
    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<import("axios").AxiosResponse<PacketCaptureSession>>;
    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    getVirtualPrivateGateway(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    listGatePeers(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<GatePeer[]>>;
    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<import("axios").AxiosResponse<PacketCaptureSession[]>>;
    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<IpAddressMapEntry[]>>;
    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<import("axios").AxiosResponse<VirtualPrivateGateway[]>>;
    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): Promise<import("axios").AxiosResponse<IpAddressMapEntry>>;
    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): Promise<import("axios").AxiosResponse<GatePeer>>;
    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    terminateVirtualPrivateGateway(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    unsetInspectionConfiguration(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    unsetRedirectionConfiguration(vpgId: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
