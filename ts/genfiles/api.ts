/* tslint:disable */
/* eslint-disable */
/**
 * SORACOM API
 * SORACOM API v1
 *
 * The version of the OpenAPI document: VERSION_PLACEHOLDER
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIAuditLogEntry
 */
export interface APIAuditLogEntry {
    /**
     * The kind of the API (e.g. `/v1/auth`).
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    apiKind?: string;
    /**
     * The operator ID that called the API.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    operatorId?: string;
    /**
     * The IP address of the caller.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    remoteIpAddress?: string;
    /**
     * The request path that has been called.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    requestPath?: string;
    /**
     * The timestamp of the API call. This can be used as the `last_evaluated_key` request parameter, for pagination.
     * @type {number}
     * @memberof APIAuditLogEntry
     */
    requestedTimeEpochMs?: number;
    /**
     * The SAM username that called the API, if this parameter is empty, it means the caller user is the root user.
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    userName?: string;
}
/**
 * 
 * @export
 * @interface APICallError
 */
export interface APICallError {
    /**
     * 
     * @type {APICallErrorMessage}
     * @memberof APICallError
     */
    errorMessage?: APICallErrorMessage;
    /**
     * 
     * @type {number}
     * @memberof APICallError
     */
    httpStatus?: number;
}
/**
 * 
 * @export
 * @interface APICallErrorMessage
 */
export interface APICallErrorMessage {
    /**
     * エラーコード
     * @type {string}
     * @memberof APICallErrorMessage
     */
    code: string;
    /**
     * エラーメッセージ。リクエスト時にX-Soracom-Langヘッダーに言語(en,ja)を設定するとその言語のメッセージがセットされます。
     * @type {string}
     * @memberof APICallErrorMessage
     */
    message: string;
}
/**
 * 
 * @export
 * @interface APIKeyResponse
 */
export interface APIKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    apiKey?: string;
}
/**
 * 
 * @export
 * @interface ActionConfig
 */
export interface ActionConfig {
    /**
     * 
     * @type {ActionConfigProperty}
     * @memberof ActionConfig
     */
    properties: ActionConfigProperty;
    /**
     * 
     * @type {string}
     * @memberof ActionConfig
     */
    type: ActionConfigTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ActionConfigTypeEnum {
    ChangeSpeedClassAction = 'ChangeSpeedClassAction',
    InvokeAwsLambdaAction = 'InvokeAWSLambdaAction',
    ExecuteWebRequestAction = 'ExecuteWebRequestAction',
    SendMailAction = 'SendMailAction',
    SendMailToOperatorAction = 'SendMailToOperatorAction',
    ActivationAction = 'ActivationAction',
    DeactivationAction = 'DeactivationAction'
}

/**
 * 
 * @export
 * @interface ActionConfigProperty
 */
export interface ActionConfigProperty {
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    accessKey?: string;
    /**
     * Only for ExecuteWebRequestAction (Optional)
     * @type {string}
     * @memberof ActionConfigProperty
     */
    body?: string;
    /**
     * Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    contentType?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    endpoint?: string;
    /**
     * Run in the minutes after the timing of executionDateTimeConst
     * @type {number}
     * @memberof ActionConfigProperty
     */
    executionDateTimeConst: number;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    functionName?: string;
    /**
     * Only for ExecuteWebRequestAction (Optional)
     * @type {object}
     * @memberof ActionConfigProperty
     */
    headers?: object;
    /**
     * Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    httpMethod?: ActionConfigPropertyHttpMethodEnum;
    /**
     * Only for SendMailAction, SendMailToOperatorAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    message?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter1?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter2?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter3?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter4?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    parameter5?: string;
    /**
     * Only for InvokeAWSLambdaAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    secretAccessKey?: string;
    /**
     * Only for ChangeSpeedClassAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    speedClass?: ActionConfigPropertySpeedClassEnum;
    /**
     * Only for SendMailAction, SendMailToOperatorAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    title?: string;
    /**
     * Only for SendMailAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    to?: string;
    /**
     * Access URL and parameters. Only for ExecuteWebRequestAction
     * @type {string}
     * @memberof ActionConfigProperty
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ActionConfigPropertyHttpMethodEnum {
    Get = 'GET',
    Post = 'POST',
    Put = 'PUT',
    Delete = 'DELETE'
}
/**
    * @export
    * @enum {string}
    */
export enum ActionConfigPropertySpeedClassEnum {
    Minimum = 's1.minimum',
    Slow = 's1.slow',
    Standard = 's1.standard',
    Fast = 's1.fast'
}

/**
 * 
 * @export
 * @interface AirStatsResponse
 */
export interface AirStatsResponse {
    /**
     * 
     * @type {{ [key: string]: DataTrafficStats; }}
     * @memberof AirStatsResponse
     */
    dataTrafficStatsMap?: { [key: string]: DataTrafficStats; };
    /**
     * 
     * @type {string}
     * @memberof AirStatsResponse
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof AirStatsResponse
     */
    unixtime?: number;
}
/**
 * 
 * @export
 * @interface AttachRoleRequest
 */
export interface AttachRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof AttachRoleRequest
     */
    roleId?: string;
}
/**
 * 
 * @export
 * @interface AttributeUpdate
 */
export interface AttributeUpdate {
    /**
     * 
     * @type {string}
     * @memberof AttributeUpdate
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeUpdate
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface AuthKeyResponse
 */
export interface AuthKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthKeyResponse
     */
    authKeyId?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthKeyResponse
     */
    createDateTime?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthKeyResponse
     */
    lastUsedDateTime?: number;
}
/**
 * 
 * @export
 * @interface AuthRequest
 */
export interface AuthRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    authKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    mfaOTPCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    password?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthRequest
     */
    tokenTimeoutSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    userName?: string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    userName?: string;
}
/**
 * 
 * @export
 * @interface AvailableLongTermDiscountModel
 */
export interface AvailableLongTermDiscountModel {
    /**
     * Contract months
     * @type {number}
     * @memberof AvailableLongTermDiscountModel
     */
    contractTermMonth?: number;
    /**
     * Unit price
     * @type {number}
     * @memberof AvailableLongTermDiscountModel
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof AvailableLongTermDiscountModel
     */
    volumeDiscountPaymentType?: AvailableLongTermDiscountModelVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof AvailableLongTermDiscountModel
     */
    volumeDiscountType?: AvailableLongTermDiscountModelVolumeDiscountTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AvailableLongTermDiscountModelVolumeDiscountPaymentTypeEnum {
    Monthly = 'MONTHLY',
    Prepayment = 'PREPAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum AvailableLongTermDiscountModelVolumeDiscountTypeEnum {
    BasicChargeV2 = 'SORACOM_AIR_BASIC_CHARGE_V2',
    BasicCharge = 'SORACOM_AIR_BASIC_CHARGE',
    MonthlyFixedBasicCharge = 'SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE'
}

/**
 * 
 * @export
 * @interface AvailableLongTermDiscountResponse
 */
export interface AvailableLongTermDiscountResponse {
    /**
     * List of available long term discounts
     * @type {Array<AvailableLongTermDiscountModel>}
     * @memberof AvailableLongTermDiscountResponse
     */
    availableLongTermDiscounts?: Array<AvailableLongTermDiscountModel>;
}
/**
 * 
 * @export
 * @interface BeamStatsResponse
 */
export interface BeamStatsResponse {
    /**
     * 
     * @type {{ [key: string]: SoracomBeamStats; }}
     * @memberof BeamStatsResponse
     */
    beamStatsMap?: { [key: string]: SoracomBeamStats; };
    /**
     * 
     * @type {string}
     * @memberof BeamStatsResponse
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof BeamStatsResponse
     */
    unixtime?: number;
}
/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * The Cell Identity (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.3)
     * @type {number}
     * @memberof Cell
     */
    ci?: number;
    /**
     * The E-UTRAN Cell Identifer (for LTE networks), a 28 bit value represented in decimal form as a long. (See 3GPP TS 23.003 19.6)
     * @type {number}
     * @memberof Cell
     */
    eci?: number;
    /**
     * The Location Area Code (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.1)
     * @type {number}
     * @memberof Cell
     */
    lac?: number;
    /**
     * The Mobile Country Code, a 3 digit number.
     * @type {number}
     * @memberof Cell
     */
    mcc?: number;
    /**
     * The Mobile Network Code, a 2 or 3 digit number. If the value returned is only 1 digit in length, then you should prepend the value with a leading zero.
     * @type {number}
     * @memberof Cell
     */
    mnc?: number;
    /**
     * The Routing Area Code (for 2G and 3G networks), an 8 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 4.2)
     * @type {number}
     * @memberof Cell
     */
    rac?: number;
    /**
     * The Radio Access Technology or type of network that the device is connected to. Possible values are \"gsm\" for 2G or 3G networks, or \"lte\" for LTE networks. Unfortunately, it is not possible to differentiate 2G from 3G, or LTE from LTE Cat-M1.
     * @type {string}
     * @memberof Cell
     */
    radioType?: string;
    /**
     * The Service Area Code (for 2G and 3G networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 12.5)
     * @type {number}
     * @memberof Cell
     */
    sac?: number;
    /**
     * The Tracking Area Code (for LTE networks), a 16 bit value represented in decimal form as an integer. (See 3GPP TS 23.003 19.4.2.3)
     * @type {number}
     * @memberof Cell
     */
    tac?: number;
}
/**
 * 
 * @export
 * @interface CellIdentifier
 */
export interface CellIdentifier {
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    cid?: string;
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    ecid?: string;
    /**
     * optionally link the result to the request
     * @type {string}
     * @memberof CellIdentifier
     */
    identifier?: string;
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    lac?: string;
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    mnc?: string;
    /**
     * 
     * @type {string}
     * @memberof CellIdentifier
     */
    tac?: string;
}
/**
 * 
 * @export
 * @interface CellLocation
 */
export interface CellLocation {
    /**
     * Average signal strength from all observations for the cell network. This is an integer value, in dBm.
     * @type {number}
     * @memberof CellLocation
     */
    avgStrength?: number;
    /**
     * Timestamp of the time when this record was first created.
     * @type {string}
     * @memberof CellLocation
     */
    created?: string;
    /**
     * Whether or not this cell is a position estimate based on observations subject to change in the future (`0`) or an exact location entered from a knowledgeable source (`1`).
     * @type {number}
     * @memberof CellLocation
     */
    exact?: number;
    /**
     * Latitude
     * @type {number}
     * @memberof CellLocation
     */
    lat?: number;
    /**
     * Longitude
     * @type {number}
     * @memberof CellLocation
     */
    lon?: number;
    /**
     * Estimate of radio range, in meters. This is an estimate on how large each cell area is, as a radius around the estimated position and is based on the observations or a knowledgeable source.
     * @type {number}
     * @memberof CellLocation
     */
    range?: number;
    /**
     * Total number of observations used to calculate the estimated position, range and avg_strength.
     * @type {number}
     * @memberof CellLocation
     */
    samples?: number;
    /**
     * Timestamp of the time when this record was most recently modified.
     * @type {string}
     * @memberof CellLocation
     */
    updated?: string;
}
/**
 * 
 * @export
 * @interface CompanyInformationModel
 */
export interface CompanyInformationModel {
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    building?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    companyName: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    contactPersonName: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    department: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    vatIdentificationNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInformationModel
     */
    zipCode: string;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Config
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ContractUpdatedResponse
 */
export interface ContractUpdatedResponse {
    /**
     * 
     * @type {object}
     * @memberof ContractUpdatedResponse
     */
    contractDetail?: object;
    /**
     * 
     * @type {string}
     * @memberof ContractUpdatedResponse
     */
    contractName?: string;
}
/**
 * 
 * @export
 * @interface ContractUpdatingRequest
 */
export interface ContractUpdatingRequest {
    /**
     * 
     * @type {object}
     * @memberof ContractUpdatingRequest
     */
    contractDetail?: object;
    /**
     * 
     * @type {string}
     * @memberof ContractUpdatingRequest
     */
    contractName?: string;
}
/**
 * 
 * @export
 * @interface CouponResponse
 */
export interface CouponResponse {
    /**
     * Amount
     * @type {number}
     * @memberof CouponResponse
     */
    amount?: number;
    /**
     * Balance
     * @type {number}
     * @memberof CouponResponse
     */
    balance?: number;
    /**
     * Item
     * @type {string}
     * @memberof CouponResponse
     */
    billItemName?: string;
    /**
     * Coupon code
     * @type {string}
     * @memberof CouponResponse
     */
    couponCode?: string;
    /**
     * Expiry month
     * @type {string}
     * @memberof CouponResponse
     */
    expiryYearMonth?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof CouponResponse
     */
    orderId?: string;
}
/**
 * 
 * @export
 * @interface CreateAndUpdateCredentialsModel
 */
export interface CreateAndUpdateCredentialsModel {
    /**
     * 
     * @type {object}
     * @memberof CreateAndUpdateCredentialsModel
     */
    credentials?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateAndUpdateCredentialsModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndUpdateCredentialsModel
     */
    type?: CreateAndUpdateCredentialsModelTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateAndUpdateCredentialsModelTypeEnum {
    AwsCredentials = 'aws-credentials',
    AzureCredentials = 'azure-credentials',
    Psk = 'psk',
    X509 = 'x509'
}

/**
 * 
 * @export
 * @interface CreateEstimatedCouponRequest
 */
export interface CreateEstimatedCouponRequest {
    /**
     * Amount
     * @type {number}
     * @memberof CreateEstimatedCouponRequest
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface CreateEstimatedOrderRequest
 */
export interface CreateEstimatedOrderRequest {
    /**
     * Order item list
     * @type {Array<OrderItemModel>}
     * @memberof CreateEstimatedOrderRequest
     */
    orderItemList?: Array<OrderItemModel>;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof CreateEstimatedOrderRequest
     */
    shippingAddressId?: string;
}
/**
 * 
 * @export
 * @interface CreateEstimatedVolumeDiscountRequest
 */
export interface CreateEstimatedVolumeDiscountRequest {
    /**
     * Contract months
     * @type {number}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    contractTermMonth: number;
    /**
     * Quantity
     * @type {number}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    quantity: number;
    /**
     * Start date
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    startDate?: string;
    /**
     * Payment type
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    volumeDiscountPaymentType: CreateEstimatedVolumeDiscountRequestVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof CreateEstimatedVolumeDiscountRequest
     */
    volumeDiscountType: CreateEstimatedVolumeDiscountRequestVolumeDiscountTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateEstimatedVolumeDiscountRequestVolumeDiscountPaymentTypeEnum {
    Monthly = 'MONTHLY',
    Prepayment = 'PREPAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateEstimatedVolumeDiscountRequestVolumeDiscountTypeEnum {
    BasicChargeV2 = 'SORACOM_AIR_BASIC_CHARGE_V2',
    BasicCharge = 'SORACOM_AIR_BASIC_CHARGE',
    MonthlyFixedBasicCharge = 'SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE'
}

/**
 * 
 * @export
 * @interface CreateEventHandlerRequest
 */
export interface CreateEventHandlerRequest {
    /**
     * 
     * @type {Array<ActionConfig>}
     * @memberof CreateEventHandlerRequest
     */
    actionConfigList: Array<ActionConfig>;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    name?: string;
    /**
     * 
     * @type {RuleConfig}
     * @memberof CreateEventHandlerRequest
     */
    ruleConfig: RuleConfig;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    status: CreateEventHandlerRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetImsi?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetOperatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventHandlerRequest
     */
    targetSimId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateEventHandlerRequestStatusEnum {
    Inactive = 'inactive',
    Active = 'active'
}

/**
 * 
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof CreateGroupRequest
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateOrUpdateRoleRequest
 */
export interface CreateOrUpdateRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateRoleRequest
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof CreateOrUpdateRoleRequest
     */
    permission: string;
}
/**
 * 
 * @export
 * @interface CreatePortMappingRequest
 */
export interface CreatePortMappingRequest {
    /**
     * 
     * @type {PortMappingDestination}
     * @memberof CreatePortMappingRequest
     */
    destination: PortMappingDestination;
    /**
     * Specify the duration, in seconds, that remote access should be enabled.
     * @type {number}
     * @memberof CreatePortMappingRequest
     */
    duration?: number;
    /**
     * 
     * @type {PortMappingSource}
     * @memberof CreatePortMappingRequest
     */
    source?: PortMappingSource;
    /**
     * Specify whether access uses TLS.
     * @type {boolean}
     * @memberof CreatePortMappingRequest
     */
    tlsRequired?: boolean;
}
/**
 * 
 * @export
 * @interface CreateRoleResponse
 */
export interface CreateRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleResponse
     */
    roleId?: string;
}
/**
 * 
 * @export
 * @interface CreateSoraletRequest
 */
export interface CreateSoraletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSoraletRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSoraletRequest
     */
    soraletId: string;
}
/**
 * 
 * @export
 * @interface CreateUserPasswordRequest
 */
export interface CreateUserPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserPasswordRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface CreateVirtualPrivateGatewayRequest
 */
export interface CreateVirtualPrivateGatewayRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    deviceSubnetCidrRange?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    type: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateVirtualPrivateGatewayRequest
     */
    useInternetGateway?: boolean;
}
/**
 * 
 * @export
 * @interface CreateVpcPeeringConnectionRequest
 */
export interface CreateVpcPeeringConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    destinationCidrBlock?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerOwnerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVpcPeeringConnectionRequest
     */
    peerVpcId?: string;
}
/**
 * 
 * @export
 * @interface CredentialsModel
 */
export interface CredentialsModel {
    /**
     * 
     * @type {number}
     * @memberof CredentialsModel
     */
    createDateTime?: number;
    /**
     * 
     * @type {object}
     * @memberof CredentialsModel
     */
    credentials?: object;
    /**
     * 
     * @type {string}
     * @memberof CredentialsModel
     */
    credentialsId?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsModel
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CredentialsModel
     */
    lastUsedDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof CredentialsModel
     */
    type?: CredentialsModelTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CredentialsModel
     */
    updateDateTime?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CredentialsModelTypeEnum {
    AwsCredentials = 'aws-credentials',
    AzureCredentials = 'azure-credentials',
    Psk = 'psk',
    X509 = 'x509'
}

/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    cvc?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    expireMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    expireYear?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    number?: string;
}
/**
 * 
 * @export
 * @interface DailyBill
 */
export interface DailyBill {
    /**
     * 金額
     * @type {number}
     * @memberof DailyBill
     */
    amount?: number;
    /**
     * 年月日
     * @type {string}
     * @memberof DailyBill
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface DailyBillResponse
 */
export interface DailyBillResponse {
    /**
     * 日ごとの利用料リスト
     * @type {Array<DailyBill>}
     * @memberof DailyBillResponse
     */
    billList?: Array<DailyBill>;
}
/**
 * 
 * @export
 * @interface DataEntry
 */
export interface DataEntry {
    /**
     * 
     * @type {string}
     * @memberof DataEntry
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof DataEntry
     */
    contentType?: string;
    /**
     * 
     * @type {number}
     * @memberof DataEntry
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface DataSourceResourceMetadata
 */
export interface DataSourceResourceMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof DataSourceResourceMetadata
     */
    attributeNames?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DataSourceResourceMetadata
     */
    lastModifiedTime?: number;
    /**
     * 
     * @type {string}
     * @memberof DataSourceResourceMetadata
     */
    resourceId?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceResourceMetadata
     */
    resourceType?: string;
}
/**
 * 
 * @export
 * @interface DataTrafficStats
 */
export interface DataTrafficStats {
    /**
     * 
     * @type {number}
     * @memberof DataTrafficStats
     */
    downloadByteSizeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTrafficStats
     */
    downloadPacketSizeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTrafficStats
     */
    uploadByteSizeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTrafficStats
     */
    uploadPacketSizeTotal?: number;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    endpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    firmwareVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    lastRegistrationUpdate?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    manufacturer?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    modelNumber?: string;
    /**
     * 
     * @type {object}
     * @memberof Device
     */
    objects?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    online?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    registrationId?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    registrationLifeTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    serialNumber?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Device
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DeviceObjectModel
 */
export interface DeviceObjectModel {
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    createdTime?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    format?: DeviceObjectModelFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    objectId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    objectName?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceObjectModel
     */
    scope?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DeviceObjectModelFormatEnum {
    Xml = 'xml',
    Json = 'json'
}

/**
 * 
 * @export
 * @interface EmailsModel
 */
export interface EmailsModel {
    /**
     * 
     * @type {number}
     * @memberof EmailsModel
     */
    createDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof EmailsModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailsModel
     */
    emailId?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailsModel
     */
    updateDateTime?: number;
    /**
     * Whether the email address was verified by token.
     * @type {boolean}
     * @memberof EmailsModel
     */
    verified?: boolean;
}
/**
 * 
 * @export
 * @interface EnableMFAOTPResponse
 */
export interface EnableMFAOTPResponse {
    /**
     * 
     * @type {string}
     * @memberof EnableMFAOTPResponse
     */
    totpUri?: string;
}
/**
 * 
 * @export
 * @interface EstimatedCouponModel
 */
export interface EstimatedCouponModel {
    /**
     * Amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    amount?: number;
    /**
     * Currency
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    currency?: EstimatedCouponModelCurrencyEnum;
    /**
     * Expiry month
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    expiryYearMonth?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedCouponModel
     */
    orderId?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedCouponModel
     */
    totalAmount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum EstimatedCouponModelCurrencyEnum {
    Jpy = 'JPY',
    Usd = 'USD'
}

/**
 * 
 * @export
 * @interface EstimatedOrderItemModel
 */
export interface EstimatedOrderItemModel {
    /**
     * 
     * @type {ProductModel}
     * @memberof EstimatedOrderItemModel
     */
    product?: ProductModel;
    /**
     * Product amount
     * @type {number}
     * @memberof EstimatedOrderItemModel
     */
    productAmount?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof EstimatedOrderItemModel
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface EstimatedOrderModel
 */
export interface EstimatedOrderModel {
    /**
     * Email address
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    email?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    orderId?: string;
    /**
     * Order item list
     * @type {Array<EstimatedOrderItemModel>}
     * @memberof EstimatedOrderModel
     */
    orderItemList?: Array<EstimatedOrderItemModel>;
    /**
     * 
     * @type {ShippingAddressModel}
     * @memberof EstimatedOrderModel
     */
    shippingAddress?: ShippingAddressModel;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof EstimatedOrderModel
     */
    shippingAddressId?: string;
    /**
     * Shipping cost
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    shippingCost?: number;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedOrderModel
     */
    totalAmount?: number;
}
/**
 * 
 * @export
 * @interface EstimatedVolumeDiscountModel
 */
export interface EstimatedVolumeDiscountModel {
    /**
     * Currency
     * @type {string}
     * @memberof EstimatedVolumeDiscountModel
     */
    currency?: EstimatedVolumeDiscountModelCurrencyEnum;
    /**
     * Order ID
     * @type {string}
     * @memberof EstimatedVolumeDiscountModel
     */
    orderId?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof EstimatedVolumeDiscountModel
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof EstimatedVolumeDiscountModel
     */
    totalAmount?: number;
    /**
     * 
     * @type {VolumeDiscountModel}
     * @memberof EstimatedVolumeDiscountModel
     */
    volumeDiscount?: VolumeDiscountModel;
}

/**
    * @export
    * @enum {string}
    */
export enum EstimatedVolumeDiscountModelCurrencyEnum {
    Jpy = 'JPY',
    Usd = 'USD'
}

/**
 * 
 * @export
 * @interface EventHandlerModel
 */
export interface EventHandlerModel {
    /**
     * 
     * @type {Array<ActionConfig>}
     * @memberof EventHandlerModel
     */
    actionConfigList: Array<ActionConfig>;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    handlerId: string;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    name: string;
    /**
     * 
     * @type {RuleConfig}
     * @memberof EventHandlerModel
     */
    ruleConfig: RuleConfig;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    status: EventHandlerModelStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetImsi?: string;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetOperatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventHandlerModel
     */
    targetSimId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EventHandlerModelStatusEnum {
    Inactive = 'inactive',
    Active = 'active'
}

/**
 * 
 * @export
 * @interface ExecuteSoraletRequest
 */
export interface ExecuteSoraletRequest {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    direction: ExecuteSoraletRequestDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    encodingType?: ExecuteSoraletRequestEncodingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    payload: string;
    /**
     * 
     * @type {{ [key: string]: SoraletDataSource; }}
     * @memberof ExecuteSoraletRequest
     */
    source: { [key: string]: SoraletDataSource; };
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    userdata?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletRequest
     */
    version: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ExecuteSoraletRequestDirectionEnum {
    Uplink = 'uplink',
    Downlink = 'downlink'
}
/**
    * @export
    * @enum {string}
    */
export enum ExecuteSoraletRequestEncodingTypeEnum {
    Text = 'text',
    Binary = 'binary'
}

/**
 * 
 * @export
 * @interface ExecuteSoraletResponse
 */
export interface ExecuteSoraletResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    contentType?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSoraletResponse
     */
    encodingType?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecuteSoraletResponse
     */
    resultCode?: number;
}
/**
 * 
 * @export
 * @interface ExpiryTime
 */
export interface ExpiryTime {
    /**
     * 
     * @type {string}
     * @memberof ExpiryTime
     */
    expiryAction?: ExpiryTimeExpiryActionEnum;
    /**
     * The timestamp (in Unix milliseconds) of a date and time set using the Expiration function. If no Expiration function is set, null is returned.
     * @type {number}
     * @memberof ExpiryTime
     */
    expiryTime: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ExpiryTimeExpiryActionEnum {
    DoNothing = 'doNothing',
    DeleteSession = 'deleteSession',
    Deactivate = 'deactivate',
    Suspend = 'suspend',
    Terminate = 'terminate'
}

/**
 * 
 * @export
 * @interface ExportRequest
 */
export interface ExportRequest {
    /**
     * 
     * @type {number}
     * @memberof ExportRequest
     */
    from?: number;
    /**
     * 
     * @type {string}
     * @memberof ExportRequest
     */
    period?: ExportRequestPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof ExportRequest
     */
    to?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ExportRequestPeriodEnum {
    Month = 'month',
    Day = 'day',
    Minutes = 'minutes'
}

/**
 * 
 * @export
 * @interface FileEntry
 */
export interface FileEntry {
    /**
     * Content length of the file
     * @type {number}
     * @memberof FileEntry
     */
    contentLength?: number;
    /**
     * Content type of the file
     * @type {string}
     * @memberof FileEntry
     */
    contentType?: string;
    /**
     * Created time of the file
     * @type {number}
     * @memberof FileEntry
     */
    createdTime?: number;
    /**
     * Parent directory name
     * @type {string}
     * @memberof FileEntry
     */
    directory?: string;
    /**
     * Etag of the file
     * @type {string}
     * @memberof FileEntry
     */
    etag?: string;
    /**
     * Absolute path of the file
     * @type {string}
     * @memberof FileEntry
     */
    filePath?: string;
    /**
     * File name
     * @type {string}
     * @memberof FileEntry
     */
    filename?: string;
    /**
     * Whether the entry is directory or not
     * @type {boolean}
     * @memberof FileEntry
     */
    isDirectory?: boolean;
    /**
     * Last modified time of the file
     * @type {number}
     * @memberof FileEntry
     */
    lastModifiedTime?: number;
}
/**
 * 
 * @export
 * @interface FileExportResponse
 */
export interface FileExportResponse {
    /**
     * ファイル出力ID(リクエストにexport_mode=asyncを指定した場合）
     * @type {string}
     * @memberof FileExportResponse
     */
    exportedFileId?: string;
    /**
     * 出力済みファイル取得パス(リクエストにexport_mode=asyncを付与した場合）
     * @type {string}
     * @memberof FileExportResponse
     */
    exportedFilePath?: string;
    /**
     * ファイルダウンロードURL(export_mode指定なし、もしくはexport_mode=syncの場合
     * @type {string}
     * @memberof FileExportResponse
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface FunnelConfiguration
 */
export interface FunnelConfiguration {
    /**
     * 
     * @type {string}
     * @memberof FunnelConfiguration
     */
    credentialsId?: string;
    /**
     * 
     * @type {FunnelDestination}
     * @memberof FunnelConfiguration
     */
    destination?: FunnelDestination;
    /**
     * 
     * @type {boolean}
     * @memberof FunnelConfiguration
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface FunnelDestination
 */
export interface FunnelDestination {
    /**
     * 
     * @type {string}
     * @memberof FunnelDestination
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof FunnelDestination
     */
    resourceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof FunnelDestination
     */
    service?: string;
}
/**
 * 
 * @export
 * @interface Gadget
 */
export interface Gadget {
    /**
     * 
     * @type {object}
     * @memberof Gadget
     */
    attributes?: object;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {object}
     * @memberof Gadget
     */
    lastSeen?: object;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Gadget
     */
    status?: GadgetStatusEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Gadget
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof Gadget
     */
    terminationEnabled?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum GadgetStatusEnum {
    Active = 'active',
    Terminated = 'terminated'
}

/**
 * 
 * @export
 * @interface GadgetRegistrationRequest
 */
export interface GadgetRegistrationRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GadgetRegistrationRequest
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GatePeer
 */
export interface GatePeer {
    /**
     * 
     * @type {string}
     * @memberof GatePeer
     */
    innerIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GatePeer
     */
    outerIpAddress?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GatePeer
     */
    ownedByCustomer?: boolean;
}
/**
 * 
 * @export
 * @interface GenerateOperatorsAuthKeyResponse
 */
export interface GenerateOperatorsAuthKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof GenerateOperatorsAuthKeyResponse
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateOperatorsAuthKeyResponse
     */
    authKeyId?: string;
}
/**
 * 
 * @export
 * @interface GenerateTokenRequest
 */
export interface GenerateTokenRequest {
    /**
     * 新しい API トークンの有効期限の長さ（秒単位）。 指定しなければデフォルトは 86400 [秒]（24時間）。 最大値は 172800 [秒]（48時間）。 
     * @type {number}
     * @memberof GenerateTokenRequest
     */
    tokenTimeoutSeconds?: number;
}
/**
 * 
 * @export
 * @interface GenerateTokenResponse
 */
export interface GenerateTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof GenerateTokenResponse
     */
    token: string;
}
/**
 * 
 * @export
 * @interface GenerateUserAuthKeyResponse
 */
export interface GenerateUserAuthKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof GenerateUserAuthKeyResponse
     */
    authKey?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateUserAuthKeyResponse
     */
    authKeyId?: string;
}
/**
 * 
 * @export
 * @interface GetBillingHistoryResponse
 */
export interface GetBillingHistoryResponse {
    /**
     * 月ごとの利用料リスト
     * @type {Array<MonthlyBill>}
     * @memberof GetBillingHistoryResponse
     */
    billList?: Array<MonthlyBill>;
}
/**
 * 
 * @export
 * @interface GetDefaultPermissionsResponse
 */
export interface GetDefaultPermissionsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDefaultPermissionsResponse
     */
    defaultPermissions?: string;
}
/**
 * 
 * @export
 * @interface GetExportedFileResponse
 */
export interface GetExportedFileResponse {
    /**
     * ファイル出力ステータス
     * @type {string}
     * @memberof GetExportedFileResponse
     */
    status?: GetExportedFileResponseStatusEnum;
    /**
     * ファイルダウンロードURL
     * @type {string}
     * @memberof GetExportedFileResponse
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetExportedFileResponseStatusEnum {
    Processing = 'processing',
    Exported = 'exported',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface GetLatestBill
 */
export interface GetLatestBill {
    /**
     * 金額
     * @type {number}
     * @memberof GetLatestBill
     */
    amount?: number;
    /**
     * 利用額計算を実施した時間
     * @type {string}
     * @memberof GetLatestBill
     */
    lastEvaluatedTime?: string;
}
/**
 * 
 * @export
 * @interface GetOperatorResponse
 */
export interface GetOperatorResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    createDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    operatorId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    rootOperatorId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOperatorResponse
     */
    updateDate: string;
}
/**
 * 
 * @export
 * @interface GetOrderResponse
 */
export interface GetOrderResponse {
    /**
     * Email address
     * @type {string}
     * @memberof GetOrderResponse
     */
    email?: string;
    /**
     * Order date and time
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderDateTime?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderId?: string;
    /**
     * Order item list
     * @type {Array<EstimatedOrderItemModel>}
     * @memberof GetOrderResponse
     */
    orderItemList?: Array<EstimatedOrderItemModel>;
    /**
     * Order status
     * @type {string}
     * @memberof GetOrderResponse
     */
    orderStatus?: GetOrderResponseOrderStatusEnum;
    /**
     * 
     * @type {ShippingAddressModel}
     * @memberof GetOrderResponse
     */
    shippingAddress?: ShippingAddressModel;
    /**
     * Shipping address ID
     * @type {string}
     * @memberof GetOrderResponse
     */
    shippingAddressId?: string;
    /**
     * Shipping cost
     * @type {number}
     * @memberof GetOrderResponse
     */
    shippingCost?: number;
    /**
     * Shipping label number
     * @type {string}
     * @memberof GetOrderResponse
     */
    shippingLabelNumber?: string;
    /**
     * Tax amount
     * @type {number}
     * @memberof GetOrderResponse
     */
    taxAmount?: number;
    /**
     * Total amount
     * @type {number}
     * @memberof GetOrderResponse
     */
    totalAmount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOrderResponseOrderStatusEnum {
    Ordering = 'ordering',
    Ordered = 'ordered',
    Kitting = 'kitting',
    Shipped = 'shipped',
    Received = 'received',
    Cancelling = 'cancelling',
    Cancelled = 'cancelled',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface GetPaymentMethodResult
 */
export interface GetPaymentMethodResult {
    /**
     * Error code (only if payment information is invalid)
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    errorCode?: GetPaymentMethodResultErrorCodeEnum;
    /**
     * Error message (only if payment information is invalid)
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    errorMessage?: string;
    /**
     * Payment information
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    properties?: string;
    /**
     * Provider type
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    providerType?: GetPaymentMethodResultProviderTypeEnum;
    /**
     * Update date
     * @type {string}
     * @memberof GetPaymentMethodResult
     */
    updateDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetPaymentMethodResultErrorCodeEnum {
    Success = 'success',
    Processing = 'processing',
    InvalidRequest = 'invalid_request',
    InvalidNumber = 'invalid_number',
    IncorrectNumber = 'incorrect_number',
    InvalidName = 'invalid_name',
    InvalidExpiryMonth = 'invalid_expiry_month',
    InvalidExpiryYear = 'invalid_expiry_year',
    InvalidExpiry = 'invalid_expiry',
    IncorrectExpiry = 'incorrect_expiry',
    InvalidCvc = 'invalid_cvc',
    IncorrectCvc = 'incorrect_cvc',
    CardDeclined = 'card_declined',
    Missing = 'missing',
    ProcessingError = 'processing_error'
}
/**
    * @export
    * @enum {string}
    */
export enum GetPaymentMethodResultProviderTypeEnum {
    WebPay = 'WebPay'
}

/**
 * 
 * @export
 * @interface GetPaymentTransactionResult
 */
export interface GetPaymentTransactionResult {
    /**
     * 
     * @type {PaymentAmount}
     * @memberof GetPaymentTransactionResult
     */
    amount?: PaymentAmount;
    /**
     * 
     * @type {PaymentDescription}
     * @memberof GetPaymentTransactionResult
     */
    description?: PaymentDescription;
    /**
     * Message
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    message?: string;
    /**
     * Message code
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    messageCode?: GetPaymentTransactionResultMessageCodeEnum;
    /**
     * Status
     * @type {string}
     * @memberof GetPaymentTransactionResult
     */
    status?: GetPaymentTransactionResultStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetPaymentTransactionResultMessageCodeEnum {
    Success = 'success',
    Processing = 'processing',
    InvalidRequest = 'invalid_request',
    InvalidNumber = 'invalid_number',
    IncorrectNumber = 'incorrect_number',
    InvalidName = 'invalid_name',
    InvalidExpiryMonth = 'invalid_expiry_month',
    InvalidExpiryYear = 'invalid_expiry_year',
    InvalidExpiry = 'invalid_expiry',
    IncorrectExpiry = 'incorrect_expiry',
    InvalidCvc = 'invalid_cvc',
    IncorrectCvc = 'incorrect_cvc',
    CardDeclined = 'card_declined',
    Missing = 'missing',
    ProcessingError = 'processing_error'
}
/**
    * @export
    * @enum {string}
    */
export enum GetPaymentTransactionResultStatusEnum {
    Success = 'success',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface GetShippingAddressResponse
 */
export interface GetShippingAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    building?: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    phoneNumber: string;
    /**
     * 配送先ID
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    shippingAddressId: string;
    /**
     * 配送先エリア
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    shippingArea: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingAddressResponse
     */
    zipCode: string;
}
/**
 * 
 * @export
 * @interface GetUserPasswordResponse
 */
export interface GetUserPasswordResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserPasswordResponse
     */
    hasPassword?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserPermissionResponse
 */
export interface GetUserPermissionResponse {
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof GetUserPermissionResponse
     */
    permission: string;
}
/**
 * 
 * @export
 * @interface GetVolumeDiscountResponse
 */
export interface GetVolumeDiscountResponse {
    /**
     * Contract date time
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    contractDateTime?: string;
    /**
     * Contract ID
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    contractId?: string;
    /**
     * Contract months
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    contractTermMonth?: number;
    /**
     * End date
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    endDate?: string;
    /**
     * Initial cost
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    initialCost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    quantity?: number;
    /**
     * Start date
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    startDate?: string;
    /**
     * Status
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    status?: GetVolumeDiscountResponseStatusEnum;
    /**
     * Unit price
     * @type {number}
     * @memberof GetVolumeDiscountResponse
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    volumeDiscountPaymentType?: GetVolumeDiscountResponseVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof GetVolumeDiscountResponse
     */
    volumeDiscountType?: GetVolumeDiscountResponseVolumeDiscountTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetVolumeDiscountResponseStatusEnum {
    Active = 'active',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum GetVolumeDiscountResponseVolumeDiscountPaymentTypeEnum {
    Monthly = 'MONTHLY',
    Prepayment = 'PREPAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum GetVolumeDiscountResponseVolumeDiscountTypeEnum {
    BasicChargeV2 = 'SORACOM_AIR_BASIC_CHARGE_V2',
    BasicCharge = 'SORACOM_AIR_BASIC_CHARGE',
    MonthlyFixedBasicCharge = 'SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE'
}

/**
 * 
 * @export
 * @interface GlobalSimAppletPLMNRecord
 */
export interface GlobalSimAppletPLMNRecord {
    /**
     * 
     * @type {number}
     * @memberof GlobalSimAppletPLMNRecord
     */
    containerId: number;
    /**
     * 
     * @type {string}
     * @memberof GlobalSimAppletPLMNRecord
     */
    mcc: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalSimAppletPLMNRecord
     */
    mnc?: string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Group
     */
    configuration?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    groupId?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    lastModifiedTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    operatorId?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof Group
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GroupConfigurationUpdateRequest
 */
export interface GroupConfigurationUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupConfigurationUpdateRequest
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof GroupConfigurationUpdateRequest
     */
    value: string;
}
/**
 * 
 * @export
 * @interface HarvestExportedDataStatsResponse
 */
export interface HarvestExportedDataStatsResponse {
    /**
     * exportedBytes
     * @type {number}
     * @memberof HarvestExportedDataStatsResponse
     */
    exportedBytes?: number;
    /**
     * yearMonth
     * @type {string}
     * @memberof HarvestExportedDataStatsResponse
     */
    yearMonth?: string;
}
/**
 * The IMEI of a modem or device that is allowed to use the subscriber/SIM, which is set using the IMEI Lock function. When enabled, the value returned is a string of length 15, which contain the IMEI number. If IMEI Lock is not enabled, null is returned.
 * @export
 * @interface ImeiLock
 */
export interface ImeiLock {
    /**
     * 
     * @type {string}
     * @memberof ImeiLock
     */
    imei?: string;
}
/**
 * 
 * @export
 * @interface IndividualInformationModel
 */
export interface IndividualInformationModel {
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    building?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualInformationModel
     */
    zipCode?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    groupId?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * A flag to indicate if it should cause a switch to the subscription after the download has finished. If it is set to true, the downloaded subscriber will be enabled immediately. 
     * @type {boolean}
     * @memberof InlineObject2
     */
    enable?: boolean;
    /**
     * Name of the sbscription plan
     * @type {string}
     * @memberof InlineObject2
     */
    subscription: string;
}
/**
 * 
 * @export
 * @interface IpAddressMapEntry
 */
export interface IpAddressMapEntry {
    /**
     * 
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAddressMapEntry
     */
    type?: IpAddressMapEntryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum IpAddressMapEntryTypeEnum {
    Static = 'static',
    Dynamic = 'dynamic',
    CustomerGatePeer = 'customerGatePeer',
    GatePeer = 'gatePeer'
}

/**
 * 
 * @export
 * @interface IssueAddEmailTokenRequest
 */
export interface IssueAddEmailTokenRequest {
    /**
     * Email address to be added
     * @type {string}
     * @memberof IssueAddEmailTokenRequest
     */
    email: string;
    /**
     * Password of the operator
     * @type {string}
     * @memberof IssueAddEmailTokenRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface IssueEmailChangeTokenRequest
 */
export interface IssueEmailChangeTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IssueEmailChangeTokenRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IssuePasswordResetTokenRequest
 */
export interface IssuePasswordResetTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IssuePasswordResetTokenRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IssueSubscriberTransferTokenRequest
 */
export interface IssueSubscriberTransferTokenRequest {
    /**
     * 移管先オペレーターEmail
     * @type {string}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferDestinationOperatorEmail: string;
    /**
     * 移管先オペレーターID
     * @type {string}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferDestinationOperatorId: string;
    /**
     * 移管するIMSIリスト
     * @type {Array<string>}
     * @memberof IssueSubscriberTransferTokenRequest
     */
    transferImsi: Array<string>;
}
/**
 * 
 * @export
 * @interface IssueSubscriberTransferTokenResponse
 */
export interface IssueSubscriberTransferTokenResponse {
    /**
     * トークン
     * @type {string}
     * @memberof IssueSubscriberTransferTokenResponse
     */
    token: string;
}
/**
 * 
 * @export
 * @interface JunctionInspectionConfiguration
 */
export interface JunctionInspectionConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof JunctionInspectionConfiguration
     */
    enabled?: boolean;
    /**
     * 
     * @type {FunnelConfiguration}
     * @memberof JunctionInspectionConfiguration
     */
    report?: FunnelConfiguration;
}
/**
 * 
 * @export
 * @interface JunctionMirroringConfiguration
 */
export interface JunctionMirroringConfiguration {
    /**
     * 
     * @type {{ [key: string]: JunctionMirroringPeer; }}
     * @memberof JunctionMirroringConfiguration
     */
    peers?: { [key: string]: JunctionMirroringPeer; };
}
/**
 * 
 * @export
 * @interface JunctionMirroringPeer
 */
export interface JunctionMirroringPeer {
    /**
     * 
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JunctionMirroringPeer
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof JunctionMirroringPeer
     */
    protocol?: JunctionMirroringPeerProtocolEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum JunctionMirroringPeerProtocolEnum {
    Gre = 'gre'
}

/**
 * 
 * @export
 * @interface JunctionRedirectionConfiguration
 */
export interface JunctionRedirectionConfiguration {
    /**
     * 
     * @type {string}
     * @memberof JunctionRedirectionConfiguration
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JunctionRedirectionConfiguration
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JunctionRedirectionConfiguration
     */
    gateway?: string;
}
/**
 * 
 * @export
 * @interface LagoonDashboardPermissionsResponse
 */
export interface LagoonDashboardPermissionsResponse {
    /**
     * 
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponse
     */
    dashboardId?: number;
    /**
     * 
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponse
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {Array<LagoonDashboardPermissionsResponsePermissions>}
     * @memberof LagoonDashboardPermissionsResponse
     */
    permissions?: Array<LagoonDashboardPermissionsResponsePermissions>;
}
/**
 * 
 * @export
 * @interface LagoonDashboardPermissionsResponsePermissions
 */
export interface LagoonDashboardPermissionsResponsePermissions {
    /**
     * 
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    dashboardId?: number;
    /**
     * 
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    permissionName?: LagoonDashboardPermissionsResponsePermissionsPermissionNameEnum;
    /**
     * 
     * @type {string}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    userEmail?: string;
    /**
     * 
     * @type {number}
     * @memberof LagoonDashboardPermissionsResponsePermissions
     */
    userId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonDashboardPermissionsResponsePermissionsPermissionNameEnum {
    View = 'View',
    Edit = 'Edit',
    Admin = 'Admin'
}

/**
 * 
 * @export
 * @interface LagoonDashboardPermissionsUpdatingRequest
 */
export interface LagoonDashboardPermissionsUpdatingRequest {
    /**
     * 
     * @type {Array<LagoonDashboardPermissionsUpdatingRequestPermissions>}
     * @memberof LagoonDashboardPermissionsUpdatingRequest
     */
    permissions?: Array<LagoonDashboardPermissionsUpdatingRequestPermissions>;
}
/**
 * 
 * @export
 * @interface LagoonDashboardPermissionsUpdatingRequestPermissions
 */
export interface LagoonDashboardPermissionsUpdatingRequestPermissions {
    /**
     * 
     * @type {string}
     * @memberof LagoonDashboardPermissionsUpdatingRequestPermissions
     */
    permission?: string;
    /**
     * 
     * @type {number}
     * @memberof LagoonDashboardPermissionsUpdatingRequestPermissions
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface LagoonLicensePackStatusResponse
 */
export interface LagoonLicensePackStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof LagoonLicensePackStatusResponse
     */
    licensePackName?: string;
    /**
     * 
     * @type {number}
     * @memberof LagoonLicensePackStatusResponse
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface LagoonLicensePacksUpdatingRequest
 */
export interface LagoonLicensePacksUpdatingRequest {
    /**
     * 
     * @type {Array<LagoonLicensePacksUpdatingRequestLicensePackQuantities>}
     * @memberof LagoonLicensePacksUpdatingRequest
     */
    licensePackQuantities?: Array<LagoonLicensePacksUpdatingRequestLicensePackQuantities>;
}
/**
 * 
 * @export
 * @interface LagoonLicensePacksUpdatingRequestLicensePackQuantities
 */
export interface LagoonLicensePacksUpdatingRequestLicensePackQuantities {
    /**
     * 
     * @type {number}
     * @memberof LagoonLicensePacksUpdatingRequestLicensePackQuantities
     */
    desiredQuantity?: number;
    /**
     * 
     * @type {string}
     * @memberof LagoonLicensePacksUpdatingRequestLicensePackQuantities
     */
    licensePackName?: string;
}
/**
 * 
 * @export
 * @interface LagoonPlanChangingRequest
 */
export interface LagoonPlanChangingRequest {
    /**
     * 
     * @type {string}
     * @memberof LagoonPlanChangingRequest
     */
    plan?: LagoonPlanChangingRequestPlanEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonPlanChangingRequestPlanEnum {
    Maker = 'maker',
    Pro = 'pro',
    Free = 'free'
}

/**
 * 
 * @export
 * @interface LagoonRegistrationRequest
 */
export interface LagoonRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof LagoonRegistrationRequest
     */
    plan?: LagoonRegistrationRequestPlanEnum;
    /**
     * This password is used by the initial user\'s login.
     * @type {string}
     * @memberof LagoonRegistrationRequest
     */
    userPassword?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonRegistrationRequestPlanEnum {
    Maker = 'maker'
}

/**
 * 
 * @export
 * @interface LagoonRegistrationResponse
 */
export interface LagoonRegistrationResponse {
    /**
     * This email address is used on login with the initial user.
     * @type {string}
     * @memberof LagoonRegistrationResponse
     */
    lagoonUserEmail?: string;
}
/**
 * 
 * @export
 * @interface LagoonUser
 */
export interface LagoonUser {
    /**
     * This value used on login.
     * @type {string}
     * @memberof LagoonUser
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof LagoonUser
     */
    id?: number;
    /**
     * The last login datetime.
     * @type {string}
     * @memberof LagoonUser
     */
    lastSeenAt?: string;
    /**
     * The last login datetime as age.
     * @type {string}
     * @memberof LagoonUser
     */
    lastSeenAtAge?: string;
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUser
     */
    role?: LagoonUserRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonUserRoleEnum {
    Viewer = 'Viewer',
    Editor = 'Editor'
}

/**
 * 
 * @export
 * @interface LagoonUserCreationRequest
 */
export interface LagoonUserCreationRequest {
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    role?: LagoonUserCreationRequestRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    userEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof LagoonUserCreationRequest
     */
    userPassword?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonUserCreationRequestRoleEnum {
    Viewer = 'Viewer',
    Editor = 'Editor'
}

/**
 * 
 * @export
 * @interface LagoonUserCreationResponse
 */
export interface LagoonUserCreationResponse {
    /**
     * Lagoon user ID assigned to the created user.
     * @type {number}
     * @memberof LagoonUserCreationResponse
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface LagoonUserEmailUpdatingRequest
 */
export interface LagoonUserEmailUpdatingRequest {
    /**
     * 
     * @type {string}
     * @memberof LagoonUserEmailUpdatingRequest
     */
    userEmail?: string;
}
/**
 * 
 * @export
 * @interface LagoonUserPasswordUpdatingRequest
 */
export interface LagoonUserPasswordUpdatingRequest {
    /**
     * 
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    newPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    oldPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof LagoonUserPasswordUpdatingRequest
     */
    userEmail?: string;
}
/**
 * 
 * @export
 * @interface LagoonUserPermissionUpdatingRequest
 */
export interface LagoonUserPermissionUpdatingRequest {
    /**
     * A role that represents the permission.
     * @type {string}
     * @memberof LagoonUserPermissionUpdatingRequest
     */
    role?: LagoonUserPermissionUpdatingRequestRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LagoonUserPermissionUpdatingRequestRoleEnum {
    Viewer = 'Viewer',
    Editor = 'Editor'
}

/**
 * 
 * @export
 * @interface LastSeen
 */
export interface LastSeen {
    /**
     * 
     * @type {number}
     * @memberof LastSeen
     */
    rssi?: number;
    /**
     * 
     * @type {number}
     * @memberof LastSeen
     */
    snr?: number;
    /**
     * 
     * @type {string}
     * @memberof LastSeen
     */
    time?: string;
}
/**
 * 
 * @export
 * @interface ListCouponResponse
 */
export interface ListCouponResponse {
    /**
     * Coupons
     * @type {Array<CouponResponse>}
     * @memberof ListCouponResponse
     */
    couponList?: Array<CouponResponse>;
}
/**
 * 
 * @export
 * @interface ListOrderResponse
 */
export interface ListOrderResponse {
    /**
     * List of confirmed orders
     * @type {Array<GetOrderResponse>}
     * @memberof ListOrderResponse
     */
    orderList?: Array<GetOrderResponse>;
}
/**
 * 
 * @export
 * @interface ListOrderedSubscriberResponse
 */
export interface ListOrderedSubscriberResponse {
    /**
     * List of ordered SIMs
     * @type {Array<OrderedSubscriber>}
     * @memberof ListOrderedSubscriberResponse
     */
    orderedSubscriberList?: Array<OrderedSubscriber>;
}
/**
 * 
 * @export
 * @interface ListPaymentStatementResponse
 */
export interface ListPaymentStatementResponse {
    /**
     * Payment statements
     * @type {Array<PaymentStatementResponse>}
     * @memberof ListPaymentStatementResponse
     */
    paymentStatementsList?: Array<PaymentStatementResponse>;
}
/**
 * 
 * @export
 * @interface ListProductResponse
 */
export interface ListProductResponse {
    /**
     * 
     * @type {Array<ProductModel>}
     * @memberof ListProductResponse
     */
    productList?: Array<ProductModel>;
    /**
     * 
     * @type {Array<ShippingCostModel>}
     * @memberof ListProductResponse
     */
    shippingCostList?: Array<ShippingCostModel>;
}
/**
 * 
 * @export
 * @interface ListRolesResponse
 */
export interface ListRolesResponse {
    /**
     * 
     * @type {number}
     * @memberof ListRolesResponse
     */
    createDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof ListRolesResponse
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ListRolesResponse
     */
    roleId?: string;
    /**
     * 
     * @type {number}
     * @memberof ListRolesResponse
     */
    updateDateTime?: number;
}
/**
 * 
 * @export
 * @interface ListShippingAddressResponse
 */
export interface ListShippingAddressResponse {
    /**
     * 
     * @type {Array<GetShippingAddressResponse>}
     * @memberof ListShippingAddressResponse
     */
    shippingAddresses?: Array<GetShippingAddressResponse>;
}
/**
 * 
 * @export
 * @interface ListSubOperatorsResponse
 */
export interface ListSubOperatorsResponse {
    /**
     * 
     * @type {string}
     * @memberof ListSubOperatorsResponse
     */
    operatorId?: string;
}
/**
 * 
 * @export
 * @interface ListVolumeDiscountResponse
 */
export interface ListVolumeDiscountResponse {
    /**
     * Contracted long term discounts
     * @type {Array<GetVolumeDiscountResponse>}
     * @memberof ListVolumeDiscountResponse
     */
    volumeDiscountList?: Array<GetVolumeDiscountResponse>;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {object}
     * @memberof LogEntry
     */
    body?: object;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    resourceId?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    resourceType?: LogEntryResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    service?: LogEntryServiceEnum;
    /**
     * 
     * @type {number}
     * @memberof LogEntry
     */
    time?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum LogEntryResourceTypeEnum {
    Subscriber = 'Subscriber',
    EventHandler = 'EventHandler',
    VirtualPrivateGateway = 'VirtualPrivateGateway'
}
/**
    * @export
    * @enum {string}
    */
export enum LogEntryServiceEnum {
    Air = 'Air',
    Beam = 'Beam',
    Canal = 'Canal',
    Direct = 'Direct',
    Door = 'Door',
    Endorse = 'Endorse',
    Funnel = 'Funnel',
    Gate = 'Gate'
}

/**
 * 
 * @export
 * @interface LoraData
 */
export interface LoraData {
    /**
     * 
     * @type {string}
     * @memberof LoraData
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof LoraData
     */
    fPort?: number;
}
/**
 * 
 * @export
 * @interface LoraDevice
 */
export interface LoraDevice {
    /**
     * 
     * @type {string}
     * @memberof LoraDevice
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraDevice
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraDevice
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {LastSeen}
     * @memberof LoraDevice
     */
    lastSeen?: LastSeen;
    /**
     * 
     * @type {string}
     * @memberof LoraDevice
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraDevice
     */
    status?: LoraDeviceStatusEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LoraDevice
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof LoraDevice
     */
    terminationEnabled?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum LoraDeviceStatusEnum {
    Active = 'active',
    Ready = 'ready',
    Terminated = 'terminated',
    Instock = 'instock'
}

/**
 * 
 * @export
 * @interface LoraGateway
 */
export interface LoraGateway {
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    createdTime?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    gatewayId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    networkSetId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoraGateway
     */
    online?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    operatorId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoraGateway
     */
    owned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoraGateway
     */
    status?: LoraGatewayStatusEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LoraGateway
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof LoraGateway
     */
    terminationEnabled?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum LoraGatewayStatusEnum {
    Active = 'active',
    Terminated = 'terminated',
    Ready = 'ready',
    Instock = 'instock'
}

/**
 * 
 * @export
 * @interface LoraNetworkSet
 */
export interface LoraNetworkSet {
    /**
     * 
     * @type {Set<string>}
     * @memberof LoraNetworkSet
     */
    allowedOperators?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof LoraNetworkSet
     */
    createdTime?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraNetworkSet
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraNetworkSet
     */
    networkSetId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoraNetworkSet
     */
    operatorId?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LoraNetworkSet
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface MFAAuthenticationRequest
 */
export interface MFAAuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof MFAAuthenticationRequest
     */
    mfaOTPCode?: string;
}
/**
 * 
 * @export
 * @interface MFAIssueRevokingTokenRequest
 */
export interface MFAIssueRevokingTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof MFAIssueRevokingTokenRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof MFAIssueRevokingTokenRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface MFARevokingTokenVerifyRequest
 */
export interface MFARevokingTokenVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    backupCode?: string;
    /**
     * 
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof MFARevokingTokenVerifyRequest
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface MFAStatusOfUseResponse
 */
export interface MFAStatusOfUseResponse {
    /**
     * 
     * @type {string}
     * @memberof MFAStatusOfUseResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface MappingEntries
 */
export interface MappingEntries {
    /**
     * 
     * @type {Array<GlobalSimAppletPLMNRecord>}
     * @memberof MappingEntries
     */
    mappingEntries?: Array<GlobalSimAppletPLMNRecord>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    fields?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface MonthlyBill
 */
export interface MonthlyBill {
    /**
     * 金額
     * @type {number}
     * @memberof MonthlyBill
     */
    amount?: number;
    /**
     * 直近の課金ステータス
     * @type {string}
     * @memberof MonthlyBill
     */
    paymentStatus?: MonthlyBillPaymentStatusEnum;
    /**
     * 課金詳細取得用のID
     * @type {string}
     * @memberof MonthlyBill
     */
    paymentTransactionId?: string;
    /**
     * 年月
     * @type {string}
     * @memberof MonthlyBill
     */
    yearMonth?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MonthlyBillPaymentStatusEnum {
    LessThanMinimumCharge = 'lessThanMinimumCharge',
    Paying = 'paying',
    Paid = 'paid',
    Refunding = 'refunding',
    Refunded = 'refunded',
    Fail = 'fail'
}

/**
 * 
 * @export
 * @interface NapterAuditLogDirection
 */
export interface NapterAuditLogDirection {
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogDirection
     */
    destinationIPAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof NapterAuditLogDirection
     */
    destinationPort?: number;
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogDirection
     */
    sourceIPAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof NapterAuditLogDirection
     */
    sourcePort?: number;
}
/**
 * 
 * @export
 * @interface NapterAuditLogEntry
 */
export interface NapterAuditLogEntry {
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    connectionId?: string;
    /**
     * 
     * @type {number}
     * @memberof NapterAuditLogEntry
     */
    createdAt?: number;
    /**
     * 
     * @type {NapterAuditLogDirection}
     * @memberof NapterAuditLogEntry
     */
    direction?: NapterAuditLogDirection;
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    imsi?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NapterAuditLogEntry
     */
    isTLS?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof NapterAuditLogEntry
     */
    type?: NapterAuditLogEntryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum NapterAuditLogEntryTypeEnum {
    Access = 'ACCESS',
    Denied = 'DENIED',
    Connected = 'CONNECTED',
    Closed = 'CLOSED',
    Refused = 'REFUSED',
    Created = 'CREATED',
    Deleted = 'DELETED',
    Expired = 'EXPIRED'
}

/**
 * 
 * @export
 * @interface NapterAuditLogsExportedDataStatsResponse
 */
export interface NapterAuditLogsExportedDataStatsResponse {
    /**
     * exportedBytes
     * @type {number}
     * @memberof NapterAuditLogsExportedDataStatsResponse
     */
    exportedBytes?: number;
    /**
     * yearMonth
     * @type {string}
     * @memberof NapterAuditLogsExportedDataStatsResponse
     */
    yearMonth?: string;
}
/**
 * 
 * @export
 * @interface ObjectInstance
 */
export interface ObjectInstance {
    /**
     * 
     * @type {number}
     * @memberof ObjectInstance
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ObjectInstance
     */
    observed?: boolean;
    /**
     * 
     * @type {{ [key: string]: ResourceInstance; }}
     * @memberof ObjectInstance
     */
    resources?: { [key: string]: ResourceInstance; };
}
/**
 * 
 * @export
 * @interface OpenGateRequest
 */
export interface OpenGateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof OpenGateRequest
     */
    privacySeparatorEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OpenGateRequest
     */
    vxlanId?: number;
}
/**
 * 
 * @export
 * @interface OperatorMFAVerifyingResponse
 */
export interface OperatorMFAVerifyingResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof OperatorMFAVerifyingResponse
     */
    backupCodes?: Array<string>;
}
/**
 * 
 * @export
 * @interface OrderItemModel
 */
export interface OrderItemModel {
    /**
     * Product code
     * @type {string}
     * @memberof OrderItemModel
     */
    productCode?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderItemModel
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface OrderedSubscriber
 */
export interface OrderedSubscriber {
    /**
     * IMSI
     * @type {string}
     * @memberof OrderedSubscriber
     */
    imsi?: string;
    /**
     * MSISDN
     * @type {string}
     * @memberof OrderedSubscriber
     */
    msisdn?: string;
    /**
     * serialNumber
     * @type {string}
     * @memberof OrderedSubscriber
     */
    serialNumber?: string;
}
/**
 * 
 * @export
 * @interface PacketCaptureSession
 */
export interface PacketCaptureSession {
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    createdTime?: string;
    /**
     * 
     * @type {number}
     * @memberof PacketCaptureSession
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    endedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    failedReason?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    startedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    status?: PacketCaptureSessionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSession
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PacketCaptureSessionStatusEnum {
    Requested = 'REQUESTED',
    Accepted = 'ACCEPTED',
    Capturing = 'CAPTURING',
    PostProcessing = 'POST_PROCESSING',
    Done = 'DONE',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface PacketCaptureSessionRequest
 */
export interface PacketCaptureSessionRequest {
    /**
     * 
     * @type {number}
     * @memberof PacketCaptureSessionRequest
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof PacketCaptureSessionRequest
     */
    prefix?: string;
}
/**
 * 
 * @export
 * @interface PaymentAmount
 */
export interface PaymentAmount {
    /**
     * 
     * @type {number}
     * @memberof PaymentAmount
     */
    taxAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentAmount
     */
    totalAmount?: number;
}
/**
 * 
 * @export
 * @interface PaymentDescription
 */
export interface PaymentDescription {
    /**
     * 
     * @type {string}
     * @memberof PaymentDescription
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentDescription
     */
    itemList?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentStatementResponse
 */
export interface PaymentStatementResponse {
    /**
     * Amount
     * @type {number}
     * @memberof PaymentStatementResponse
     */
    amount?: number;
    /**
     * Payment date time
     * @type {number}
     * @memberof PaymentStatementResponse
     */
    paymentDateTime?: number;
    /**
     * Payment instrument
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentInstrument?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentMethod?: string;
    /**
     * Payment statement ID
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentStatementId?: string;
    /**
     * Payment statement information
     * @type {string}
     * @memberof PaymentStatementResponse
     */
    paymentStatementInfo?: string;
}
/**
 * 
 * @export
 * @interface Placement
 */
export interface Placement {
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    region?: string;
}
/**
 * 
 * @export
 * @interface PortMapping
 */
export interface PortMapping {
    /**
     * 
     * @type {PortMappingDestination}
     * @memberof PortMapping
     */
    destination?: PortMappingDestination;
    /**
     * The duration that remote access is enabled, in seconds.
     * @type {number}
     * @memberof PortMapping
     */
    duration?: number;
    /**
     * SORACOM Napter endpoint (IP address and port number) for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    endpoint?: string;
    /**
     * SORACOM Napter hostname for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    hostname?: string;
    /**
     * SORACOM Napter IP Address for remote access.
     * @type {string}
     * @memberof PortMapping
     */
    ipAddress?: string;
    /**
     * SORACOM Napter port number for remote access.
     * @type {number}
     * @memberof PortMapping
     */
    port?: number;
    /**
     * 
     * @type {PortMappingSource}
     * @memberof PortMapping
     */
    source?: PortMappingSource;
    /**
     * Indicates TLS is required.
     * @type {boolean}
     * @memberof PortMapping
     */
    tlsRequired?: boolean;
}
/**
 * 
 * @export
 * @interface PortMappingDestination
 */
export interface PortMappingDestination {
    /**
     * The target IMSI of the subscriber.
     * @type {string}
     * @memberof PortMappingDestination
     */
    imsi: string;
    /**
     * The port on your device used for access.
     * @type {number}
     * @memberof PortMappingDestination
     */
    port: number;
}
/**
 * 
 * @export
 * @interface PortMappingSource
 */
export interface PortMappingSource {
    /**
     * The range of IP addresses in CIDR notation which will be allowed to access the port mapping.
     * @type {Array<string>}
     * @memberof PortMappingSource
     */
    ipRanges?: Array<string>;
}
/**
 * 
 * @export
 * @interface PreviousSessionStatus
 */
export interface PreviousSessionStatus {
    /**
     * 
     * @type {Cell}
     * @memberof PreviousSessionStatus
     */
    cell?: Cell;
    /**
     * The time when the previous session was created.
     * @type {number}
     * @memberof PreviousSessionStatus
     */
    createdTime?: number;
    /**
     * Thetime when the previous session was deleted.
     * @type {number}
     * @memberof PreviousSessionStatus
     */
    deletedTime?: number;
    /**
     * Array of IP address of the DNS servers.
     * @type {Array<string>}
     * @memberof PreviousSessionStatus
     */
    dnsServers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    gatewayPrivateIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    imei?: string;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof PreviousSessionStatus
     */
    vpgId?: string;
}
/**
 * 
 * @export
 * @interface ProductModel
 */
export interface ProductModel {
    /**
     * Count
     * @type {number}
     * @memberof ProductModel
     */
    count?: number;
    /**
     * Max quantity
     * @type {number}
     * @memberof ProductModel
     */
    maxQuantity?: number;
    /**
     * Price
     * @type {number}
     * @memberof ProductModel
     */
    price?: number;
    /**
     * Product code
     * @type {string}
     * @memberof ProductModel
     */
    productCode?: string;
    /**
     * URL of product page
     * @type {string}
     * @memberof ProductModel
     */
    productInfoURL?: string;
    /**
     * Product name
     * @type {string}
     * @memberof ProductModel
     */
    productName?: string;
    /**
     * Product type
     * @type {string}
     * @memberof ProductModel
     */
    productType?: ProductModelProductTypeEnum;
    /**
     * Properties
     * @type {{ [key: string]: string; }}
     * @memberof ProductModel
     */
    properties?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum ProductModelProductTypeEnum {
    Sim = 'sim',
    NetworkModule = 'network_module'
}

/**
 * 
 * @export
 * @interface PutIpAddressMapEntryRequest
 */
export interface PutIpAddressMapEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof PutIpAddressMapEntryRequest
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof PutIpAddressMapEntryRequest
     */
    key: string;
}
/**
 * 
 * @export
 * @interface RegisterGatePeerRequest
 */
export interface RegisterGatePeerRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterGatePeerRequest
     */
    innerIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterGatePeerRequest
     */
    outerIpAddress: string;
}
/**
 * 
 * @export
 * @interface RegisterLoraDeviceRequest
 */
export interface RegisterLoraDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterLoraDeviceRequest
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterLoraDeviceRequest
     */
    registrationSecret?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RegisterLoraDeviceRequest
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RegisterOperatorsRequest
 */
export interface RegisterOperatorsRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterOperatorsRequest
     */
    email: string;
    /**
     * パスワードは以下の条件を満たしている必要があります：長さ 8 文字以上100 文字以内、アルファベット小文字 (a-z) を 1 文字以上使用、アルファベット大文字 (A-Z) を 1 文字以上使用、数字を 1 文字以上使用。記号なども使用できます。
     * @type {string}
     * @memberof RegisterOperatorsRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface RegisterPayerInformationModel
 */
export interface RegisterPayerInformationModel {
    /**
     * Company name
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    companyName?: string;
    /**
     * Department
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    department?: string;
    /**
     * Full name
     * @type {string}
     * @memberof RegisterPayerInformationModel
     */
    fullName?: string;
}
/**
 * 
 * @export
 * @interface RegisterSimRequest
 */
export interface RegisterSimRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterSimRequest
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSimRequest
     */
    registrationSecret: string;
    /**
     * 
     * @type {Array<TagUpdateRequest>}
     * @memberof RegisterSimRequest
     */
    tags?: Array<TagUpdateRequest>;
}
/**
 * 
 * @export
 * @interface RegisterSubscribersRequest
 */
export interface RegisterSubscribersRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterSubscribersRequest
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSubscribersRequest
     */
    registrationSecret: string;
    /**
     * 
     * @type {Array<TagUpdateRequest>}
     * @memberof RegisterSubscribersRequest
     */
    tags?: Array<TagUpdateRequest>;
}
/**
 * 
 * @export
 * @interface ResourceInstance
 */
export interface ResourceInstance {
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceInstance
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceInstance
     */
    mandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceInstance
     */
    multiple?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceInstance
     */
    observed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    operations?: ResourceInstanceOperationsEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    rangeEnumeration?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    type?: ResourceInstanceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceInstance
     */
    units?: string;
    /**
     * 
     * @type {object}
     * @memberof ResourceInstance
     */
    value?: object;
    /**
     * 
     * @type {object}
     * @memberof ResourceInstance
     */
    values?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceInstanceOperationsEnum {
    None = 'NONE',
    R = 'R',
    W = 'W',
    Rw = 'RW',
    E = 'E',
    Re = 'RE',
    We = 'WE',
    Rwe = 'RWE'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceInstanceTypeEnum {
    String = 'STRING',
    Integer = 'INTEGER',
    Float = 'FLOAT',
    Boolean = 'BOOLEAN',
    Opaque = 'OPAQUE',
    Time = 'TIME',
    Objlnk = 'OBJLNK'
}

/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * 
     * @type {number}
     * @memberof RoleResponse
     */
    createDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleResponse
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof RoleResponse
     */
    permission?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleResponse
     */
    roleId?: string;
    /**
     * 
     * @type {number}
     * @memberof RoleResponse
     */
    updateDateTime?: number;
}
/**
 * 
 * @export
 * @interface RoutingFilterEntry
 */
export interface RoutingFilterEntry {
    /**
     * Whether to allow or deny the outbound packets with a destination in the specified range
     * @type {string}
     * @memberof RoutingFilterEntry
     */
    action: RoutingFilterEntryActionEnum;
    /**
     * IPv4 address range in CIDR format, e.g. a.b.c.d/x
     * @type {string}
     * @memberof RoutingFilterEntry
     */
    ipRange: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RoutingFilterEntryActionEnum {
    Allow = 'allow',
    Deny = 'deny'
}

/**
 * 
 * @export
 * @interface RuleConfig
 */
export interface RuleConfig {
    /**
     * 
     * @type {RuleConfigProperty}
     * @memberof RuleConfig
     */
    properties: RuleConfigProperty;
    /**
     * 
     * @type {string}
     * @memberof RuleConfig
     */
    type: RuleConfigTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RuleConfigTypeEnum {
    SubscriberDailyTrafficRule = 'SubscriberDailyTrafficRule',
    SubscriberMonthlyTrafficRule = 'SubscriberMonthlyTrafficRule',
    SubscriberCumulativeTrafficRule = 'SubscriberCumulativeTrafficRule',
    SubscriberFirstTrafficRule = 'SubscriberFirstTrafficRule',
    DailyTotalTrafficRule = 'DailyTotalTrafficRule',
    MonthlyTotalTrafficRule = 'MonthlyTotalTrafficRule',
    SubscriberStatusAttributeRule = 'SubscriberStatusAttributeRule',
    SubscriberSpeedClassAttributeRule = 'SubscriberSpeedClassAttributeRule',
    SubscriberExpiredRule = 'SubscriberExpiredRule',
    SimDailyTotalTrafficRule = 'SimDailyTotalTrafficRule',
    SimMonthlyTotalTrafficRule = 'SimMonthlyTotalTrafficRule',
    SimCumulativeTotalTrafficRule = 'SimCumulativeTotalTrafficRule',
    SimStatusAttributeRule = 'SimStatusAttributeRule',
    SimSpeedClassAttributeRule = 'SimSpeedClassAttributeRule',
    SimExpiredRule = 'SimExpiredRule',
    SimSubscriptionStatusRule = 'SimSubscriptionStatusRule'
}

/**
 * 
 * @export
 * @interface RuleConfigProperty
 */
export interface RuleConfigProperty {
    /**
     * 
     * @type {string}
     * @memberof RuleConfigProperty
     */
    inactiveTimeoutDateConst?: RuleConfigPropertyInactiveTimeoutDateConstEnum;
    /**
     * 
     * @type {number}
     * @memberof RuleConfigProperty
     */
    inactiveTimeoutOffsetMinutes?: number;
    /**
     * 
     * @type {number}
     * @memberof RuleConfigProperty
     */
    limitTotalTrafficMegaByte: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleConfigProperty
     */
    runOnceAmongTarget?: boolean;
    /**
     * Only for SimSubscriptionStatusRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetOtaStatus?: RuleConfigPropertyTargetOtaStatusEnum;
    /**
     * Only for SubscriberSpeedClassAttributeRule, SimSpeedClassAttributeRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetSpeedClass?: RuleConfigPropertyTargetSpeedClassEnum;
    /**
     * Only for SubscriberStatusAttributeRule, SimStatusAttributeRule
     * @type {string}
     * @memberof RuleConfigProperty
     */
    targetStatus?: RuleConfigPropertyTargetStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RuleConfigPropertyInactiveTimeoutDateConstEnum {
    Immediately = 'IMMEDIATELY',
    BeginningOfNextMonth = 'BEGINNING_OF_NEXT_MONTH',
    BeginningOfNextDay = 'BEGINNING_OF_NEXT_DAY',
    AfterOneDay = 'AFTER_ONE_DAY',
    Never = 'NEVER'
}
/**
    * @export
    * @enum {string}
    */
export enum RuleConfigPropertyTargetOtaStatusEnum {
    Started = 'started',
    Finished = 'finished',
    Failed = 'failed'
}
/**
    * @export
    * @enum {string}
    */
export enum RuleConfigPropertyTargetSpeedClassEnum {
    Minimum = 's1.minimum',
    Slow = 's1.slow',
    Standard = 's1.standard',
    Fast = 's1.fast'
}
/**
    * @export
    * @enum {string}
    */
export enum RuleConfigPropertyTargetStatusEnum {
    Ready = 'ready',
    Active = 'active',
    Inactive = 'inactive',
    Suspended = 'suspended',
    Terminated = 'terminated'
}

/**
 * 
 * @export
 * @interface SessionEvent
 */
export interface SessionEvent {
    /**
     * The Access Point Name confirured.
     * @type {string}
     * @memberof SessionEvent
     */
    apn?: string;
    /**
     * First IP address of DNS servers.
     * @type {string}
     * @memberof SessionEvent
     */
    dns0?: string;
    /**
     * Second IP address of DNS servers.
     * @type {string}
     * @memberof SessionEvent
     */
    dns1?: string;
    /**
     * The type of behavior for the event. Possible values are \"Created\" indicates the device created a new session, \"Modified\" indicates that an existing connection was modified, \"Deleted\" indicates a network connection was closed.
     * @type {string}
     * @memberof SessionEvent
     */
    event?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionEvent
     */
    gatewayPrivateIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionEvent
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof SessionEvent
     */
    imei?: string;
    /**
     * The IMSI of the SIM.
     * @type {string}
     * @memberof SessionEvent
     */
    imsi?: string;
    /**
     * The operator ID of the session event.
     * @type {string}
     * @memberof SessionEvent
     */
    operatorId?: string;
    /**
     * The timestamp of the session event.
     * @type {number}
     * @memberof SessionEvent
     */
    time?: number;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof SessionEvent
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof SessionEvent
     */
    vpgId?: string;
}
/**
 * 
 * @export
 * @interface SessionStatus
 */
export interface SessionStatus {
    /**
     * 
     * @type {Cell}
     * @memberof SessionStatus
     */
    cell?: Cell;
    /**
     * Array of IP address of the DNS servers.
     * @type {Array<string>}
     * @memberof SessionStatus
     */
    dnsServers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SessionStatus
     */
    gatewayPrivateIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStatus
     */
    gatewayPublicIpAddress?: string;
    /**
     * The IMEI of the device using the SIM.
     * @type {string}
     * @memberof SessionStatus
     */
    imei?: string;
    /**
     * 
     * @type {number}
     * @memberof SessionStatus
     */
    lastUpdatedAt?: number;
    /**
     * Whether or not the SIM is online.
     * @type {boolean}
     * @memberof SessionStatus
     */
    online?: boolean;
    /**
     * The IP address of the device.
     * @type {string}
     * @memberof SessionStatus
     */
    ueIpAddress?: string;
    /**
     * The Virtual Private Gateway IP address configured.
     * @type {string}
     * @memberof SessionStatus
     */
    vpgId?: string;
}
/**
 * 
 * @export
 * @interface SetDeviceObjectModelScopeRequest
 */
export interface SetDeviceObjectModelScopeRequest {
    /**
     * 
     * @type {string}
     * @memberof SetDeviceObjectModelScopeRequest
     */
    scope?: string;
}
/**
 * 
 * @export
 * @interface SetGroupRequest
 */
export interface SetGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof SetGroupRequest
     */
    groupId?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof SetGroupRequest
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SetImeiLockRequest
 */
export interface SetImeiLockRequest {
    /**
     * 
     * @type {string}
     * @memberof SetImeiLockRequest
     */
    imei?: string;
}
/**
 * 
 * @export
 * @interface SetNetworkSetRequest
 */
export interface SetNetworkSetRequest {
    /**
     * 
     * @type {string}
     * @memberof SetNetworkSetRequest
     */
    networkSetId?: string;
}
/**
 * 
 * @export
 * @interface SetSystemNotificationsRequest
 */
export interface SetSystemNotificationsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof SetSystemNotificationsRequest
     */
    emailIdList: Array<string>;
    /**
     * Password of the operator. This is necessary when type is primary.
     * @type {string}
     * @memberof SetSystemNotificationsRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface SetUserPermissionRequest
 */
export interface SetUserPermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof SetUserPermissionRequest
     */
    description?: string;
    /**
     * PermissionのJSON
     * @type {string}
     * @memberof SetUserPermissionRequest
     */
    permission: string;
}
/**
 * 
 * @export
 * @interface ShippingAddressModel
 */
export interface ShippingAddressModel {
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    building?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingAddressModel
     */
    zipCode: string;
}
/**
 * Shipping cost
 * @export
 * @interface ShippingCostModel
 */
export interface ShippingCostModel {
    /**
     * (Japan coverage only) Shipping area
     * @type {string}
     * @memberof ShippingCostModel
     */
    shippingArea?: ShippingCostModelShippingAreaEnum;
    /**
     * Shipping Area name
     * @type {string}
     * @memberof ShippingCostModel
     */
    shippingAreaName?: string;
    /**
     * Shipping Cost
     * @type {number}
     * @memberof ShippingCostModel
     */
    shippingCost?: number;
    /**
     * Size
     * @type {number}
     * @memberof ShippingCostModel
     */
    size?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ShippingCostModelShippingAreaEnum {
    Hokkaido = 'hokkaido',
    KitaTohoku = 'kita_tohoku',
    MinamiTohoku = 'minami_tohoku',
    Kanto = 'kanto',
    Shinetsu = 'shinetsu',
    Chubu = 'chubu',
    Hokuriku = 'hokuriku',
    Kansai = 'kansai',
    Chugoku = 'chugoku',
    Shikoku = 'shikoku',
    Kyushu = 'kyushu',
    Okinawa = 'okinawa'
}

/**
 * 
 * @export
 * @interface SigfoxData
 */
export interface SigfoxData {
    /**
     * 
     * @type {string}
     * @memberof SigfoxData
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface SigfoxDevice
 */
export interface SigfoxDevice {
    /**
     * 
     * @type {string}
     * @memberof SigfoxDevice
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof SigfoxDevice
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof SigfoxDevice
     */
    lastModifiedTime?: string;
    /**
     * 
     * @type {LastSeen}
     * @memberof SigfoxDevice
     */
    lastSeen?: LastSeen;
    /**
     * 
     * @type {string}
     * @memberof SigfoxDevice
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof SigfoxDevice
     */
    status?: SigfoxDeviceStatusEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SigfoxDevice
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof SigfoxDevice
     */
    terminationEnabled?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum SigfoxDeviceStatusEnum {
    Active = 'active',
    Ready = 'ready',
    Terminated = 'terminated',
    Instock = 'instock'
}

/**
 * 
 * @export
 * @interface SigfoxRegistrationRequest
 */
export interface SigfoxRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof SigfoxRegistrationRequest
     */
    registrationSecret?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SigfoxRegistrationRequest
     */
    tags?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Sim
 */
export interface Sim {
    /**
     * 
     * @type {number}
     * @memberof Sim
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    groupId?: string;
    /**
     * 
     * @type {number}
     * @memberof Sim
     */
    lastModifiedTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    otaSerialNumber?: string;
    /**
     * 
     * @type {{ [key: string]: SimProfile; }}
     * @memberof Sim
     */
    profiles?: { [key: string]: SimProfile; };
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    simId?: string;
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    speedClass?: string;
    /**
     * 
     * @type {string}
     * @memberof Sim
     */
    type?: SimTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SimTypeEnum {
    Uicc = 'uicc',
    Euicc = 'euicc'
}

/**
 * 
 * @export
 * @interface SimProfile
 */
export interface SimProfile {
    /**
     * 
     * @type {string}
     * @memberof SimProfile
     */
    iccid?: string;
    /**
     * 
     * @type {{ [key: string]: Subscriber; }}
     * @memberof SimProfile
     */
    subscribers?: { [key: string]: Subscriber; };
}
/**
 * 
 * @export
 * @interface SmsForwardingReport
 */
export interface SmsForwardingReport {
    /**
     * 
     * @type {string}
     * @memberof SmsForwardingReport
     */
    messageId?: string;
}
/**
 * 
 * @export
 * @interface SmsForwardingRequest
 */
export interface SmsForwardingRequest {
    /**
     * Encoding type of the message body. `1` indicates the body is `DCS_7BIT` that only supports single byte characters. `2` is `DCS_UCS2` that supports multi-byte text. When omitted, it is treated as `2` (`DCS_UCS2`).
     * @type {number}
     * @memberof SmsForwardingRequest
     */
    encodingType?: number;
    /**
     * 
     * @type {string}
     * @memberof SmsForwardingRequest
     */
    payload?: string;
}
/**
 * 
 * @export
 * @interface SoracomBeamStats
 */
export interface SoracomBeamStats {
    /**
     * 
     * @type {number}
     * @memberof SoracomBeamStats
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface Soralet
 */
export interface Soralet {
    /**
     * 
     * @type {number}
     * @memberof Soralet
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Soralet
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Soralet
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Soralet
     */
    soraletId?: string;
    /**
     * 
     * @type {number}
     * @memberof Soralet
     */
    updatedTime?: number;
}
/**
 * 
 * @export
 * @interface SoraletDataSource
 */
export interface SoraletDataSource {
    /**
     * 
     * @type {string}
     * @memberof SoraletDataSource
     */
    resourceId: string;
    /**
     * 
     * @type {string}
     * @memberof SoraletDataSource
     */
    resourceType: string;
}
/**
 * 
 * @export
 * @interface SoraletLog
 */
export interface SoraletLog {
    /**
     * 
     * @type {number}
     * @memberof SoraletLog
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof SoraletLog
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SoraletLog
     */
    operatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof SoraletLog
     */
    soraletId?: string;
    /**
     * 
     * @type {number}
     * @memberof SoraletLog
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface SoraletVersion
 */
export interface SoraletVersion {
    /**
     * 
     * @type {number}
     * @memberof SoraletVersion
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof SoraletVersion
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof SoraletVersion
     */
    operatorId?: string;
    /**
     * 
     * @type {number}
     * @memberof SoraletVersion
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof SoraletVersion
     */
    soraletId?: string;
    /**
     * 
     * @type {string}
     * @memberof SoraletVersion
     */
    srn?: string;
    /**
     * 
     * @type {number}
     * @memberof SoraletVersion
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface Subscriber
 */
export interface Subscriber {
    /**
     * The Access Point Name confirured.
     * @type {string}
     * @memberof Subscriber
     */
    apn?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Subscriber
     */
    bundles?: Array<string>;
    /**
     * The timestamp that the SIM was created.
     * @type {number}
     * @memberof Subscriber
     */
    createdAt?: number;
    /**
     * The timestamp of a date and time where the SIM was expired.
     * @type {number}
     * @memberof Subscriber
     */
    expiredAt?: number;
    /**
     * The timestamp of a date and time where the SIM was expired.
     * @type {number}
     * @memberof Subscriber
     */
    expiredTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    expiryAction?: SubscriberExpiryActionEnum;
    /**
     * The SIM group ID where the SIM belongs to.
     * @type {string}
     * @memberof Subscriber
     */
    groupId?: string;
    /**
     * The ICCID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    iccid?: string;
    /**
     * 
     * @type {ImeiLock}
     * @memberof Subscriber
     */
    imeiLock?: ImeiLock;
    /**
     * The IMSI of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    imsi?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    ipAddress?: string;
    /**
     * The timestamp when the SIM information was modified.
     * @type {number}
     * @memberof Subscriber
     */
    lastModifiedAt?: number;
    /**
     * The timestamp (in Unix milliseconds) of the last instance where the Napter On-Demand Remote Access service was used with the subscriber. If Napter has never been used with the subscriber, null is returned.
     * @type {number}
     * @memberof Subscriber
     */
    lastPortMappingCreatedTime?: number;
    /**
     * The form factor of the physical SIM. Possible values are \"mini\" for 2FF SIM card, \"micro\" for 3FF SIM card, \"nano\" for 4FF SIM card, \"trio\" for a Universal 3-in-1 (2FF/3FF/4FF) SIM card, or \"embedded\" for MFF2 or Embedded SIM (eSIM).
     * @type {string}
     * @memberof Subscriber
     */
    moduleType?: string;
    /**
     * The MSISDN of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    msisdn?: string;
    /**
     * The Operator ID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    operatorId?: string;
    /**
     * Whether or not the subscription supports SMS functionality. 0 = SMS not supported; 1 = SMS supported.
     * @type {number}
     * @memberof Subscriber
     */
    plan?: number;
    /**
     * 
     * @type {PreviousSessionStatus}
     * @memberof Subscriber
     */
    previousSession?: PreviousSessionStatus;
    /**
     * The timestamp (in Unix milliseconds) that the subscriber was manually registered to your account. When purchasing SIMs directly through the User Console, SIMs will automatically be registered to your account, and null is returned.
     * @type {number}
     * @memberof Subscriber
     */
    registeredTime?: number;
    /**
     * The serial number of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    serialNumber?: string;
    /**
     * 
     * @type {SessionStatus}
     * @memberof Subscriber
     */
    sessionStatus?: SessionStatus;
    /**
     * The SIM ID of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    simId?: string;
    /**
     * The speed class of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    speedClass?: string;
    /**
     * The subscription status of the subscriber. Possible values are \"ready\", \"active\", \"inactive\", \"standby\", \"suspended\", or \"terminated\".
     * @type {string}
     * @memberof Subscriber
     */
    status?: string;
    /**
     * The name of the subscription for the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    subscription?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof Subscriber
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof Subscriber
     */
    terminationEnabled?: boolean;
    /**
     * The speed class of the SIM.
     * @type {string}
     * @memberof Subscriber
     */
    type?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SubscriberExpiryActionEnum {
    DoNothing = 'doNothing',
    DeleteSession = 'deleteSession',
    Deactivate = 'deactivate',
    Suspend = 'suspend',
    Terminate = 'terminate'
}

/**
 * 
 * @export
 * @interface SubscriptionContainer
 */
export interface SubscriptionContainer {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionContainer
     */
    containerId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionContainer
     */
    downloaded?: boolean;
    /**
     * 
     * @type {{ [key: string]: Subscriber; }}
     * @memberof SubscriptionContainer
     */
    subscriber?: { [key: string]: Subscriber; };
}
/**
 * 
 * @export
 * @interface SubscriptionContainerStatus
 */
export interface SubscriptionContainerStatus {
    /**
     * 
     * @type {Array<SubscriptionContainer>}
     * @memberof SubscriptionContainerStatus
     */
    containers?: Array<SubscriptionContainer>;
    /**
     * 
     * @type {{ [key: string]: SubscriptionContainerStatusCountryMapping; }}
     * @memberof SubscriptionContainerStatus
     */
    countryMapping?: { [key: string]: SubscriptionContainerStatusCountryMapping; };
}
/**
 * 
 * @export
 * @interface SubscriptionContainerStatusCountryMapping
 */
export interface SubscriptionContainerStatusCountryMapping {
    /**
     * 
     * @type {SubscriptionContainerStatusMappingRecord}
     * @memberof SubscriptionContainerStatusCountryMapping
     */
    mappingRecord?: SubscriptionContainerStatusMappingRecord;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionContainerStatusCountryMapping
     */
    plmnCode?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionContainerStatusMappingRecord
 */
export interface SubscriptionContainerStatusMappingRecord {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionContainerStatusMappingRecord
     */
    containerId?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionContainerStatusMappingRecord
     */
    subscription?: string;
}
/**
 * 
 * @export
 * @interface SupportTokenResponse
 */
export interface SupportTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof SupportTokenResponse
     */
    token: string;
}
/**
 * 
 * @export
 * @interface SystemNotificationsModel
 */
export interface SystemNotificationsModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemNotificationsModel
     */
    emailIdList?: Array<string>;
    /**
     * primary / recovery / billing
     * @type {string}
     * @memberof SystemNotificationsModel
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemNotificationsModel
     */
    updateDateTime?: number;
}
/**
 * 
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    tagName: string;
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    tagValue: string;
}
/**
 * 
 * @export
 * @interface TrafficVolumeRanking
 */
export interface TrafficVolumeRanking {
    /**
     * 
     * @type {string}
     * @memberof TrafficVolumeRanking
     */
    imsi?: string;
    /**
     * 
     * @type {number}
     * @memberof TrafficVolumeRanking
     */
    trafficVolume?: number;
}
/**
 * 
 * @export
 * @interface UpdateDefaultPermissionsRequest
 */
export interface UpdateDefaultPermissionsRequest {
    /**
     * JSON string of permissions
     * @type {string}
     * @memberof UpdateDefaultPermissionsRequest
     */
    permissions: string;
}
/**
 * 
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    currentPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface UpdatePermissionRequest
 */
export interface UpdatePermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    operatorId?: string;
}
/**
 * 
 * @export
 * @interface UpdateSpeedClassRequest
 */
export interface UpdateSpeedClassRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSpeedClassRequest
     */
    speedClass: UpdateSpeedClassRequestSpeedClassEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateSpeedClassRequestSpeedClassEnum {
    Minimum = 's1.minimum',
    Slow = 's1.slow',
    Standard = 's1.standard',
    Fast = 's1.fast'
}

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface UserDetailResponse
 */
export interface UserDetailResponse {
    /**
     * 
     * @type {Array<AuthKeyResponse>}
     * @memberof UserDetailResponse
     */
    authKeyList?: Array<AuthKeyResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserDetailResponse
     */
    createDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailResponse
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailResponse
     */
    hasPassword?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetailResponse
     */
    permission?: string;
    /**
     * 
     * @type {Array<ListRolesResponse>}
     * @memberof UserDetailResponse
     */
    roleList?: Array<ListRolesResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserDetailResponse
     */
    updateDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailResponse
     */
    userName?: string;
}
/**
 * 
 * @export
 * @interface VerifyAddEmailTokenRequest
 */
export interface VerifyAddEmailTokenRequest {
    /**
     * Token sent by email
     * @type {string}
     * @memberof VerifyAddEmailTokenRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface VerifyEmailChangeTokenRequest
 */
export interface VerifyEmailChangeTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailChangeTokenRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface VerifyOperatorsRequest
 */
export interface VerifyOperatorsRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyOperatorsRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface VerifyPasswordResetTokenRequest
 */
export interface VerifyPasswordResetTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyPasswordResetTokenRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyPasswordResetTokenRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface VerifySubscriberTransferTokenRequest
 */
export interface VerifySubscriberTransferTokenRequest {
    /**
     * トークン
     * @type {string}
     * @memberof VerifySubscriberTransferTokenRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface VerifySubscriberTransferTokenResponse
 */
export interface VerifySubscriberTransferTokenResponse {
    /**
     * 移管されたIMSIリスト
     * @type {Array<string>}
     * @memberof VerifySubscriberTransferTokenResponse
     */
    transferredImsi: Array<string>;
}
/**
 * 
 * @export
 * @interface VirtualPrivateGateway
 */
export interface VirtualPrivateGateway {
    /**
     * 
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    lastModifiedTime?: number;
    /**
     * 
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    operatorId?: string;
    /**
     * 
     * @type {Placement}
     * @memberof VirtualPrivateGateway
     */
    placement?: Placement;
    /**
     * 
     * @type {string}
     * @memberof VirtualPrivateGateway
     */
    status?: string;
    /**
     * An object which always contains at least one property \"name\" with a string value. If you give a subscriber/SIM a name, the name will be returned as the value of the \"name\" property. If the subscriber/SIM does not have a name, an empty string \"\" is returned. In addition, if you create any custom tags for the subscriber/SIM, each custom tag will appear as additional properties in the object.
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof VirtualPrivateGateway
     */
    type?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VirtualPrivateGateway
     */
    useInternetGateway?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    virtualInterfaces?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VirtualPrivateGateway
     */
    vpcPeeringConnections?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface VolumeDiscountModel
 */
export interface VolumeDiscountModel {
    /**
     * Contract months
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    contractTermMonth?: number;
    /**
     * End date
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    endDate?: string;
    /**
     * Initial cost
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    initialCost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    quantity?: number;
    /**
     * Start date
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    startDate?: string;
    /**
     * Unit price
     * @type {number}
     * @memberof VolumeDiscountModel
     */
    unitPrice?: number;
    /**
     * Payment type
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    volumeDiscountPaymentType?: VolumeDiscountModelVolumeDiscountPaymentTypeEnum;
    /**
     * Long term discount type
     * @type {string}
     * @memberof VolumeDiscountModel
     */
    volumeDiscountType?: VolumeDiscountModelVolumeDiscountTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum VolumeDiscountModelVolumeDiscountPaymentTypeEnum {
    Monthly = 'MONTHLY',
    Prepayment = 'PREPAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum VolumeDiscountModelVolumeDiscountTypeEnum {
    BasicChargeV2 = 'SORACOM_AIR_BASIC_CHARGE_V2',
    BasicCharge = 'SORACOM_AIR_BASIC_CHARGE',
    MonthlyFixedBasicCharge = 'SORACOM_AIR_MONTHLY_FIXED_BASIC_CHARGE'
}

/**
 * 
 * @export
 * @interface VpcPeeringConnection
 */
export interface VpcPeeringConnection {
    /**
     * 
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    destinationCidrBlock?: string;
    /**
     * 
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    peerOwnerId?: string;
    /**
     * 
     * @type {string}
     * @memberof VpcPeeringConnection
     */
    peerVpcId?: string;
}

/**
 * AuditLogApi - axios parameter creator
 * @export
 */
export const AuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve audit logs for API calls.
         * @summary Retrieve audit logs for API calls
         * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
         * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
         * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiAuditLogs: async (apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/audit_logs/api`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (apiKind !== undefined) {
                localVarQueryParameter['api_kind'] = apiKind;
            }

            if (fromEpochMs !== undefined) {
                localVarQueryParameter['from_epoch_ms'] = fromEpochMs;
            }

            if (toEpochMs !== undefined) {
                localVarQueryParameter['to_epoch_ms'] = toEpochMs;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve audit logs for Napter.
         * @summary Retrieve audit logs for Napter
         * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {number} [from] Start time for the log search range (unixtime milliseconds).
         * @param {number} [to] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNapterAuditLogs: async (resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/audit_logs/napter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resource_id'] = resourceId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogApi - functional programming interface
 * @export
 */
export const AuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve audit logs for API calls.
         * @summary Retrieve audit logs for API calls
         * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
         * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
         * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIAuditLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiAuditLogs(apiKind, fromEpochMs, toEpochMs, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve audit logs for Napter.
         * @summary Retrieve audit logs for Napter
         * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {number} [from] Start time for the log search range (unixtime milliseconds).
         * @param {number} [to] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NapterAuditLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNapterAuditLogs(resourceType, resourceId, from, to, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditLogApi - factory interface
 * @export
 */
export const AuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogApiFp(configuration)
    return {
        /**
         * Retrieve audit logs for API calls.
         * @summary Retrieve audit logs for API calls
         * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
         * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
         * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<APIAuditLogEntry>> {
            return localVarFp.getApiAuditLogs(apiKind, fromEpochMs, toEpochMs, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve audit logs for Napter.
         * @summary Retrieve audit logs for Napter
         * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {number} [from] Start time for the log search range (unixtime milliseconds).
         * @param {number} [to] End time for the log search range (unixtime milliseconds).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<NapterAuditLogEntry>> {
            return localVarFp.getNapterAuditLogs(resourceType, resourceId, from, to, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogApi - interface
 * @export
 * @interface AuditLogApi
 */
export interface AuditLogApiInterface {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApiInterface
     */
    getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<APIAuditLogEntry>>;

    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApiInterface
     */
    getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<NapterAuditLogEntry>>;

}

/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export class AuditLogApi extends BaseAPI implements AuditLogApiInterface {
    /**
     * Retrieve audit logs for API calls.
     * @summary Retrieve audit logs for API calls
     * @param {string} [apiKind] Filter item for audit log retrieval by API kind (e.g. &#x60;/v1/auth&#x60;).
     * @param {number} [fromEpochMs] Start time for the log search range (unixtime milliseconds).
     * @param {number} [toEpochMs] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;requestedTimeEpochMs&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getApiAuditLogs(apiKind?: string, fromEpochMs?: number, toEpochMs?: number, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return AuditLogApiFp(this.configuration).getApiAuditLogs(apiKind, fromEpochMs, toEpochMs, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve audit logs for Napter.
     * @summary Retrieve audit logs for Napter
     * @param {'Subscriber'} [resourceType] Type of the target resource to query Napter audit log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {number} [from] Start time for the log search range (unixtime milliseconds).
     * @param {number} [to] End time for the log search range (unixtime milliseconds).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getNapterAuditLogs(resourceType?: 'Subscriber', resourceId?: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return AuditLogApiFp(this.configuration).getNapterAuditLogs(resourceType, resourceId, from, to, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
         * @summary Performs authentication to access to the SORACOM API.
         * @param {AuthRequest} auth Authentication request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auth: async (auth: AuthRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'auth' is not null or undefined
            assertParamExists('auth', 'auth', auth)
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(auth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
         * @summary Issues a password reset token for the operator.
         * @param {IssuePasswordResetTokenRequest} email email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePasswordResetToken: async (email: IssuePasswordResetTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('issuePasswordResetToken', 'email', email)
            const localVarPath = `/auth/password_reset_token/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(email, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the operator\'s password if the password reset token is verified.
         * @summary Verifies the password reset token and updates password.
         * @param {VerifyPasswordResetTokenRequest} request token, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPasswordResetToken: async (request: VerifyPasswordResetTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verifyPasswordResetToken', 'request', request)
            const localVarPath = `/auth/password_reset_token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
         * @summary Performs authentication to access to the SORACOM API.
         * @param {AuthRequest} auth Authentication request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auth(auth: AuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auth(auth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
         * @summary Issues a password reset token for the operator.
         * @param {IssuePasswordResetTokenRequest} email email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePasswordResetToken(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the operator\'s password if the password reset token is verified.
         * @summary Verifies the password reset token and updates password.
         * @param {VerifyPasswordResetTokenRequest} request token, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyPasswordResetToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
         * @summary Performs authentication to access to the SORACOM API.
         * @param {AuthRequest} auth Authentication request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auth(auth: AuthRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.auth(auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
         * @summary Issues a password reset token for the operator.
         * @param {IssuePasswordResetTokenRequest} email email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.issuePasswordResetToken(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the operator\'s password if the password reset token is verified.
         * @summary Verifies the password reset token and updates password.
         * @param {VerifyPasswordResetTokenRequest} request token, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyPasswordResetToken(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    auth(auth: AuthRequest, options?: any): AxiosPromise<AuthResponse>;

    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any): AxiosPromise<void>;

    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any): AxiosPromise<void>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Performs authentication to access to the SORACOM API. To perform authentication by a root account, specify `email` and `password`. To perform authentication by an AuthKey, specify `authKeyId` and `authKey`. To perform authentication by a SAM user, specify `operatorId`, `userName` and `password`. An API Key and an API Token will be included in the response if successful. Specify the API Key and the API Token to requests afterwards
     * @summary Performs authentication to access to the SORACOM API.
     * @param {AuthRequest} auth Authentication request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public auth(auth: AuthRequest, options?: any) {
        return AuthApiFp(this.configuration).auth(auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a password reset token and send it to the operator\'s mail address. After receiving the password reset token, call /v1/auth/password_reset_token/verify API with the token to update operator\'s password.
     * @summary Issues a password reset token for the operator.
     * @param {IssuePasswordResetTokenRequest} email email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public issuePasswordResetToken(email: IssuePasswordResetTokenRequest, options?: any) {
        return AuthApiFp(this.configuration).issuePasswordResetToken(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the operator\'s password if the password reset token is verified.
     * @summary Verifies the password reset token and updates password.
     * @param {VerifyPasswordResetTokenRequest} request token, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyPasswordResetToken(request: VerifyPasswordResetTokenRequest, options?: any) {
        return AuthApiFp(this.configuration).verifyPasswordResetToken(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
         * @summary Output billing CSV file to S3.
         * @param {string} yyyyMM yyyyMM
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBilling: async (yyyyMM: string, exportMode?: 'async' | 'sync', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'yyyyMM' is not null or undefined
            assertParamExists('exportBilling', 'yyyyMM', yyyyMM)
            const localVarPath = `/bills/{yyyyMM}/export`
                .replace(`{${"yyyyMM"}}`, encodeURIComponent(String(yyyyMM)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (exportMode !== undefined) {
                localVarQueryParameter['export_mode'] = exportMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Export latest billing CSV file to S3.
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportLatestBilling: async (exportMode?: 'async' | 'sync', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bills/latest/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (exportMode !== undefined) {
                localVarQueryParameter['export_mode'] = exportMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get bill.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBilling: async (yyyyMM: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'yyyyMM' is not null or undefined
            assertParamExists('getBilling', 'yyyyMM', yyyyMM)
            const localVarPath = `/bills/{yyyyMM}`
                .replace(`{${"yyyyMM"}}`, encodeURIComponent(String(yyyyMM)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
         * @summary Get billing history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingHistory: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
         * @summary Get bill per day.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPerDay: async (yyyyMM: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'yyyyMM' is not null or undefined
            assertParamExists('getBillingPerDay', 'yyyyMM', yyyyMM)
            const localVarPath = `/bills/{yyyyMM}/daily`
                .replace(`{${"yyyyMM"}}`, encodeURIComponent(String(yyyyMM)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get latest bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBilling: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bills/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
         * @summary Output billing CSV file to S3.
         * @param {string} yyyyMM yyyyMM
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportBilling(yyyyMM, exportMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Export latest billing CSV file to S3.
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportLatestBilling(exportMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get bill.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBilling(yyyyMM: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBilling(yyyyMM, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
         * @summary Get billing history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBillingHistory(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBillingHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBillingHistory(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
         * @summary Get bill per day.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBillingPerDay(yyyyMM: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DailyBillResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBillingPerDay(yyyyMM, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get latest bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBilling(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLatestBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBilling(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
         * @summary Output billing CSV file to S3.
         * @param {string} yyyyMM yyyyMM
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse> {
            return localVarFp.exportBilling(yyyyMM, exportMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Export latest billing CSV file to S3.
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse> {
            return localVarFp.exportLatestBilling(exportMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get bill.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBilling(yyyyMM: string, options?: any): AxiosPromise<MonthlyBill> {
            return localVarFp.getBilling(yyyyMM, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
         * @summary Get billing history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingHistory(options?: any): AxiosPromise<GetBillingHistoryResponse> {
            return localVarFp.getBillingHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
         * @summary Get bill per day.
         * @param {string} yyyyMM year and month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPerDay(yyyyMM: string, options?: any): AxiosPromise<DailyBillResponse> {
            return localVarFp.getBillingPerDay(yyyyMM, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
         * @summary Get latest bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBilling(options?: any): AxiosPromise<GetLatestBill> {
            return localVarFp.getLatestBilling(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - interface
 * @export
 * @interface BillingApi
 */
export interface BillingApiInterface {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;

    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    exportLatestBilling(exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;

    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBilling(yyyyMM: string, options?: any): AxiosPromise<MonthlyBill>;

    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBillingHistory(options?: any): AxiosPromise<GetBillingHistoryResponse>;

    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getBillingPerDay(yyyyMM: string, options?: any): AxiosPromise<DailyBillResponse>;

    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getLatestBilling(options?: any): AxiosPromise<GetLatestBill>;

}

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI implements BillingApiInterface {
    /**
     * Returns detailed information for the billing amounts for the specified month. This detailed information includes billing amounts per day, subscriber, and billing item.
     * @summary Output billing CSV file to S3.
     * @param {string} yyyyMM yyyyMM
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public exportBilling(yyyyMM: string, exportMode?: 'async' | 'sync', options?: any) {
        return BillingApiFp(this.configuration).exportBilling(yyyyMM, exportMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns detailed information of the billing amounts for the latest month. This detailed information includes billing amounts per day, subscriber, and billing item. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Export latest billing CSV file to S3.
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public exportLatestBilling(exportMode?: 'async' | 'sync', options?: any) {
        return BillingApiFp(this.configuration).exportLatestBilling(exportMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the billing history for the specified month (after applied discounts such as free tiers, etc., inclusive of tax). The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get bill.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getBilling(yyyyMM: string, options?: any) {
        return BillingApiFp(this.configuration).getBilling(yyyyMM, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns past billing history (after applied discounts such as free tiers, etc., inclusive of tax). This API only returns the billing amounts that have been finalized at the end of the month.
     * @summary Get billing history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getBillingHistory(options?: any) {
        return BillingApiFp(this.configuration).getBillingHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns detailed information of billing amounts per day for the specified month. This API only returns the billing amounts that have been finalized.
     * @summary Get bill per day.
     * @param {string} yyyyMM year and month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getBillingPerDay(yyyyMM: string, options?: any) {
        return BillingApiFp(this.configuration).getBillingPerDay(yyyyMM, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest billing amounts after applied discounts such as free tiers, etc. The amounts retrieved using this API correspond to the values before the invoice was finalized.
     * @summary Get latest bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getLatestBilling(options?: any) {
        return BillingApiFp(this.configuration).getLatestBilling(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellLocationApi - axios parameter creator
 * @export
 */
export const CellLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
         * @summary List location information for multiple cell towers.
         * @param {Array<CellIdentifier>} body List of cell identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetCellLocations: async (body: Array<CellIdentifier>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchGetCellLocations', 'body', body)
            const localVarPath = `/cell_locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
         * @summary Get location information for a cell tower.
         * @param {string} mcc MCC - Mobile Country Code
         * @param {string} mnc MNC - Mobile Network Code
         * @param {string} [lac] LAC - Location Area Code (for 3G)
         * @param {string} [cid] CID - Cell ID (for 3G)
         * @param {string} [tac] TAC - Tracking Area Code (for 4G)
         * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCellLocation: async (mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcc' is not null or undefined
            assertParamExists('getCellLocation', 'mcc', mcc)
            // verify required parameter 'mnc' is not null or undefined
            assertParamExists('getCellLocation', 'mnc', mnc)
            const localVarPath = `/cell_locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (mcc !== undefined) {
                localVarQueryParameter['mcc'] = mcc;
            }

            if (mnc !== undefined) {
                localVarQueryParameter['mnc'] = mnc;
            }

            if (lac !== undefined) {
                localVarQueryParameter['lac'] = lac;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }

            if (tac !== undefined) {
                localVarQueryParameter['tac'] = tac;
            }

            if (ecid !== undefined) {
                localVarQueryParameter['ecid'] = ecid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellLocationApi - functional programming interface
 * @export
 */
export const CellLocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellLocationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
         * @summary List location information for multiple cell towers.
         * @param {Array<CellIdentifier>} body List of cell identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchGetCellLocations(body: Array<CellIdentifier>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CellLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchGetCellLocations(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
         * @summary Get location information for a cell tower.
         * @param {string} mcc MCC - Mobile Country Code
         * @param {string} mnc MNC - Mobile Network Code
         * @param {string} [lac] LAC - Location Area Code (for 3G)
         * @param {string} [cid] CID - Cell ID (for 3G)
         * @param {string} [tac] TAC - Tracking Area Code (for 4G)
         * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCellLocation(mcc, mnc, lac, cid, tac, ecid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellLocationApi - factory interface
 * @export
 */
export const CellLocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellLocationApiFp(configuration)
    return {
        /**
         * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
         * @summary List location information for multiple cell towers.
         * @param {Array<CellIdentifier>} body List of cell identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetCellLocations(body: Array<CellIdentifier>, options?: any): AxiosPromise<Array<CellLocation>> {
            return localVarFp.batchGetCellLocations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
         * @summary Get location information for a cell tower.
         * @param {string} mcc MCC - Mobile Country Code
         * @param {string} mnc MNC - Mobile Network Code
         * @param {string} [lac] LAC - Location Area Code (for 3G)
         * @param {string} [cid] CID - Cell ID (for 3G)
         * @param {string} [tac] TAC - Tracking Area Code (for 4G)
         * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): AxiosPromise<CellLocation> {
            return localVarFp.getCellLocation(mcc, mnc, lac, cid, tac, ecid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellLocationApi - interface
 * @export
 * @interface CellLocationApi
 */
export interface CellLocationApiInterface {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApiInterface
     */
    batchGetCellLocations(body: Array<CellIdentifier>, options?: any): AxiosPromise<Array<CellLocation>>;

    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApiInterface
     */
    getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any): AxiosPromise<CellLocation>;

}

/**
 * CellLocationApi - object-oriented interface
 * @export
 * @class CellLocationApi
 * @extends {BaseAPI}
 */
export class CellLocationApi extends BaseAPI implements CellLocationApiInterface {
    /**
     * Retrieves a list of location information (latitude / longitude) for multiple cell towers which are identified by Cell IDs etc.
     * @summary List location information for multiple cell towers.
     * @param {Array<CellIdentifier>} body List of cell identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApi
     */
    public batchGetCellLocations(body: Array<CellIdentifier>, options?: any) {
        return CellLocationApiFp(this.configuration).batchGetCellLocations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves location information (latitude / longitude) for a cell tower which is identified by Cell ID etc. Please specify MCC, MNC, LAC and CID when the access radio technology is 3G. It is possible to retrieve location information without CID, but the location information will be low accuracy. For LTE (4G), please specify MCC, MNC, TAC and ECID. As it is based on an open database to convert cell information into location information, the location information does not exist or might be incorrect.
     * @summary Get location information for a cell tower.
     * @param {string} mcc MCC - Mobile Country Code
     * @param {string} mnc MNC - Mobile Network Code
     * @param {string} [lac] LAC - Location Area Code (for 3G)
     * @param {string} [cid] CID - Cell ID (for 3G)
     * @param {string} [tac] TAC - Tracking Area Code (for 4G)
     * @param {string} [ecid] ECID - Enhanced Cell ID (for 4G)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellLocationApi
     */
    public getCellLocation(mcc: string, mnc: string, lac?: string, cid?: string, tac?: string, ecid?: string, options?: any) {
        return CellLocationApiFp(this.configuration).getCellLocation(mcc, mnc, lac, cid, tac, ecid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialApi - axios parameter creator
 * @export
 */
export const CredentialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new credential.
         * @summary Create a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('createCredential', 'credentialsId', credentialsId)
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('createCredential', 'credentials', credentials)
            const localVarPath = `/credentials/{credentials_id}`
                .replace(`{${"credentials_id"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a credential.
         * @summary Delete a credential.
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (credentialsId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteCredential', 'credentialsId', credentialsId)
            const localVarPath = `/credentials/{credentials_id}`
                .replace(`{${"credentials_id"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of credentials.
         * @summary List of credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a credential.
         * @summary Update a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('updateCredential', 'credentialsId', credentialsId)
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('updateCredential', 'credentials', credentials)
            const localVarPath = `/credentials/{credentials_id}`
                .replace(`{${"credentials_id"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialApi - functional programming interface
 * @export
 */
export const CredentialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new credential.
         * @summary Create a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(credentialsId, credentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a credential.
         * @summary Delete a credential.
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(credentialsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of credentials.
         * @summary List of credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CredentialsModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a credential.
         * @summary Update a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(credentialsId, credentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialApi - factory interface
 * @export
 */
export const CredentialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialApiFp(configuration)
    return {
        /**
         * Creates a new credential.
         * @summary Create a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel> {
            return localVarFp.createCredential(credentialsId, credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a credential.
         * @summary Delete a credential.
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(credentialsId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of credentials.
         * @summary List of credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(options?: any): AxiosPromise<Array<CredentialsModel>> {
            return localVarFp.listCredentials(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a credential.
         * @summary Update a credential.
         * @param {string} credentialsId credentials_id
         * @param {CreateAndUpdateCredentialsModel} credentials credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel> {
            return localVarFp.updateCredential(credentialsId, credentials, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialApi - interface
 * @export
 * @interface CredentialApi
 */
export interface CredentialApiInterface {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;

    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    deleteCredential(credentialsId: string, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    listCredentials(options?: any): AxiosPromise<Array<CredentialsModel>>;

    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApiInterface
     */
    updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any): AxiosPromise<CredentialsModel>;

}

/**
 * CredentialApi - object-oriented interface
 * @export
 * @class CredentialApi
 * @extends {BaseAPI}
 */
export class CredentialApi extends BaseAPI implements CredentialApiInterface {
    /**
     * Creates a new credential.
     * @summary Create a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public createCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any) {
        return CredentialApiFp(this.configuration).createCredential(credentialsId, credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a credential.
     * @summary Delete a credential.
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public deleteCredential(credentialsId: string, options?: any) {
        return CredentialApiFp(this.configuration).deleteCredential(credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of credentials.
     * @summary List of credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public listCredentials(options?: any) {
        return CredentialApiFp(this.configuration).listCredentials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a credential.
     * @summary Update a credential.
     * @param {string} credentialsId credentials_id
     * @param {CreateAndUpdateCredentialsModel} credentials credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public updateCredential(credentialsId: string, credentials: CreateAndUpdateCredentialsModel, options?: any) {
        return CredentialApiFp(this.configuration).updateCredential(credentialsId, credentials, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataEntryApi - axios parameter creator
 * @export
 */
export const DataEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a data entry identified with resource ID and timestamp
         * @summary Deletes a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataEntry: async (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('deleteDataEntry', 'resourceType', resourceType)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('deleteDataEntry', 'resourceId', resourceId)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('deleteDataEntry', 'time', time)
            const localVarPath = `/data/{resource_type}/{resource_id}/{time}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"time"}}`, encodeURIComponent(String(time)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a resource.
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEntries: async (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getDataEntries', 'resourceType', resourceType)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDataEntries', 'resourceId', resourceId)
            const localVarPath = `/data/{resource_type}/{resource_id}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a data entry identified with resource ID and timestamp
         * @summary Gets a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEntry: async (resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('getDataEntry', 'resourceType', resourceType)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDataEntry', 'resourceId', resourceId)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('getDataEntry', 'time', time)
            const localVarPath = `/data/{resource_type}/{resource_id}/{time}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"time"}}`, encodeURIComponent(String(time)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get the list of data source resources
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSourceResources: async (resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataEntryApi - functional programming interface
 * @export
 */
export const DataEntryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataEntryApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a data entry identified with resource ID and timestamp
         * @summary Deletes a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataEntry(resourceType, resourceId, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a resource.
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataEntries(resourceType, resourceId, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a data entry identified with resource ID and timestamp
         * @summary Gets a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataEntry(resourceType, resourceId, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get the list of data source resources
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSourceResourceMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataSourceResources(resourceType, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataEntryApi - factory interface
 * @export
 */
export const DataEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataEntryApiFp(configuration)
    return {
        /**
         * Deletes a data entry identified with resource ID and timestamp
         * @summary Deletes a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataEntry(resourceType, resourceId, time, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a resource.
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataEntries(resourceType, resourceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a data entry identified with resource ID and timestamp
         * @summary Gets a data entry
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
         * @param {string} resourceId ID of data source resource
         * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void> {
            return localVarFp.getDataEntry(resourceType, resourceId, time, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get the list of data source resources
         * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataSourceResourceMetadata>> {
            return localVarFp.listDataSourceResources(resourceType, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataEntryApi - interface
 * @export
 * @interface DataEntryApi
 */
export interface DataEntryApiInterface {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApiInterface
     */
    listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataSourceResourceMetadata>>;

}

/**
 * DataEntryApi - object-oriented interface
 * @export
 * @class DataEntryApi
 * @extends {BaseAPI}
 */
export class DataEntryApi extends BaseAPI implements DataEntryApiInterface {
    /**
     * Deletes a data entry identified with resource ID and timestamp
     * @summary Deletes a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to delete (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    public deleteDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any) {
        return DataEntryApiFp(this.configuration).deleteDataEntry(resourceType, resourceId, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a resource that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a resource.
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    public getDataEntries(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return DataEntryApiFp(this.configuration).getDataEntries(resourceType, resourceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a data entry identified with resource ID and timestamp
     * @summary Gets a data entry
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} resourceType Type of data source resource
     * @param {string} resourceId ID of data source resource
     * @param {number} time Timestamp of the target data entry to get (unixtime in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    public getDataEntry(resourceType: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', resourceId: string, time: number, options?: any) {
        return DataEntryApiFp(this.configuration).getDataEntry(resourceType, resourceId, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data source resources that have sent data from resources that belong to the operator. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get the list of data source resources
     * @param {'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device'} [resourceType] Type of data source resource
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;resourceId&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataEntryApi
     */
    public listDataSourceResources(resourceType?: 'Subscriber' | 'LoraDevice' | 'SubscriberIdentityModule' | 'SigfoxDevice' | 'Device', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return DataEntryApiFp(this.configuration).listDataSourceResources(resourceType, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Device
         * @summary Creates a new Device
         * @param {Device} device Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice: async (device: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('createDevice', 'device', device)
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Device
         * @summary Delete Device
         * @param {string} deviceId Device to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deleteDevice', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete device tag
         * @summary Delete device tag
         * @param {string} deviceId Device to update
         * @param {string} tagName Name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag: async (deviceId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deleteDeviceTag', 'deviceId', deviceId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteDeviceTag', 'tagName', tagName)
            const localVarPath = `/devices/{device_id}/tags/{tag_name}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes a resource of a device
         * @summary Executes a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {InlineObject} [arg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeDeviceResource: async (deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('executeDeviceResource', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('executeDeviceResource', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('executeDeviceResource', 'instance', instance)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('executeDeviceResource', 'resource', resource)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/{resource}/execute`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(arg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromDevice: async (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDataFromDevice', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/data`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Device identified by device ID
         * @summary Returns a Device identified by device ID
         * @param {string} deviceId Device ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (deviceId: string, model?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDevice', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Devices
         * @summary Returns a list of Devices
         * @param {string} [tagName] Tag name
         * @param {string} [tagValue] Tag value
         * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
         * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
         * @param {number} [limit] Max number of Devices in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices: async (tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers observation of the specified resource of a device
         * @summary Triggers observation of the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observeDeviceResource: async (deviceId: string, object: string, instance: string, resource: string, model?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('observeDeviceResource', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('observeDeviceResource', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('observeDeviceResource', 'instance', instance)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('observeDeviceResource', 'resource', resource)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/{resource}/observe`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers observation of resources under an object instance of a device
         * @summary Triggers observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observeDeviceResources: async (deviceId: string, object: string, instance: string, model?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('observeDeviceResources', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('observeDeviceResources', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('observeDeviceResources', 'instance', instance)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/observe`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates device tags
         * @summary Updates device tags
         * @param {string} deviceId Device to update
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeviceTags: async (deviceId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('putDeviceTags', 'deviceId', deviceId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putDeviceTags', 'tags', tags)
            const localVarPath = `/devices/{device_id}/tags`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified resource of a device
         * @summary Get the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceResource: async (deviceId: string, object: string, instance: string, resource: string, model?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('readDeviceResource', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('readDeviceResource', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('readDeviceResource', 'instance', instance)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('readDeviceResource', 'resource', resource)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/{resource}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resources under an object instance of a device
         * @summary Get resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceResources: async (deviceId: string, object: string, instance: string, model?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('readDeviceResources', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('readDeviceResources', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('readDeviceResources', 'instance', instance)
            const localVarPath = `/devices/{device_id}/{object}/{instance}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lets a device device join a group
         * @summary Lets a device device join a group
         * @param {string} deviceId Device to update
         * @param {InlineObject1} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeviceGroup: async (deviceId: string, groupId?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('setDeviceGroup', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/set_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops observation of a resource of a device
         * @summary Stops observation of a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unobserveDeviceResource: async (deviceId: string, object: string, instance: string, resource: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('unobserveDeviceResource', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('unobserveDeviceResource', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('unobserveDeviceResource', 'instance', instance)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('unobserveDeviceResource', 'resource', resource)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/{resource}/unobserve`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops observation of resources under an object instance of a device
         * @summary Stops observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unobserveDeviceResources: async (deviceId: string, object: string, instance: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('unobserveDeviceResources', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('unobserveDeviceResources', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('unobserveDeviceResources', 'instance', instance)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/unobserve`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lets a device leave from a group
         * @summary Lets a device leave from a group
         * @param {string} deviceId Device to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetDeviceGroup: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('unsetDeviceGroup', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/unset_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Write value to a resource of a device
         * @summary Write value to a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeDeviceResource: async (deviceId: string, object: string, instance: string, resource: string, value: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('writeDeviceResource', 'deviceId', deviceId)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('writeDeviceResource', 'object', object)
            // verify required parameter 'instance' is not null or undefined
            assertParamExists('writeDeviceResource', 'instance', instance)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('writeDeviceResource', 'resource', resource)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('writeDeviceResource', 'value', value)
            const localVarPath = `/devices/{device_id}/{object}/{instance}/{resource}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"object"}}`, encodeURIComponent(String(object)))
                .replace(`{${"instance"}}`, encodeURIComponent(String(instance)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Device
         * @summary Creates a new Device
         * @param {Device} device Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDevice(device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDevice(device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Device
         * @summary Delete Device
         * @param {string} deviceId Device to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete device tag
         * @summary Delete device tag
         * @param {string} deviceId Device to update
         * @param {string} tagName Name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceTag(deviceId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes a resource of a device
         * @summary Executes a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {InlineObject} [arg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeDeviceResource(deviceId, object, instance, resource, arg, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFromDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Device identified by device ID
         * @summary Returns a Device identified by device ID
         * @param {string} deviceId Device ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(deviceId: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(deviceId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Devices
         * @summary Returns a list of Devices
         * @param {string} [tagName] Tag name
         * @param {string} [tagValue] Tag value
         * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
         * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
         * @param {number} [limit] Max number of Devices in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDevices(tagName, tagValue, tagValueMatchMode, lastEvaluatedKey, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers observation of the specified resource of a device
         * @summary Triggers observation of the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observeDeviceResource(deviceId, object, instance, resource, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers observation of resources under an object instance of a device
         * @summary Triggers observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observeDeviceResources(deviceId, object, instance, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates device tags
         * @summary Updates device tags
         * @param {string} deviceId Device to update
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDeviceTags(deviceId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the specified resource of a device
         * @summary Get the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDeviceResource(deviceId, object, instance, resource, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get resources under an object instance of a device
         * @summary Get resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDeviceResources(deviceId, object, instance, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lets a device device join a group
         * @summary Lets a device device join a group
         * @param {string} deviceId Device to update
         * @param {InlineObject1} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDeviceGroup(deviceId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stops observation of a resource of a device
         * @summary Stops observation of a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unobserveDeviceResource(deviceId, object, instance, resource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stops observation of resources under an object instance of a device
         * @summary Stops observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unobserveDeviceResources(deviceId, object, instance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lets a device leave from a group
         * @summary Lets a device leave from a group
         * @param {string} deviceId Device to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetDeviceGroup(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Write value to a resource of a device
         * @summary Write value to a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeDeviceResource(deviceId, object, instance, resource, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * Creates a new Device
         * @summary Creates a new Device
         * @param {Device} device Device to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice(device: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.createDevice(device, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Device
         * @summary Delete Device
         * @param {string} deviceId Device to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(deviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete device tag
         * @summary Delete device tag
         * @param {string} deviceId Device to update
         * @param {string} tagName Name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceTag(deviceId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes a resource of a device
         * @summary Executes a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {InlineObject} [arg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.executeDeviceResource(deviceId, object, instance, resource, arg, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataFromDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Device identified by device ID
         * @summary Returns a Device identified by device ID
         * @param {string} deviceId Device ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(deviceId: string, model?: boolean, options?: any): AxiosPromise<Device> {
            return localVarFp.getDevice(deviceId, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Devices
         * @summary Returns a list of Devices
         * @param {string} [tagName] Tag name
         * @param {string} [tagValue] Tag value
         * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
         * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
         * @param {number} [limit] Max number of Devices in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.listDevices(tagName, tagValue, tagValueMatchMode, lastEvaluatedKey, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers observation of the specified resource of a device
         * @summary Triggers observation of the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.observeDeviceResource(deviceId, object, instance, resource, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers observation of resources under an object instance of a device
         * @summary Triggers observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.observeDeviceResources(deviceId, object, instance, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates device tags
         * @summary Updates device tags
         * @param {string} deviceId Device to update
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Device> {
            return localVarFp.putDeviceTags(deviceId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the specified resource of a device
         * @summary Get the specified resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<ResourceInstance> {
            return localVarFp.readDeviceResource(deviceId, object, instance, resource, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resources under an object instance of a device
         * @summary Get resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {boolean} [model] Whether or not to add model information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<ObjectInstance> {
            return localVarFp.readDeviceResources(deviceId, object, instance, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Lets a device device join a group
         * @summary Lets a device device join a group
         * @param {string} deviceId Device to update
         * @param {InlineObject1} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): AxiosPromise<Device> {
            return localVarFp.setDeviceGroup(deviceId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops observation of a resource of a device
         * @summary Stops observation of a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): AxiosPromise<void> {
            return localVarFp.unobserveDeviceResource(deviceId, object, instance, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops observation of resources under an object instance of a device
         * @summary Stops observation of resources under an object instance of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): AxiosPromise<void> {
            return localVarFp.unobserveDeviceResources(deviceId, object, instance, options).then((request) => request(axios, basePath));
        },
        /**
         * Lets a device leave from a group
         * @summary Lets a device leave from a group
         * @param {string} deviceId Device to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetDeviceGroup(deviceId: string, options?: any): AxiosPromise<Device> {
            return localVarFp.unsetDeviceGroup(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Write value to a resource of a device
         * @summary Write value to a resource of a device
         * @param {string} deviceId Target device
         * @param {string} object Object ID
         * @param {string} instance Instance ID
         * @param {string} resource Resource ID
         * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): AxiosPromise<void> {
            return localVarFp.writeDeviceResource(deviceId, object, instance, resource, value, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - interface
 * @export
 * @interface DeviceApi
 */
export interface DeviceApiInterface {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    createDevice(device: Device, options?: any): AxiosPromise<Device>;

    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    deleteDevice(deviceId: string, options?: any): AxiosPromise<void>;

    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    deleteDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDevice(deviceId: string, model?: boolean, options?: any): AxiosPromise<Device>;

    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<Device>>;

    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<void>;

    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Device>;

    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any): AxiosPromise<ResourceInstance>;

    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any): AxiosPromise<ObjectInstance>;

    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any): AxiosPromise<Device>;

    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any): AxiosPromise<void>;

    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any): AxiosPromise<void>;

    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    unsetDeviceGroup(deviceId: string, options?: any): AxiosPromise<Device>;

    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any): AxiosPromise<void>;

}

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI implements DeviceApiInterface {
    /**
     * Creates a new Device
     * @summary Creates a new Device
     * @param {Device} device Device to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public createDevice(device: Device, options?: any) {
        return DeviceApiFp(this.configuration).createDevice(device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Device
     * @summary Delete Device
     * @param {string} deviceId Device to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deleteDevice(deviceId: string, options?: any) {
        return DeviceApiFp(this.configuration).deleteDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete device tag
     * @summary Delete device tag
     * @param {string} deviceId Device to update
     * @param {string} tagName Name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deleteDeviceTag(deviceId: string, tagName: string, options?: any) {
        return DeviceApiFp(this.configuration).deleteDeviceTag(deviceId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes a resource of a device
     * @summary Executes a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {InlineObject} [arg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public executeDeviceResource(deviceId: string, object: string, instance: string, resource: string, arg?: InlineObject, options?: any) {
        return DeviceApiFp(this.configuration).executeDeviceResource(deviceId, object, instance, resource, arg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDataFromDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return DeviceApiFp(this.configuration).getDataFromDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Device identified by device ID
     * @summary Returns a Device identified by device ID
     * @param {string} deviceId Device ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDevice(deviceId: string, model?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).getDevice(deviceId, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Devices
     * @summary Returns a list of Devices
     * @param {string} [tagName] Tag name
     * @param {string} [tagValue] Tag value
     * @param {string} [tagValueMatchMode] Tag value match mode (exact | prefix)
     * @param {string} [lastEvaluatedKey] ID of the last Device in the previous page
     * @param {number} [limit] Max number of Devices in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public listDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: string, lastEvaluatedKey?: string, limit?: number, options?: any) {
        return DeviceApiFp(this.configuration).listDevices(tagName, tagValue, tagValueMatchMode, lastEvaluatedKey, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers observation of the specified resource of a device
     * @summary Triggers observation of the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public observeDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).observeDeviceResource(deviceId, object, instance, resource, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers observation of resources under an object instance of a device
     * @summary Triggers observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public observeDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).observeDeviceResources(deviceId, object, instance, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates device tags
     * @summary Updates device tags
     * @param {string} deviceId Device to update
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public putDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return DeviceApiFp(this.configuration).putDeviceTags(deviceId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the specified resource of a device
     * @summary Get the specified resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public readDeviceResource(deviceId: string, object: string, instance: string, resource: string, model?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).readDeviceResource(deviceId, object, instance, resource, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resources under an object instance of a device
     * @summary Get resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {boolean} [model] Whether or not to add model information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public readDeviceResources(deviceId: string, object: string, instance: string, model?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).readDeviceResources(deviceId, object, instance, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lets a device device join a group
     * @summary Lets a device device join a group
     * @param {string} deviceId Device to update
     * @param {InlineObject1} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public setDeviceGroup(deviceId: string, groupId?: InlineObject1, options?: any) {
        return DeviceApiFp(this.configuration).setDeviceGroup(deviceId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops observation of a resource of a device
     * @summary Stops observation of a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public unobserveDeviceResource(deviceId: string, object: string, instance: string, resource: string, options?: any) {
        return DeviceApiFp(this.configuration).unobserveDeviceResource(deviceId, object, instance, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops observation of resources under an object instance of a device
     * @summary Stops observation of resources under an object instance of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public unobserveDeviceResources(deviceId: string, object: string, instance: string, options?: any) {
        return DeviceApiFp(this.configuration).unobserveDeviceResources(deviceId, object, instance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lets a device leave from a group
     * @summary Lets a device leave from a group
     * @param {string} deviceId Device to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public unsetDeviceGroup(deviceId: string, options?: any) {
        return DeviceApiFp(this.configuration).unsetDeviceGroup(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Write value to a resource of a device
     * @summary Write value to a resource of a device
     * @param {string} deviceId Target device
     * @param {string} object Object ID
     * @param {string} instance Instance ID
     * @param {string} resource Resource ID
     * @param {object} value Value(s) to write to the resource. This value accepts LwM2M basic data types. You have to use the property name &#x60;values&#x60; (instead of &#x60;value&#x60;) with an array value if the resource model is multiple-mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public writeDeviceResource(deviceId: string, object: string, instance: string, resource: string, value: object, options?: any) {
        return DeviceApiFp(this.configuration).writeDeviceResource(deviceId, object, instance, resource, value, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceObjectModelApi - axios parameter creator
 * @export
 */
export const DeviceObjectModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new device object model
         * @summary Creates a new device object model
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceObjectModel: async (objectModelDefinition: DeviceObjectModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectModelDefinition' is not null or undefined
            assertParamExists('createDeviceObjectModel', 'objectModelDefinition', objectModelDefinition)
            const localVarPath = `/device_object_models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectModelDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a device object model
         * @summary Deletes a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceObjectModel: async (modelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('deleteDeviceObjectModel', 'modelId', modelId)
            const localVarPath = `/device_object_models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a device object model
         * @summary Gets a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceObjectModel: async (modelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getDeviceObjectModel', 'modelId', modelId)
            const localVarPath = `/device_object_models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of device object models
         * @summary Returns a list of device object models
         * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
         * @param {number} [limit] Max number of device object models in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeviceObjectModels: async (lastEvaluatedKey?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_object_models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets scope for a device object model
         * @summary Sets scope for a device object model
         * @param {string} modelId Target device object model ID
         * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeviceObjectModelScope: async (modelId: string, scope: SetDeviceObjectModelScopeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('setDeviceObjectModelScope', 'modelId', modelId)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('setDeviceObjectModelScope', 'scope', scope)
            const localVarPath = `/device_object_models/{model_id}/set_scope`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a device object model
         * @summary Updates a device object model
         * @param {string} modelId Device object model ID
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceObjectModel: async (modelId: string, objectModelDefinition: DeviceObjectModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateDeviceObjectModel', 'modelId', modelId)
            // verify required parameter 'objectModelDefinition' is not null or undefined
            assertParamExists('updateDeviceObjectModel', 'objectModelDefinition', objectModelDefinition)
            const localVarPath = `/device_object_models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectModelDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceObjectModelApi - functional programming interface
 * @export
 */
export const DeviceObjectModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceObjectModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new device object model
         * @summary Creates a new device object model
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceObjectModel(objectModelDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a device object model
         * @summary Deletes a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceObjectModel(modelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceObjectModel(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a device object model
         * @summary Gets a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceObjectModel(modelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceObjectModel(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of device object models
         * @summary Returns a list of device object models
         * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
         * @param {number} [limit] Max number of device object models in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceObjectModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeviceObjectModels(lastEvaluatedKey, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets scope for a device object model
         * @summary Sets scope for a device object model
         * @param {string} modelId Target device object model ID
         * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDeviceObjectModelScope(modelId, scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a device object model
         * @summary Updates a device object model
         * @param {string} modelId Device object model ID
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceObjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceObjectModel(modelId, objectModelDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceObjectModelApi - factory interface
 * @export
 */
export const DeviceObjectModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceObjectModelApiFp(configuration)
    return {
        /**
         * Creates a new device object model
         * @summary Creates a new device object model
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel> {
            return localVarFp.createDeviceObjectModel(objectModelDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a device object model
         * @summary Deletes a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceObjectModel(modelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeviceObjectModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a device object model
         * @summary Gets a device object model
         * @param {string} modelId Device object model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceObjectModel(modelId: string, options?: any): AxiosPromise<DeviceObjectModel> {
            return localVarFp.getDeviceObjectModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of device object models
         * @summary Returns a list of device object models
         * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
         * @param {number} [limit] Max number of device object models in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<DeviceObjectModel>> {
            return localVarFp.listDeviceObjectModels(lastEvaluatedKey, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets scope for a device object model
         * @summary Sets scope for a device object model
         * @param {string} modelId Target device object model ID
         * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): AxiosPromise<DeviceObjectModel> {
            return localVarFp.setDeviceObjectModelScope(modelId, scope, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a device object model
         * @summary Updates a device object model
         * @param {string} modelId Device object model ID
         * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel> {
            return localVarFp.updateDeviceObjectModel(modelId, objectModelDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceObjectModelApi - interface
 * @export
 * @interface DeviceObjectModelApi
 */
export interface DeviceObjectModelApiInterface {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;

    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    deleteDeviceObjectModel(modelId: string, options?: any): AxiosPromise<void>;

    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    getDeviceObjectModel(modelId: string, options?: any): AxiosPromise<DeviceObjectModel>;

    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<DeviceObjectModel>>;

    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any): AxiosPromise<DeviceObjectModel>;

    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApiInterface
     */
    updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any): AxiosPromise<DeviceObjectModel>;

}

/**
 * DeviceObjectModelApi - object-oriented interface
 * @export
 * @class DeviceObjectModelApi
 * @extends {BaseAPI}
 */
export class DeviceObjectModelApi extends BaseAPI implements DeviceObjectModelApiInterface {
    /**
     * Creates a new device object model
     * @summary Creates a new device object model
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public createDeviceObjectModel(objectModelDefinition: DeviceObjectModel, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).createDeviceObjectModel(objectModelDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a device object model
     * @summary Deletes a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public deleteDeviceObjectModel(modelId: string, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).deleteDeviceObjectModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a device object model
     * @summary Gets a device object model
     * @param {string} modelId Device object model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public getDeviceObjectModel(modelId: string, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).getDeviceObjectModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of device object models
     * @summary Returns a list of device object models
     * @param {string} [lastEvaluatedKey] ID of the last device object model in the previous page
     * @param {number} [limit] Max number of device object models in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public listDeviceObjectModels(lastEvaluatedKey?: string, limit?: number, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).listDeviceObjectModels(lastEvaluatedKey, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets scope for a device object model
     * @summary Sets scope for a device object model
     * @param {string} modelId Target device object model ID
     * @param {SetDeviceObjectModelScopeRequest} scope Scope value that is applied to the target device object model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public setDeviceObjectModelScope(modelId: string, scope: SetDeviceObjectModelScopeRequest, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).setDeviceObjectModelScope(modelId, scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a device object model
     * @summary Updates a device object model
     * @param {string} modelId Device object model ID
     * @param {DeviceObjectModel} objectModelDefinition Device object model definition in either XML or JSON format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceObjectModelApi
     */
    public updateDeviceObjectModel(modelId: string, objectModelDefinition: DeviceObjectModel, options?: any) {
        return DeviceObjectModelApiFp(this.configuration).updateDeviceObjectModel(modelId, objectModelDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an email address.
         * @summary Delete email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: async (operatorId: string, emailId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteEmail', 'operatorId', operatorId)
            // verify required parameter 'emailId' is not null or undefined
            assertParamExists('deleteEmail', 'emailId', emailId)
            const localVarPath = `/operators/{operator_id}/emails/{email_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(emailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an email address.
         * @summary Get email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: async (operatorId: string, emailId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getEmail', 'operatorId', operatorId)
            // verify required parameter 'emailId' is not null or undefined
            assertParamExists('getEmail', 'emailId', emailId)
            const localVarPath = `/operators/{operator_id}/emails/{email_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(emailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email with a one-time token for adding an e-mail address.
         * @summary Issue a token to add an email address
         * @param {IssueAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddEmailToken: async (request: IssueAddEmailTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueAddEmailToken', 'request', request)
            const localVarPath = `/operators/add_email_token/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of email addresses.
         * @summary List email addresses
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listEmails', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/emails`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the token for adding email address.
         * @summary Verify a token to add an email address
         * @param {VerifyAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddEmailToken: async (request: VerifyAddEmailTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verifyAddEmailToken', 'request', request)
            const localVarPath = `/operators/add_email_token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an email address.
         * @summary Delete email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmail(operatorId: string, emailId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmail(operatorId, emailId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an email address.
         * @summary Get email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmail(operatorId: string, emailId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmail(operatorId, emailId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email with a one-time token for adding an e-mail address.
         * @summary Issue a token to add an email address
         * @param {IssueAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddEmailToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of email addresses.
         * @summary List email addresses
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmails(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailsModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmails(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the token for adding email address.
         * @summary Verify a token to add an email address
         * @param {VerifyAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAddEmailToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailApiFp(configuration)
    return {
        /**
         * Deletes an email address.
         * @summary Delete email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEmail(operatorId, emailId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an email address.
         * @summary Get email address
         * @param {string} operatorId operator_id
         * @param {string} emailId email_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<EmailsModel> {
            return localVarFp.getEmail(operatorId, emailId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email with a one-time token for adding an e-mail address.
         * @summary Issue a token to add an email address
         * @param {IssueAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.issueAddEmailToken(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of email addresses.
         * @summary List email addresses
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(operatorId: string, options?: any): AxiosPromise<Array<EmailsModel>> {
            return localVarFp.listEmails(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the token for adding email address.
         * @summary Verify a token to add an email address
         * @param {VerifyAddEmailTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyAddEmailToken(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailApi - interface
 * @export
 * @interface EmailApi
 */
export interface EmailApiInterface {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    deleteEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<void>;

    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    getEmail(operatorId: string, emailId: string, options?: any): AxiosPromise<EmailsModel>;

    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    listEmails(operatorId: string, options?: any): AxiosPromise<Array<EmailsModel>>;

    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApiInterface
     */
    verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any): AxiosPromise<void>;

}

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI implements EmailApiInterface {
    /**
     * Deletes an email address.
     * @summary Delete email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public deleteEmail(operatorId: string, emailId: string, options?: any) {
        return EmailApiFp(this.configuration).deleteEmail(operatorId, emailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an email address.
     * @summary Get email address
     * @param {string} operatorId operator_id
     * @param {string} emailId email_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public getEmail(operatorId: string, emailId: string, options?: any) {
        return EmailApiFp(this.configuration).getEmail(operatorId, emailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email with a one-time token for adding an e-mail address.
     * @summary Issue a token to add an email address
     * @param {IssueAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public issueAddEmailToken(request: IssueAddEmailTokenRequest, options?: any) {
        return EmailApiFp(this.configuration).issueAddEmailToken(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of email addresses.
     * @summary List email addresses
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public listEmails(operatorId: string, options?: any) {
        return EmailApiFp(this.configuration).listEmails(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the token for adding email address.
     * @summary Verify a token to add an email address
     * @param {VerifyAddEmailTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public verifyAddEmailToken(request: VerifyAddEmailTokenRequest, options?: any) {
        return EmailApiFp(this.configuration).verifyAddEmailToken(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventHandlerApi - axios parameter creator
 * @export
 */
export const EventHandlerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Create Event Handler.
         * @param {CreateEventHandlerRequest} req event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventHandler: async (req: CreateEventHandlerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('createEventHandler', 'req', req)
            const localVarPath = `/event_handlers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified event handler.
         * @summary Delete Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventHandler: async (handlerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('deleteEventHandler', 'handlerId', handlerId)
            const localVarPath = `/event_handlers/{handler_id}`
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the setting for ignoring the specified event handler of the specified IMSI.
         * @summary Delete Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIgnoreEventHandler: async (imsi: string, handlerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('deleteIgnoreEventHandler', 'imsi', imsi)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('deleteIgnoreEventHandler', 'handlerId', handlerId)
            const localVarPath = `/event_handlers/{handler_id}/subscribers/{imsi}/ignore`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified event handler.
         * @summary Get Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventHandler: async (handlerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('getEventHandler', 'handlerId', handlerId)
            const localVarPath = `/event_handlers/{handler_id}`
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event handlers.
         * @summary List Event Handlers.
         * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventHandlers: async (target?: 'operator' | 'imsi' | 'sim' | 'group', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_handlers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event handlers related to the specified IMSI.
         * @summary List Event Handlers related to Subscriber.
         * @param {string} imsi imsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventHandlersBySubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('listEventHandlersBySubscriber', 'imsi', imsi)
            const localVarPath = `/event_handlers/subscribers/{imsi}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a setting for ignoring the specified event handler of the specified IMSI.
         * @summary Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIgnoreEventHandler: async (imsi: string, handlerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('setIgnoreEventHandler', 'imsi', imsi)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('setIgnoreEventHandler', 'handlerId', handlerId)
            const localVarPath = `/event_handlers/{handler_id}/subscribers/{imsi}/ignore`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Update Event Handler.
         * @param {string} handlerId handler ID
         * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventHandler: async (handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('updateEventHandler', 'handlerId', handlerId)
            // verify required parameter 'eventHandlerModel' is not null or undefined
            assertParamExists('updateEventHandler', 'eventHandlerModel', eventHandlerModel)
            const localVarPath = `/event_handlers/{handler_id}`
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventHandlerModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventHandlerApi - functional programming interface
 * @export
 */
export const EventHandlerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventHandlerApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Create Event Handler.
         * @param {CreateEventHandlerRequest} req event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventHandler(req: CreateEventHandlerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventHandlerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventHandler(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified event handler.
         * @summary Delete Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventHandler(handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventHandler(handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the setting for ignoring the specified event handler of the specified IMSI.
         * @summary Delete Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIgnoreEventHandler(imsi, handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified event handler.
         * @summary Get Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventHandler(handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventHandlerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventHandler(handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event handlers.
         * @summary List Event Handlers.
         * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventHandlerModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventHandlers(target, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event handlers related to the specified IMSI.
         * @summary List Event Handlers related to Subscriber.
         * @param {string} imsi imsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventHandlersBySubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventHandlerModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventHandlersBySubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a setting for ignoring the specified event handler of the specified IMSI.
         * @summary Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setIgnoreEventHandler(imsi, handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Update Event Handler.
         * @param {string} handlerId handler ID
         * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventHandler(handlerId, eventHandlerModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventHandlerApi - factory interface
 * @export
 */
export const EventHandlerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventHandlerApiFp(configuration)
    return {
        /**
         * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Create Event Handler.
         * @param {CreateEventHandlerRequest} req event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventHandler(req: CreateEventHandlerRequest, options?: any): AxiosPromise<EventHandlerModel> {
            return localVarFp.createEventHandler(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified event handler.
         * @summary Delete Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventHandler(handlerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventHandler(handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the setting for ignoring the specified event handler of the specified IMSI.
         * @summary Delete Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIgnoreEventHandler(imsi, handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified event handler.
         * @summary Get Event Handler.
         * @param {string} handlerId handler ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventHandler(handlerId: string, options?: any): AxiosPromise<EventHandlerModel> {
            return localVarFp.getEventHandler(handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event handlers.
         * @summary List Event Handlers.
         * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): AxiosPromise<Array<EventHandlerModel>> {
            return localVarFp.listEventHandlers(target, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event handlers related to the specified IMSI.
         * @summary List Event Handlers related to Subscriber.
         * @param {string} imsi imsi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventHandlersBySubscriber(imsi: string, options?: any): AxiosPromise<Array<EventHandlerModel>> {
            return localVarFp.listEventHandlersBySubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a setting for ignoring the specified event handler of the specified IMSI.
         * @summary Ignore Event Handler.
         * @param {string} imsi imsi
         * @param {string} handlerId handler_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setIgnoreEventHandler(imsi, handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
         * @summary Update Event Handler.
         * @param {string} handlerId handler ID
         * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateEventHandler(handlerId, eventHandlerModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventHandlerApi - interface
 * @export
 * @interface EventHandlerApi
 */
export interface EventHandlerApiInterface {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    createEventHandler(req: CreateEventHandlerRequest, options?: any): AxiosPromise<EventHandlerModel>;

    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    deleteEventHandler(handlerId: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;

    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    getEventHandler(handlerId: string, options?: any): AxiosPromise<EventHandlerModel>;

    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any): AxiosPromise<Array<EventHandlerModel>>;

    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    listEventHandlersBySubscriber(imsi: string, options?: any): AxiosPromise<Array<EventHandlerModel>>;

    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    setIgnoreEventHandler(imsi: string, handlerId: string, options?: any): AxiosPromise<void>;

    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApiInterface
     */
    updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any): AxiosPromise<void>;

}

/**
 * EventHandlerApi - object-oriented interface
 * @export
 * @class EventHandlerApi
 * @extends {BaseAPI}
 */
export class EventHandlerApi extends BaseAPI implements EventHandlerApiInterface {
    /**
     * Creates a new event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Create Event Handler.
     * @param {CreateEventHandlerRequest} req event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public createEventHandler(req: CreateEventHandlerRequest, options?: any) {
        return EventHandlerApiFp(this.configuration).createEventHandler(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified event handler.
     * @summary Delete Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public deleteEventHandler(handlerId: string, options?: any) {
        return EventHandlerApiFp(this.configuration).deleteEventHandler(handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the setting for ignoring the specified event handler of the specified IMSI.
     * @summary Delete Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public deleteIgnoreEventHandler(imsi: string, handlerId: string, options?: any) {
        return EventHandlerApiFp(this.configuration).deleteIgnoreEventHandler(imsi, handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified event handler.
     * @summary Get Event Handler.
     * @param {string} handlerId handler ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public getEventHandler(handlerId: string, options?: any) {
        return EventHandlerApiFp(this.configuration).getEventHandler(handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event handlers.
     * @summary List Event Handlers.
     * @param {'operator' | 'imsi' | 'sim' | 'group'} [target] target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public listEventHandlers(target?: 'operator' | 'imsi' | 'sim' | 'group', options?: any) {
        return EventHandlerApiFp(this.configuration).listEventHandlers(target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event handlers related to the specified IMSI.
     * @summary List Event Handlers related to Subscriber.
     * @param {string} imsi imsi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public listEventHandlersBySubscriber(imsi: string, options?: any) {
        return EventHandlerApiFp(this.configuration).listEventHandlersBySubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a setting for ignoring the specified event handler of the specified IMSI.
     * @summary Ignore Event Handler.
     * @param {string} imsi imsi
     * @param {string} handlerId handler_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public setIgnoreEventHandler(imsi: string, handlerId: string, options?: any) {
        return EventHandlerApiFp(this.configuration).setIgnoreEventHandler(imsi, handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified event handler. Please see also https://developers.soracom.io/en/docs/air/event-handler/
     * @summary Update Event Handler.
     * @param {string} handlerId handler ID
     * @param {CreateEventHandlerRequest} eventHandlerModel event handler settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventHandlerApi
     */
    public updateEventHandler(handlerId: string, eventHandlerModel: CreateEventHandlerRequest, options?: any) {
        return EventHandlerApiFp(this.configuration).updateEventHandler(handlerId, eventHandlerModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileEntryApi - axios parameter creator
 * @export
 */
export const FileEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified directory in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target directory path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDirectory: async (scope: 'private', path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('deleteDirectory', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteDirectory', 'path', path)
            const localVarPath = `/files/{scope}/{path}/`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified file in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (scope: 'private', path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('deleteFile', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteFile', 'path', path)
            const localVarPath = `/files/{scope}/{path}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
         * @summary Find files with prefix query parameter in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} prefix Prefix to match with file path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFiles: async (scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('findFiles', 'scope', scope)
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('findFiles', 'prefix', prefix)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
         * @summary Download file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (scope: 'private' | 'public', path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('getFile', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getFile', 'path', path)
            const localVarPath = `/files/{scope}/{path}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets metadata of the file specified by the path and the scope.
         * @summary Get the metadata of the file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata: async (scope: 'private' | 'public', path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('getFileMetadata', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getFileMetadata', 'path', path)
            const localVarPath = `/files/{scope}/{path}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List files and directories on the path in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listFiles', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('listFiles', 'path', path)
            const localVarPath = `/files/{scope}/{path}/`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
         * @summary Upload file to the path in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFile: async (scope: 'private', path: string, body: any, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('putFile', 'scope', scope)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('putFile', 'path', path)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putFile', 'body', body)
            const localVarPath = `/files/{scope}/{path}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['content-type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileEntryApi - functional programming interface
 * @export
 */
export const FileEntryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileEntryApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified directory in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target directory path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDirectory(scope: 'private', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDirectory(scope, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified file in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(scope: 'private', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(scope, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
         * @summary Find files with prefix query parameter in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} prefix Prefix to match with file path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFiles(scope, prefix, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
         * @summary Download file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(scope: 'private' | 'public', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(scope, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets metadata of the file specified by the path and the scope.
         * @summary Get the metadata of the file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileMetadata(scope: 'private' | 'public', path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadata(scope, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List files and directories on the path in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(scope, path, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
         * @summary Upload file to the path in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFile(scope, path, body, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileEntryApi - factory interface
 * @export
 */
export const FileEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileEntryApiFp(configuration)
    return {
        /**
         * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified directory in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target directory path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDirectory(scope: 'private', path: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDirectory(scope, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
         * @summary Delete specified file in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(scope: 'private', path: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFile(scope, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
         * @summary Find files with prefix query parameter in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} prefix Prefix to match with file path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>> {
            return localVarFp.findFiles(scope, prefix, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
         * @summary Download file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<void> {
            return localVarFp.getFile(scope, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets metadata of the file specified by the path and the scope.
         * @summary Get the metadata of the file specified by the path and the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<FileEntry> {
            return localVarFp.getFileMetadata(scope, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List files and directories on the path in the scope
         * @param {'private' | 'public'} scope Scope of the request
         * @param {string} path Target path
         * @param {string} [limit] Num of entries
         * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>> {
            return localVarFp.listFiles(scope, path, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
         * @summary Upload file to the path in the scope.
         * @param {'private'} scope Scope of the request
         * @param {string} path Target path
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): AxiosPromise<void> {
            return localVarFp.putFile(scope, path, body, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileEntryApi - interface
 * @export
 * @interface FileEntryApi
 */
export interface FileEntryApiInterface {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    deleteDirectory(scope: 'private', path: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    deleteFile(scope: 'private', path: string, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;

    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    getFile(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<void>;

    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    getFileMetadata(scope: 'private' | 'public', path: string, options?: any): AxiosPromise<FileEntry>;

    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<FileEntry>>;

    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApiInterface
     */
    putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any): AxiosPromise<void>;

}

/**
 * FileEntryApi - object-oriented interface
 * @export
 * @class FileEntryApi
 * @extends {BaseAPI}
 */
export class FileEntryApi extends BaseAPI implements FileEntryApiInterface {
    /**
     * Deletes the specified directory in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified directory in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public deleteDirectory(scope: 'private', path: string, options?: any) {
        return FileEntryApiFp(this.configuration).deleteDirectory(scope, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified file in the scope. Only `private` scope is allowed for the operation.
     * @summary Delete specified file in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public deleteFile(scope: 'private', path: string, options?: any) {
        return FileEntryApiFp(this.configuration).deleteFile(scope, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of file entries which beginnings of their file paths are matched with the `prefix` query string in the ascending sorted UTF-8 bytes order of their file paths. An empty list is returned if the prefix does not match with any paths of file entries.
     * @summary Find files with prefix query parameter in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} prefix Prefix to match with file path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filePath of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public findFiles(scope: 'private' | 'public', prefix: string, limit?: string, lastEvaluatedKey?: string, options?: any) {
        return FileEntryApiFp(this.configuration).findFiles(scope, prefix, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects the client to URL for the link to download the file specified by the scope and the path. By issuing HTTP GET request to the link returned in the response, the client is able to download the file.
     * @summary Download file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public getFile(scope: 'private' | 'public', path: string, options?: any) {
        return FileEntryApiFp(this.configuration).getFile(scope, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets metadata of the file specified by the path and the scope.
     * @summary Get the metadata of the file specified by the path and the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public getFileMetadata(scope: 'private' | 'public', path: string, options?: any) {
        return FileEntryApiFp(this.configuration).getFileMetadata(scope, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of file entries under the path in the scope. This operation works only for directories and an error will be retrurned if the file entry corresponds to the given path is not a directory. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List files and directories on the path in the scope
     * @param {'private' | 'public'} scope Scope of the request
     * @param {string} path Target path
     * @param {string} [limit] Num of entries
     * @param {string} [lastEvaluatedKey] The filename  of the last file entry retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next file entry onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public listFiles(scope: 'private' | 'public', path: string, limit?: string, lastEvaluatedKey?: string, options?: any) {
        return FileEntryApiFp(this.configuration).listFiles(scope, path, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads the file to the specified path in the scope. Only `private` scope is allowed for the operation.
     * @summary Upload file to the path in the scope.
     * @param {'private'} scope Scope of the request
     * @param {string} path Target path
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileEntryApi
     */
    public putFile(scope: 'private', path: string, body: any, contentType?: string, options?: any) {
        return FileEntryApiFp(this.configuration).putFile(scope, path, body, contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
         * @summary Get an exported file.
         * @param {string} exportedFileId file export id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (exportedFileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportedFileId' is not null or undefined
            assertParamExists('getExportedFile', 'exportedFileId', exportedFileId)
            const localVarPath = `/files/exported/{exported_file_id}`
                .replace(`{${"exported_file_id"}}`, encodeURIComponent(String(exportedFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
         * @summary Get an exported file.
         * @param {string} exportedFileId file export id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(exportedFileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExportedFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(exportedFileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
         * @summary Get an exported file.
         * @param {string} exportedFileId file export id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(exportedFileId: string, options?: any): AxiosPromise<GetExportedFileResponse> {
            return localVarFp.getExportedFile(exportedFileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - interface
 * @export
 * @interface FilesApi
 */
export interface FilesApiInterface {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    getExportedFile(exportedFileId: string, options?: any): AxiosPromise<GetExportedFileResponse>;

}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI implements FilesApiInterface {
    /**
     * Get an exported file. The `url` field in the response will contain a URL to download the exported file.
     * @summary Get an exported file.
     * @param {string} exportedFileId file export id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getExportedFile(exportedFileId: string, options?: any) {
        return FilesApiFp(this.configuration).getExportedFile(exportedFileId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GadgetApi - axios parameter creator
 * @export
 */
export const GadgetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a tag from the specified gadget.
         * @summary Delete gadget Tag.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGadgetTag: async (productId: string, serialNumber: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteGadgetTag', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteGadgetTag', 'serialNumber', serialNumber)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteGadgetTag', 'tagName', tagName)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/tags/{tag_name}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of specified gadget.
         * @summary Disable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnGadget: async (productId: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('disableTerminationOnGadget', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('disableTerminationOnGadget', 'serialNumber', serialNumber)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/disable_termination`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified gadget.
         * @summary Enable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnGadget: async (productId: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('enableTerminationOnGadget', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('enableTerminationOnGadget', 'serialNumber', serialNumber)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/enable_termination`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified gadget.
         * @summary Get gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGadget: async (productId: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getGadget', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getGadget', 'serialNumber', serialNumber)
            const localVarPath = `/gadgets/{product_id}/{serial_number}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List gadgets.
         * @param {string} [productId] Product ID for filtering the search.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of gadgets to retrieve.
         * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGadgets: async (productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gadgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified gadget.
         * @summary Bulk Insert or Update gadget Tags.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGadgetTags: async (productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('putGadgetTags', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('putGadgetTags', 'serialNumber', serialNumber)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putGadgetTags', 'tags', tags)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/tags`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a gadget
         * @summary Register a gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGadget: async (productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('registerGadget', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('registerGadget', 'serialNumber', serialNumber)
            // verify required parameter 'registrationRequest' is not null or undefined
            assertParamExists('registerGadget', 'registrationRequest', registrationRequest)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/register`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites a group for the specified gadget.
         * @summary Set Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGadgetGroup: async (productId: string, serialNumber: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('setGadgetGroup', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('setGadgetGroup', 'serialNumber', serialNumber)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('setGadgetGroup', 'group', group)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/set_group`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified gadget
         * @summary Terminate gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateGadget: async (productId: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('terminateGadget', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('terminateGadget', 'serialNumber', serialNumber)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/terminate`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group configuration from the specified gadget.
         * @summary Unset Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetGadgetGroup: async (productId: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('unsetGadgetGroup', 'productId', productId)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('unsetGadgetGroup', 'serialNumber', serialNumber)
            const localVarPath = `/gadgets/{product_id}/{serial_number}/unset_group`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"serial_number"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GadgetApi - functional programming interface
 * @export
 */
export const GadgetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GadgetApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a tag from the specified gadget.
         * @summary Delete gadget Tag.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGadgetTag(productId, serialNumber, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of specified gadget.
         * @summary Disable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTerminationOnGadget(productId, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified gadget.
         * @summary Enable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTerminationOnGadget(productId, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified gadget.
         * @summary Get gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGadget(productId, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List gadgets.
         * @param {string} [productId] Product ID for filtering the search.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of gadgets to retrieve.
         * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gadget>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGadgets(productId, tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified gadget.
         * @summary Bulk Insert or Update gadget Tags.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGadgetTags(productId, serialNumber, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a gadget
         * @summary Register a gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerGadget(productId, serialNumber, registrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites a group for the specified gadget.
         * @summary Set Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGadgetGroup(productId, serialNumber, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified gadget
         * @summary Terminate gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateGadget(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateGadget(productId, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the group configuration from the specified gadget.
         * @summary Unset Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetGadgetGroup(productId: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gadget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetGadgetGroup(productId, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GadgetApi - factory interface
 * @export
 */
export const GadgetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GadgetApiFp(configuration)
    return {
        /**
         * Deletes a tag from the specified gadget.
         * @summary Delete gadget Tag.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGadgetTag(productId, serialNumber, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of specified gadget.
         * @summary Disable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget> {
            return localVarFp.disableTerminationOnGadget(productId, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified gadget.
         * @summary Enable Termination of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget> {
            return localVarFp.enableTerminationOnGadget(productId, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified gadget.
         * @summary Get gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget> {
            return localVarFp.getGadget(productId, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List gadgets.
         * @param {string} [productId] Product ID for filtering the search.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of gadgets to retrieve.
         * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Gadget>> {
            return localVarFp.listGadgets(productId, tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified gadget.
         * @summary Bulk Insert or Update gadget Tags.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Gadget> {
            return localVarFp.putGadgetTags(productId, serialNumber, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a gadget
         * @summary Register a gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): AxiosPromise<Gadget> {
            return localVarFp.registerGadget(productId, serialNumber, registrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites a group for the specified gadget.
         * @summary Set Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): AxiosPromise<Gadget> {
            return localVarFp.setGadgetGroup(productId, serialNumber, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified gadget
         * @summary Terminate gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget> {
            return localVarFp.terminateGadget(productId, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group configuration from the specified gadget.
         * @summary Unset Group of gadget.
         * @param {string} productId Product ID of the target gadget.
         * @param {string} serialNumber Serial Number of the target gadget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetGadgetGroup(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget> {
            return localVarFp.unsetGadgetGroup(productId, serialNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GadgetApi - interface
 * @export
 * @interface GadgetApi
 */
export interface GadgetApiInterface {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    disableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;

    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    enableTerminationOnGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;

    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    getGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;

    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Gadget>>;

    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Gadget>;

    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any): AxiosPromise<Gadget>;

    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any): AxiosPromise<Gadget>;

    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    terminateGadget(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;

    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApiInterface
     */
    unsetGadgetGroup(productId: string, serialNumber: string, options?: any): AxiosPromise<Gadget>;

}

/**
 * GadgetApi - object-oriented interface
 * @export
 * @class GadgetApi
 * @extends {BaseAPI}
 */
export class GadgetApi extends BaseAPI implements GadgetApiInterface {
    /**
     * Deletes a tag from the specified gadget.
     * @summary Delete gadget Tag.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public deleteGadgetTag(productId: string, serialNumber: string, tagName: string, options?: any) {
        return GadgetApiFp(this.configuration).deleteGadgetTag(productId, serialNumber, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of specified gadget.
     * @summary Disable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public disableTerminationOnGadget(productId: string, serialNumber: string, options?: any) {
        return GadgetApiFp(this.configuration).disableTerminationOnGadget(productId, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified gadget.
     * @summary Enable Termination of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public enableTerminationOnGadget(productId: string, serialNumber: string, options?: any) {
        return GadgetApiFp(this.configuration).enableTerminationOnGadget(productId, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified gadget.
     * @summary Get gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public getGadget(productId: string, serialNumber: string, options?: any) {
        return GadgetApiFp(this.configuration).getGadget(productId, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of gadgets that match certain criteria. If the total number of gadgets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List gadgets.
     * @param {string} [productId] Product ID for filtering the search.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of gadgets to retrieve.
     * @param {string} [lastEvaluatedKey] The ID ({product_id}/{serial_number}) of the last gadget retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public listGadgets(productId?: string, tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return GadgetApiFp(this.configuration).listGadgets(productId, tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified gadget.
     * @summary Bulk Insert or Update gadget Tags.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public putGadgetTags(productId: string, serialNumber: string, tags: Array<TagUpdateRequest>, options?: any) {
        return GadgetApiFp(this.configuration).putGadgetTags(productId, serialNumber, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a gadget
     * @summary Register a gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {GadgetRegistrationRequest} registrationRequest Gadget registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public registerGadget(productId: string, serialNumber: string, registrationRequest: GadgetRegistrationRequest, options?: any) {
        return GadgetApiFp(this.configuration).registerGadget(productId, serialNumber, registrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites a group for the specified gadget.
     * @summary Set Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public setGadgetGroup(productId: string, serialNumber: string, group: Group, options?: any) {
        return GadgetApiFp(this.configuration).setGadgetGroup(productId, serialNumber, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified gadget
     * @summary Terminate gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public terminateGadget(productId: string, serialNumber: string, options?: any) {
        return GadgetApiFp(this.configuration).terminateGadget(productId, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group configuration from the specified gadget.
     * @summary Unset Group of gadget.
     * @param {string} productId Product ID of the target gadget.
     * @param {string} serialNumber Serial Number of the target gadget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GadgetApi
     */
    public unsetGadgetGroup(productId: string, serialNumber: string, options?: any) {
        return GadgetApiFp(this.configuration).unsetGadgetGroup(productId, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new group.
         * @summary Create Group.
         * @param {CreateGroupRequest} tags Tags for group to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (tags: CreateGroupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('createGroup', 'tags', tags)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a namespace for the specified group.
         * @summary Delete Group Configuration Namespace.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationNamespace: async (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteConfigurationNamespace', 'groupId', groupId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteConfigurationNamespace', 'namespace', namespace)
            const localVarPath = `/groups/{group_id}/configuration/{namespace}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete parameters for the specified group.
         * @summary Delete Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
         * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationParameter: async (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteConfigurationParameter', 'groupId', groupId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteConfigurationParameter', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteConfigurationParameter', 'name', name)
            const localVarPath = `/groups/{group_id}/configuration/{namespace}/{name}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified group by group ID
         * @summary Delete Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes tag from the specified group.
         * @summary Delete Group Tag.
         * @param {string} groupId Target group ID.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupTag: async (groupId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupTag', 'groupId', groupId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteGroupTag', 'tagName', tagName)
            const localVarPath = `/groups/{group_id}/tags/{tag_name}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the group specified by the group ID.
         * @summary Get Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of groups.
         * @summary List Groups.
         * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the groups.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of subscribers that belong to the specified group by group ID.
         * @summary List Subscribers in a group.
         * @param {string} groupId Target group ID.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribersInGroup: async (groupId: string, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listSubscribersInGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/subscribers`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds/updates parameters for the specified group.
         * @summary Update Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
         * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConfigurationParameters: async (groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('putConfigurationParameters', 'groupId', groupId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('putConfigurationParameters', 'namespace', namespace)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('putConfigurationParameters', 'parameters', parameters)
            const localVarPath = `/groups/{group_id}/configuration/{namespace}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds/updates tags of specified configuration group.
         * @summary Update Group Tags.
         * @param {string} groupId Target group ID.
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGroupTags: async (groupId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('putGroupTags', 'groupId', groupId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putGroupTags', 'tags', tags)
            const localVarPath = `/groups/{group_id}/tags`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new group.
         * @summary Create Group.
         * @param {CreateGroupRequest} tags Tags for group to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(tags: CreateGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a namespace for the specified group.
         * @summary Delete Group Configuration Namespace.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConfigurationNamespace(groupId, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete parameters for the specified group.
         * @summary Delete Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
         * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConfigurationParameter(groupId, namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified group by group ID
         * @summary Delete Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes tag from the specified group.
         * @summary Delete Group Tag.
         * @param {string} groupId Target group ID.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupTag(groupId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupTag(groupId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the group specified by the group ID.
         * @summary Get Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of groups.
         * @summary List Groups.
         * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the groups.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of subscribers that belong to the specified group by group ID.
         * @summary List Subscribers in a group.
         * @param {string} groupId Target group ID.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscribersInGroup(groupId, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds/updates parameters for the specified group.
         * @summary Update Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
         * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putConfigurationParameters(groupId, namespace, parameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds/updates tags of specified configuration group.
         * @summary Update Group Tags.
         * @param {string} groupId Target group ID.
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGroupTags(groupId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * Create a new group.
         * @summary Create Group.
         * @param {CreateGroupRequest} tags Tags for group to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(tags: CreateGroupRequest, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a namespace for the specified group.
         * @summary Delete Group Configuration Namespace.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): AxiosPromise<void> {
            return localVarFp.deleteConfigurationNamespace(groupId, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete parameters for the specified group.
         * @summary Delete Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
         * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConfigurationParameter(groupId, namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified group by group ID
         * @summary Delete Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes tag from the specified group.
         * @summary Delete Group Tag.
         * @param {string} groupId Target group ID.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupTag(groupId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupTag(groupId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the group specified by the group ID.
         * @summary Get Group.
         * @param {string} groupId Target group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of groups.
         * @summary List Groups.
         * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the groups.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.listGroups(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of subscribers that belong to the specified group by group ID.
         * @summary List Subscribers in a group.
         * @param {string} groupId Target group ID.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Group> {
            return localVarFp.listSubscribersInGroup(groupId, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds/updates parameters for the specified group.
         * @summary Update Group Configuration Parameters.
         * @param {string} groupId Target group.
         * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
         * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): AxiosPromise<Group> {
            return localVarFp.putConfigurationParameters(groupId, namespace, parameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds/updates tags of specified configuration group.
         * @summary Update Group Tags.
         * @param {string} groupId Target group ID.
         * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.putGroupTags(groupId, tags, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - interface
 * @export
 * @interface GroupApi
 */
export interface GroupApiInterface {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    createGroup(tags: CreateGroupRequest, options?: any): AxiosPromise<Group>;

    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any): AxiosPromise<void>;

    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteGroup(groupId: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    deleteGroupTag(groupId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    getGroup(groupId: string, options?: any): AxiosPromise<Group>;

    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Group>>;

    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Group>;

    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any): AxiosPromise<Group>;

    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;

}

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI implements GroupApiInterface {
    /**
     * Create a new group.
     * @summary Create Group.
     * @param {CreateGroupRequest} tags Tags for group to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(tags: CreateGroupRequest, options?: any) {
        return GroupApiFp(this.configuration).createGroup(tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a namespace for the specified group.
     * @summary Delete Group Configuration Namespace.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteConfigurationNamespace(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', options?: any) {
        return GroupApiFp(this.configuration).deleteConfigurationNamespace(groupId, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete parameters for the specified group.
     * @summary Delete Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Namespace of target parameters.
     * @param {string} name Parameter name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteConfigurationParameter(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', name: string, options?: any) {
        return GroupApiFp(this.configuration).deleteConfigurationParameter(groupId, namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified group by group ID
     * @summary Delete Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupId: string, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes tag from the specified group.
     * @summary Delete Group Tag.
     * @param {string} groupId Target group ID.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroupTag(groupId: string, tagName: string, options?: any) {
        return GroupApiFp(this.configuration).deleteGroupTag(groupId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the group specified by the group ID.
     * @summary Get Group.
     * @param {string} groupId Target group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: string, options?: any) {
        return GroupApiFp(this.configuration).getGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of groups.
     * @summary List Groups.
     * @param {string} [tagName] Tag name of the group. Filters through all groups that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the groups.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroups(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return GroupApiFp(this.configuration).listGroups(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of subscribers that belong to the specified group by group ID.
     * @summary List Subscribers in a group.
     * @param {string} groupId Target group ID.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listSubscribersInGroup(groupId: string, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return GroupApiFp(this.configuration).listSubscribersInGroup(groupId, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds/updates parameters for the specified group.
     * @summary Update Group Configuration Parameters.
     * @param {string} groupId Target group.
     * @param {'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint'} namespace Target configuration.
     * @param {Array<GroupConfigurationUpdateRequest>} parameters Array of values for target object to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public putConfigurationParameters(groupId: string, namespace: 'SoracomAir' | 'SoracomBeam' | 'SoracomEndorse' | 'SoracomFunk' | 'SoracomFunnel' | 'SoracomHarvest' | 'SoracomHarvestFiles' | 'SoracomKrypton' | 'UnifiedEndpoint', parameters: Array<GroupConfigurationUpdateRequest>, options?: any) {
        return GroupApiFp(this.configuration).putConfigurationParameters(groupId, namespace, parameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds/updates tags of specified configuration group.
     * @summary Update Group Tags.
     * @param {string} groupId Target group ID.
     * @param {Array<TagUpdateRequest>} tags Array of values for tags to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public putGroupTags(groupId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return GroupApiFp(this.configuration).putGroupTags(groupId, tags, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LagoonApi - axios parameter creator
 * @export
 */
export const LagoonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a SORACOM Lagoon user.
         * @summary Create a SORACOM Lagoon user
         * @param {LagoonUserCreationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLagoonUser: async (request: LagoonUserCreationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createLagoonUser', 'request', request)
            const localVarPath = `/lagoon/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a SORACOM Lagoon user.
         * @summary Delete a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLagoonUser: async (lagoonUserId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lagoonUserId' is not null or undefined
            assertParamExists('deleteLagoonUser', 'lagoonUserId', lagoonUserId)
            const localVarPath = `/lagoon/users/{lagoon_user_id}`
                .replace(`{${"lagoon_user_id"}}`, encodeURIComponent(String(lagoonUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a custom icon image link of SORACOM Lagoon
         * @summary Get a custom icon image link of SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageLink: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lagoon/image/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeLagoonDashboardPermissions: async (dashboardId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('initializeLagoonDashboardPermissions', 'dashboardId', dashboardId)
            const localVarPath = `/lagoon/dashboards/{dashboard_id}/permissions/init`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List permissions for all SORACOM Lagoon dashboards
         * @summary List permissions for all SORACOM Lagoon dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonDashboardsPermissions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lagoon/dashboards/permission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of active SORACOM Lagoon license packs
         * @summary Get the status of active SORACOM Lagoon license packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonLicensePackStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lagoon/license_packs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List SORACOM Lagoon users that belong to operator.
         * @summary List SORACOM Lagoon users that belong to operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lagoon/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Register (activate) SORACOM Lagoon
         * @param {LagoonRegistrationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerLagoon: async (request: LagoonRegistrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registerLagoon', 'request', request)
            const localVarPath = `/lagoon/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate (deactivate) SORACOM Lagoon.
         * @summary Terminate (deactivate) SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLagoon: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lagoon/terminate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update permissions for a dashboard of SORACOM Lagoon
         * @summary Update permissions for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {LagoonDashboardPermissionsUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonDashboardPermissions: async (dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('updateLagoonDashboardPermissions', 'dashboardId', dashboardId)
            // verify required parameter 'req' is not null or undefined
            assertParamExists('updateLagoonDashboardPermissions', 'req', req)
            const localVarPath = `/lagoon/dashboards/{dashboard_id}/permissions`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the quantities for license packs of SORACOM Lagoon
         * @param {LagoonLicensePacksUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonLicensePack: async (req: LagoonLicensePacksUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('updateLagoonLicensePack', 'req', req)
            const localVarPath = `/lagoon/license_packs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the plan of SORACOM Lagoon
         * @param {LagoonPlanChangingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonPlan: async (req: LagoonPlanChangingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('updateLagoonPlan', 'req', req)
            const localVarPath = `/lagoon/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update email address of a SORACOM Lagoon user.
         * @summary Update email address of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserEmailUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserEmail: async (lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lagoonUserId' is not null or undefined
            assertParamExists('updateLagoonUserEmail', 'lagoonUserId', lagoonUserId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateLagoonUserEmail', 'request', request)
            const localVarPath = `/lagoon/users/{lagoon_user_id}/email`
                .replace(`{${"lagoon_user_id"}}`, encodeURIComponent(String(lagoonUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password of a SORACOM Lagoon user.
         * @summary Update password of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPasswordUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserPassword: async (lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lagoonUserId' is not null or undefined
            assertParamExists('updateLagoonUserPassword', 'lagoonUserId', lagoonUserId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateLagoonUserPassword', 'request', request)
            const localVarPath = `/lagoon/users/{lagoon_user_id}/password`
                .replace(`{${"lagoon_user_id"}}`, encodeURIComponent(String(lagoonUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update permission of a SORACOM Lagoon user.
         * @summary Update permission of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPermissionUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserPermission: async (lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lagoonUserId' is not null or undefined
            assertParamExists('updateLagoonUserPermission', 'lagoonUserId', lagoonUserId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateLagoonUserPermission', 'request', request)
            const localVarPath = `/lagoon/users/{lagoon_user_id}/permission`
                .replace(`{${"lagoon_user_id"}}`, encodeURIComponent(String(lagoonUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LagoonApi - functional programming interface
 * @export
 */
export const LagoonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LagoonApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a SORACOM Lagoon user.
         * @summary Create a SORACOM Lagoon user
         * @param {LagoonUserCreationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLagoonUser(request: LagoonUserCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LagoonUserCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLagoonUser(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a SORACOM Lagoon user.
         * @summary Delete a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLagoonUser(lagoonUserId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLagoonUser(lagoonUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a custom icon image link of SORACOM Lagoon
         * @summary Get a custom icon image link of SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageLink(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageLink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeLagoonDashboardPermissions(dashboardId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeLagoonDashboardPermissions(dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List permissions for all SORACOM Lagoon dashboards
         * @summary List permissions for all SORACOM Lagoon dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLagoonDashboardsPermissions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonDashboardPermissionsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLagoonDashboardsPermissions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status of active SORACOM Lagoon license packs
         * @summary Get the status of active SORACOM Lagoon license packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLagoonLicensePackStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonLicensePackStatusResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLagoonLicensePackStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List SORACOM Lagoon users that belong to operator.
         * @summary List SORACOM Lagoon users that belong to operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLagoonUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LagoonUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLagoonUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Register (activate) SORACOM Lagoon
         * @param {LagoonRegistrationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerLagoon(request: LagoonRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LagoonRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerLagoon(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminate (deactivate) SORACOM Lagoon.
         * @summary Terminate (deactivate) SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateLagoon(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateLagoon(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update permissions for a dashboard of SORACOM Lagoon
         * @summary Update permissions for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {LagoonDashboardPermissionsUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonDashboardPermissions(dashboardId, req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the quantities for license packs of SORACOM Lagoon
         * @param {LagoonLicensePacksUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonLicensePack(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the plan of SORACOM Lagoon
         * @param {LagoonPlanChangingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonPlan(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update email address of a SORACOM Lagoon user.
         * @summary Update email address of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserEmailUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonUserEmail(lagoonUserId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update password of a SORACOM Lagoon user.
         * @summary Update password of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPasswordUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonUserPassword(lagoonUserId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update permission of a SORACOM Lagoon user.
         * @summary Update permission of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPermissionUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLagoonUserPermission(lagoonUserId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LagoonApi - factory interface
 * @export
 */
export const LagoonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LagoonApiFp(configuration)
    return {
        /**
         * Create a SORACOM Lagoon user.
         * @summary Create a SORACOM Lagoon user
         * @param {LagoonUserCreationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLagoonUser(request: LagoonUserCreationRequest, options?: any): AxiosPromise<LagoonUserCreationResponse> {
            return localVarFp.createLagoonUser(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a SORACOM Lagoon user.
         * @summary Delete a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLagoonUser(lagoonUserId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLagoonUser(lagoonUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a custom icon image link of SORACOM Lagoon
         * @summary Get a custom icon image link of SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageLink(options?: any): AxiosPromise<string> {
            return localVarFp.getImageLink(options).then((request) => request(axios, basePath));
        },
        /**
         * Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeLagoonDashboardPermissions(dashboardId: number, options?: any): AxiosPromise<void> {
            return localVarFp.initializeLagoonDashboardPermissions(dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * List permissions for all SORACOM Lagoon dashboards
         * @summary List permissions for all SORACOM Lagoon dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonDashboardsPermissions(options?: any): AxiosPromise<Array<LagoonDashboardPermissionsResponse>> {
            return localVarFp.listLagoonDashboardsPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of active SORACOM Lagoon license packs
         * @summary Get the status of active SORACOM Lagoon license packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonLicensePackStatus(options?: any): AxiosPromise<Array<LagoonLicensePackStatusResponse>> {
            return localVarFp.listLagoonLicensePackStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * List SORACOM Lagoon users that belong to operator.
         * @summary List SORACOM Lagoon users that belong to operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLagoonUsers(options?: any): AxiosPromise<Array<LagoonUser>> {
            return localVarFp.listLagoonUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Register (activate) SORACOM Lagoon
         * @param {LagoonRegistrationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerLagoon(request: LagoonRegistrationRequest, options?: any): AxiosPromise<LagoonRegistrationResponse> {
            return localVarFp.registerLagoon(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate (deactivate) SORACOM Lagoon.
         * @summary Terminate (deactivate) SORACOM Lagoon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLagoon(options?: any): AxiosPromise<void> {
            return localVarFp.terminateLagoon(options).then((request) => request(axios, basePath));
        },
        /**
         * Update permissions for a dashboard of SORACOM Lagoon
         * @summary Update permissions for a dashboard of SORACOM Lagoon
         * @param {number} dashboardId dashboard_id
         * @param {LagoonDashboardPermissionsUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonDashboardPermissions(dashboardId, req, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the quantities for license packs of SORACOM Lagoon
         * @param {LagoonLicensePacksUpdatingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonLicensePack(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
         * @summary Update the plan of SORACOM Lagoon
         * @param {LagoonPlanChangingRequest} req req
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonPlan(req, options).then((request) => request(axios, basePath));
        },
        /**
         * Update email address of a SORACOM Lagoon user.
         * @summary Update email address of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserEmailUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonUserEmail(lagoonUserId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update password of a SORACOM Lagoon user.
         * @summary Update password of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPasswordUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonUserPassword(lagoonUserId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update permission of a SORACOM Lagoon user.
         * @summary Update permission of a SORACOM Lagoon user
         * @param {number} lagoonUserId Target ID of the lagoon user
         * @param {LagoonUserPermissionUpdatingRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLagoonUserPermission(lagoonUserId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LagoonApi - interface
 * @export
 * @interface LagoonApi
 */
export interface LagoonApiInterface {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    createLagoonUser(request: LagoonUserCreationRequest, options?: any): AxiosPromise<LagoonUserCreationResponse>;

    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    deleteLagoonUser(lagoonUserId: number, options?: any): AxiosPromise<void>;

    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    getImageLink(options?: any): AxiosPromise<string>;

    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    initializeLagoonDashboardPermissions(dashboardId: number, options?: any): AxiosPromise<void>;

    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonDashboardsPermissions(options?: any): AxiosPromise<Array<LagoonDashboardPermissionsResponse>>;

    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonLicensePackStatus(options?: any): AxiosPromise<Array<LagoonLicensePackStatusResponse>>;

    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    listLagoonUsers(options?: any): AxiosPromise<Array<LagoonUser>>;

    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    registerLagoon(request: LagoonRegistrationRequest, options?: any): AxiosPromise<LagoonRegistrationResponse>;

    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    terminateLagoon(options?: any): AxiosPromise<void>;

    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any): AxiosPromise<void>;

    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any): AxiosPromise<void>;

    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any): AxiosPromise<void>;

    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any): AxiosPromise<void>;

    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any): AxiosPromise<void>;

    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApiInterface
     */
    updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any): AxiosPromise<void>;

}

/**
 * LagoonApi - object-oriented interface
 * @export
 * @class LagoonApi
 * @extends {BaseAPI}
 */
export class LagoonApi extends BaseAPI implements LagoonApiInterface {
    /**
     * Create a SORACOM Lagoon user.
     * @summary Create a SORACOM Lagoon user
     * @param {LagoonUserCreationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public createLagoonUser(request: LagoonUserCreationRequest, options?: any) {
        return LagoonApiFp(this.configuration).createLagoonUser(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a SORACOM Lagoon user.
     * @summary Delete a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public deleteLagoonUser(lagoonUserId: number, options?: any) {
        return LagoonApiFp(this.configuration).deleteLagoonUser(lagoonUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a custom icon image link of SORACOM Lagoon
     * @summary Get a custom icon image link of SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public getImageLink(options?: any) {
        return LagoonApiFp(this.configuration).getImageLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @summary Update permissions to the initial state for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public initializeLagoonDashboardPermissions(dashboardId: number, options?: any) {
        return LagoonApiFp(this.configuration).initializeLagoonDashboardPermissions(dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List permissions for all SORACOM Lagoon dashboards
     * @summary List permissions for all SORACOM Lagoon dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public listLagoonDashboardsPermissions(options?: any) {
        return LagoonApiFp(this.configuration).listLagoonDashboardsPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of active SORACOM Lagoon license packs
     * @summary Get the status of active SORACOM Lagoon license packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public listLagoonLicensePackStatus(options?: any) {
        return LagoonApiFp(this.configuration).listLagoonLicensePackStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List SORACOM Lagoon users that belong to operator.
     * @summary List SORACOM Lagoon users that belong to operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public listLagoonUsers(options?: any) {
        return LagoonApiFp(this.configuration).listLagoonUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register (activate) SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Register (activate) SORACOM Lagoon
     * @param {LagoonRegistrationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public registerLagoon(request: LagoonRegistrationRequest, options?: any) {
        return LagoonApiFp(this.configuration).registerLagoon(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate (deactivate) SORACOM Lagoon.
     * @summary Terminate (deactivate) SORACOM Lagoon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public terminateLagoon(options?: any) {
        return LagoonApiFp(this.configuration).terminateLagoon(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update permissions for a dashboard of SORACOM Lagoon
     * @summary Update permissions for a dashboard of SORACOM Lagoon
     * @param {number} dashboardId dashboard_id
     * @param {LagoonDashboardPermissionsUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonDashboardPermissions(dashboardId: number, req: LagoonDashboardPermissionsUpdatingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonDashboardPermissions(dashboardId, req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the quantities for license packs of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the quantities for license packs of SORACOM Lagoon
     * @param {LagoonLicensePacksUpdatingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonLicensePack(req: LagoonLicensePacksUpdatingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonLicensePack(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the plan of SORACOM Lagoon. This API is only allowed to operate by root account.
     * @summary Update the plan of SORACOM Lagoon
     * @param {LagoonPlanChangingRequest} req req
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonPlan(req: LagoonPlanChangingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonPlan(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update email address of a SORACOM Lagoon user.
     * @summary Update email address of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserEmailUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonUserEmail(lagoonUserId: number, request: LagoonUserEmailUpdatingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonUserEmail(lagoonUserId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update password of a SORACOM Lagoon user.
     * @summary Update password of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPasswordUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonUserPassword(lagoonUserId: number, request: LagoonUserPasswordUpdatingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonUserPassword(lagoonUserId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update permission of a SORACOM Lagoon user.
     * @summary Update permission of a SORACOM Lagoon user
     * @param {number} lagoonUserId Target ID of the lagoon user
     * @param {LagoonUserPermissionUpdatingRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LagoonApi
     */
    public updateLagoonUserPermission(lagoonUserId: number, request: LagoonUserPermissionUpdatingRequest, options?: any) {
        return LagoonApiFp(this.configuration).updateLagoonUserPermission(lagoonUserId, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get Logs.
         * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
         * @param {number} [from] Start time for the log search range (unixtime).
         * @param {number} [to] End time for the log search range (unixtime).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs: async (resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resource_id'] = resourceId;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get Logs.
         * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
         * @param {number} [from] Start time for the log search range (unixtime).
         * @param {number} [to] End time for the log search range (unixtime).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogs(resourceType, resourceId, service, from, to, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get Logs.
         * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
         * @param {string} [resourceId] Identity of the target resource to query log entries.
         * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
         * @param {number} [from] Start time for the log search range (unixtime).
         * @param {number} [to] End time for the log search range (unixtime).
         * @param {number} [limit] Maximum number of log entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LogEntry>> {
            return localVarFp.getLogs(resourceType, resourceId, service, from, to, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogApi - interface
 * @export
 * @interface LogApi
 */
export interface LogApiInterface {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApiInterface
     */
    getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LogEntry>>;

}

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI implements LogApiInterface {
    /**
     * Returns a list of log entries that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get Logs.
     * @param {'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway'} [resourceType] Type of the target resource to query log entries.
     * @param {string} [resourceId] Identity of the target resource to query log entries.
     * @param {'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate'} [service] Service name to filter log entries.
     * @param {number} [from] Start time for the log search range (unixtime).
     * @param {number} [to] End time for the log search range (unixtime).
     * @param {number} [limit] Maximum number of log entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public getLogs(resourceType?: 'Subscriber' | 'EventHandler' | 'VirtualPrivateGateway', resourceId?: string, service?: 'Air' | 'Beam' | 'Canal' | 'Direct' | 'Door' | 'Endorse' | 'Funnel' | 'Gate', from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LogApiFp(this.configuration).getLogs(resourceType, resourceId, service, from, to, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoraDeviceApi - axios parameter creator
 * @export
 */
export const LoraDeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a tag from the specified LoRa device.
         * @summary Delete LoRa device Tag.
         * @param {string} deviceId device ID of the target LoRa device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraDeviceTag: async (deviceId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deleteLoraDeviceTag', 'deviceId', deviceId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteLoraDeviceTag', 'tagName', tagName)
            const localVarPath = `/lora_devices/{device_id}/tags/{tag_name}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of specified LoRa device.
         * @summary Disable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnLoraDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('disableTerminationOnLoraDevice', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}/disable_termination`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified LoRa device.
         * @summary Enable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnLoraDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('enableTerminationOnLoraDevice', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}/enable_termination`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a LoRa device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromLoraDevice: async (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDataFromLoraDevice', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}/data`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified LoRa device.
         * @summary Get LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getLoraDevice', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraDevices: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lora_devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified LoRa device.
         * @summary Bulk Insert or Update LoRa device Tags.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraDeviceTags: async (deviceId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('putLoraDeviceTags', 'deviceId', deviceId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putLoraDeviceTags', 'tags', tags)
            const localVarPath = `/lora_devices/{device_id}/tags`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a LoRa device.
         * @summary Register LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerLoraDevice: async (deviceId: string, loraDevice: RegisterLoraDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('registerLoraDevice', 'deviceId', deviceId)
            // verify required parameter 'loraDevice' is not null or undefined
            assertParamExists('registerLoraDevice', 'loraDevice', loraDevice)
            const localVarPath = `/lora_devices/{device_id}/register`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loraDevice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a LoRa device.
         * @param {string} deviceId ID of the recipient device.
         * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataToLoraDevice: async (deviceId: string, data: LoraData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('sendDataToLoraDevice', 'deviceId', deviceId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('sendDataToLoraDevice', 'data', data)
            const localVarPath = `/lora_devices/{device_id}/data`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites a group for the specified LoRa device.
         * @summary Set Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLoraDeviceGroup: async (deviceId: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('setLoraDeviceGroup', 'deviceId', deviceId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('setLoraDeviceGroup', 'group', group)
            const localVarPath = `/lora_devices/{device_id}/set_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified LoRa device
         * @summary Terminate LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLoraDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('terminateLoraDevice', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}/terminate`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group configuration from the specified LoRa device.
         * @summary Unset Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetLoraDeviceGroup: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('unsetLoraDeviceGroup', 'deviceId', deviceId)
            const localVarPath = `/lora_devices/{device_id}/unset_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoraDeviceApi - functional programming interface
 * @export
 */
export const LoraDeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoraDeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a tag from the specified LoRa device.
         * @summary Delete LoRa device Tag.
         * @param {string} deviceId device ID of the target LoRa device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoraDeviceTag(deviceId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of specified LoRa device.
         * @summary Disable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTerminationOnLoraDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified LoRa device.
         * @summary Enable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTerminationOnLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTerminationOnLoraDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a LoRa device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFromLoraDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified LoRa device.
         * @summary Get LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoraDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLoraDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified LoRa device.
         * @summary Bulk Insert or Update LoRa device Tags.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLoraDeviceTags(deviceId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a LoRa device.
         * @summary Register LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerLoraDevice(deviceId, loraDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a LoRa device.
         * @param {string} deviceId ID of the recipient device.
         * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDataToLoraDevice(deviceId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites a group for the specified LoRa device.
         * @summary Set Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLoraDeviceGroup(deviceId: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLoraDeviceGroup(deviceId, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified LoRa device
         * @summary Terminate LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateLoraDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateLoraDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the group configuration from the specified LoRa device.
         * @summary Unset Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetLoraDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetLoraDeviceGroup(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoraDeviceApi - factory interface
 * @export
 */
export const LoraDeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoraDeviceApiFp(configuration)
    return {
        /**
         * Deletes a tag from the specified LoRa device.
         * @summary Delete LoRa device Tag.
         * @param {string} deviceId device ID of the target LoRa device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLoraDeviceTag(deviceId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of specified LoRa device.
         * @summary Disable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.disableTerminationOnLoraDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified LoRa device.
         * @summary Enable Termination of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.enableTerminationOnLoraDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a LoRa device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataFromLoraDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified LoRa device.
         * @summary Get LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.getLoraDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraDevice>> {
            return localVarFp.listLoraDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified LoRa device.
         * @summary Bulk Insert or Update LoRa device Tags.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.putLoraDeviceTags(deviceId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a LoRa device.
         * @summary Register LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.registerLoraDevice(deviceId, loraDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a LoRa device.
         * @param {string} deviceId ID of the recipient device.
         * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): AxiosPromise<void> {
            return localVarFp.sendDataToLoraDevice(deviceId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites a group for the specified LoRa device.
         * @summary Set Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLoraDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.setLoraDeviceGroup(deviceId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified LoRa device
         * @summary Terminate LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.terminateLoraDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group configuration from the specified LoRa device.
         * @summary Unset Group of LoRa device.
         * @param {string} deviceId Device ID of the target LoRa device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetLoraDeviceGroup(deviceId: string, options?: any): AxiosPromise<LoraDevice> {
            return localVarFp.unsetLoraDeviceGroup(deviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoraDeviceApi - interface
 * @export
 * @interface LoraDeviceApi
 */
export interface LoraDeviceApiInterface {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    disableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    enableTerminationOnLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    getLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraDevice>>;

    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any): AxiosPromise<void>;

    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    setLoraDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    terminateLoraDevice(deviceId: string, options?: any): AxiosPromise<LoraDevice>;

    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApiInterface
     */
    unsetLoraDeviceGroup(deviceId: string, options?: any): AxiosPromise<LoraDevice>;

}

/**
 * LoraDeviceApi - object-oriented interface
 * @export
 * @class LoraDeviceApi
 * @extends {BaseAPI}
 */
export class LoraDeviceApi extends BaseAPI implements LoraDeviceApiInterface {
    /**
     * Deletes a tag from the specified LoRa device.
     * @summary Delete LoRa device Tag.
     * @param {string} deviceId device ID of the target LoRa device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public deleteLoraDeviceTag(deviceId: string, tagName: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).deleteLoraDeviceTag(deviceId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of specified LoRa device.
     * @summary Disable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public disableTerminationOnLoraDevice(deviceId: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).disableTerminationOnLoraDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified LoRa device.
     * @summary Enable Termination of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public enableTerminationOnLoraDevice(deviceId: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).enableTerminationOnLoraDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a LoRa device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a LoRa device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public getDataFromLoraDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).getDataFromLoraDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified LoRa device.
     * @summary Get LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public getLoraDevice(deviceId: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).getLoraDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of LoRa devices that match certain criteria. If the total number of LoRa devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public listLoraDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).listLoraDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified LoRa device.
     * @summary Bulk Insert or Update LoRa device Tags.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public putLoraDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return LoraDeviceApiFp(this.configuration).putLoraDeviceTags(deviceId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a LoRa device.
     * @summary Register LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {RegisterLoraDeviceRequest} loraDevice LoRa device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public registerLoraDevice(deviceId: string, loraDevice: RegisterLoraDeviceRequest, options?: any) {
        return LoraDeviceApiFp(this.configuration).registerLoraDevice(deviceId, loraDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends data to the specified LoRa device. The data is sent to the LoRa network server, to be sent out to the device using the next available slot. If another message destined for the same LoRa device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a LoRa device.
     * @param {string} deviceId ID of the recipient device.
     * @param {LoraData} data Binary data encoded as a hexadecimal string. Maximum length of original binary data is 11 octets (22 characters when encoded as a hexadecimal string). The number of characters must be even. fPort MUST be equal to or greater than 0. 0 is used for the control plane and 1 or greater values should be used in general. It defaults to 2 to avoid the issues of some devices from some vendors and all invalid values that can not be parsed fallback to 2.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public sendDataToLoraDevice(deviceId: string, data: LoraData, options?: any) {
        return LoraDeviceApiFp(this.configuration).sendDataToLoraDevice(deviceId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites a group for the specified LoRa device.
     * @summary Set Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public setLoraDeviceGroup(deviceId: string, group: Group, options?: any) {
        return LoraDeviceApiFp(this.configuration).setLoraDeviceGroup(deviceId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified LoRa device
     * @summary Terminate LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public terminateLoraDevice(deviceId: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).terminateLoraDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group configuration from the specified LoRa device.
     * @summary Unset Group of LoRa device.
     * @param {string} deviceId Device ID of the target LoRa device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraDeviceApi
     */
    public unsetLoraDeviceGroup(deviceId: string, options?: any) {
        return LoraDeviceApiFp(this.configuration).unsetLoraDeviceGroup(deviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoraGatewayApi - axios parameter creator
 * @export
 */
export const LoraGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a tag from the specified LoRa gateway.
         * @summary Delete LoRa gateway tag.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraGatewayTag: async (gatewayId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('deleteLoraGatewayTag', 'gatewayId', gatewayId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteLoraGatewayTag', 'tagName', tagName)
            const localVarPath = `/lora_gateways/{gateway_id}/tags/{tag_name}`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of specified LoRa gateway.
         * @summary Disable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnLoraGateway: async (gatewayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('disableTerminationOnLoraGateway', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}/disable_termination`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified LoRa gateway.
         * @summary Enable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnLoraGateway: async (gatewayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('enableTerminationOnLoraGateway', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}/enable_termination`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified LoRa gateway.
         * @summary Get LoRa gateway.
         * @param {string} gatewayId Gateway ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraGateway: async (gatewayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('getLoraGateway', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraGateways: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lora_gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified LoRa gateway.
         * @summary Bulk Insert or Update LoRa gateway Tags.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraGatewayTags: async (gatewayId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('putLoraGatewayTags', 'gatewayId', gatewayId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putLoraGatewayTags', 'tags', tags)
            const localVarPath = `/lora_gateways/{gateway_id}/tags`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites network set ID for the specified LoRa gateway.
         * @summary Set Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLoraNetworkSet: async (gatewayId: string, nsId?: SetNetworkSetRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('setLoraNetworkSet', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}/set_network_set`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nsId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified LoRa gateway
         * @summary Terminate LoRa gateway.
         * @param {string} gatewayId Device ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLoraGateway: async (gatewayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('terminateLoraGateway', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}/terminate`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unset network set ID of the specified LoRa gateway.
         * @summary Unset Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetLoraNetworkSet: async (gatewayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayId' is not null or undefined
            assertParamExists('unsetLoraNetworkSet', 'gatewayId', gatewayId)
            const localVarPath = `/lora_gateways/{gateway_id}/unset_network_set`
                .replace(`{${"gateway_id"}}`, encodeURIComponent(String(gatewayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoraGatewayApi - functional programming interface
 * @export
 */
export const LoraGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoraGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a tag from the specified LoRa gateway.
         * @summary Delete LoRa gateway tag.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoraGatewayTag(gatewayId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of specified LoRa gateway.
         * @summary Disable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTerminationOnLoraGateway(gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified LoRa gateway.
         * @summary Enable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTerminationOnLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTerminationOnLoraGateway(gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified LoRa gateway.
         * @summary Get LoRa gateway.
         * @param {string} gatewayId Gateway ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoraGateway(gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraGateway>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLoraGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified LoRa gateway.
         * @summary Bulk Insert or Update LoRa gateway Tags.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLoraGatewayTags(gatewayId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites network set ID for the specified LoRa gateway.
         * @summary Set Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLoraNetworkSet(gatewayId, nsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified LoRa gateway
         * @summary Terminate LoRa gateway.
         * @param {string} gatewayId Device ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateLoraGateway(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateLoraGateway(gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unset network set ID of the specified LoRa gateway.
         * @summary Unset Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetLoraNetworkSet(gatewayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetLoraNetworkSet(gatewayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoraGatewayApi - factory interface
 * @export
 */
export const LoraGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoraGatewayApiFp(configuration)
    return {
        /**
         * Deletes a tag from the specified LoRa gateway.
         * @summary Delete LoRa gateway tag.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLoraGatewayTag(gatewayId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of specified LoRa gateway.
         * @summary Disable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.disableTerminationOnLoraGateway(gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified LoRa gateway.
         * @summary Enable Termination of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.enableTerminationOnLoraGateway(gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified LoRa gateway.
         * @summary Get LoRa gateway.
         * @param {string} gatewayId Gateway ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.getLoraGateway(gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>> {
            return localVarFp.listLoraGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified LoRa gateway.
         * @summary Bulk Insert or Update LoRa gateway Tags.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.putLoraGatewayTags(gatewayId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites network set ID for the specified LoRa gateway.
         * @summary Set Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.setLoraNetworkSet(gatewayId, nsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified LoRa gateway
         * @summary Terminate LoRa gateway.
         * @param {string} gatewayId Device ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.terminateLoraGateway(gatewayId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unset network set ID of the specified LoRa gateway.
         * @summary Unset Network Set ID of LoRa gateway.
         * @param {string} gatewayId ID of the target LoRa gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetLoraNetworkSet(gatewayId: string, options?: any): AxiosPromise<LoraGateway> {
            return localVarFp.unsetLoraNetworkSet(gatewayId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoraGatewayApi - interface
 * @export
 * @interface LoraGatewayApi
 */
export interface LoraGatewayApiInterface {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    disableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    enableTerminationOnLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    getLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;

    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    terminateLoraGateway(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;

    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApiInterface
     */
    unsetLoraNetworkSet(gatewayId: string, options?: any): AxiosPromise<LoraGateway>;

}

/**
 * LoraGatewayApi - object-oriented interface
 * @export
 * @class LoraGatewayApi
 * @extends {BaseAPI}
 */
export class LoraGatewayApi extends BaseAPI implements LoraGatewayApiInterface {
    /**
     * Deletes a tag from the specified LoRa gateway.
     * @summary Delete LoRa gateway tag.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public deleteLoraGatewayTag(gatewayId: string, tagName: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).deleteLoraGatewayTag(gatewayId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of specified LoRa gateway.
     * @summary Disable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public disableTerminationOnLoraGateway(gatewayId: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).disableTerminationOnLoraGateway(gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified LoRa gateway.
     * @summary Enable Termination of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public enableTerminationOnLoraGateway(gatewayId: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).enableTerminationOnLoraGateway(gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified LoRa gateway.
     * @summary Get LoRa gateway.
     * @param {string} gatewayId Gateway ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public getLoraGateway(gatewayId: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).getLoraGateway(gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of LoRa gateways that match certain criteria. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public listLoraGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).listLoraGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified LoRa gateway.
     * @summary Bulk Insert or Update LoRa gateway Tags.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public putLoraGatewayTags(gatewayId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return LoraGatewayApiFp(this.configuration).putLoraGatewayTags(gatewayId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites network set ID for the specified LoRa gateway.
     * @summary Set Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {SetNetworkSetRequest} [nsId] LoRa Network Set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public setLoraNetworkSet(gatewayId: string, nsId?: SetNetworkSetRequest, options?: any) {
        return LoraGatewayApiFp(this.configuration).setLoraNetworkSet(gatewayId, nsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified LoRa gateway
     * @summary Terminate LoRa gateway.
     * @param {string} gatewayId Device ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public terminateLoraGateway(gatewayId: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).terminateLoraGateway(gatewayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unset network set ID of the specified LoRa gateway.
     * @summary Unset Network Set ID of LoRa gateway.
     * @param {string} gatewayId ID of the target LoRa gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraGatewayApi
     */
    public unsetLoraNetworkSet(gatewayId: string, options?: any) {
        return LoraGatewayApiFp(this.configuration).unsetLoraNetworkSet(gatewayId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoraNetworkSetApi - axios parameter creator
 * @export
 */
export const LoraNetworkSetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds permission to allow another operator to use the network set.
         * @summary Adds permission to a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToLoraNetworkSet: async (nsId: string, operatorId: UpdatePermissionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('addPermissionToLoraNetworkSet', 'nsId', nsId)
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('addPermissionToLoraNetworkSet', 'operatorId', operatorId)
            const localVarPath = `/lora_network_sets/{ns_id}/add_permission`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operatorId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a specified LoRa network set
         * @summary Create a LoRa network set.
         * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoraNetworkSet: async (loraNetworkSet: LoraNetworkSet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loraNetworkSet' is not null or undefined
            assertParamExists('createLoraNetworkSet', 'loraNetworkSet', loraNetworkSet)
            const localVarPath = `/lora_network_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loraNetworkSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified LoRa network set
         * @summary Delete LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraNetworkSet: async (nsId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('deleteLoraNetworkSet', 'nsId', nsId)
            const localVarPath = `/lora_network_sets/{ns_id}`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tag from the specified LoRa network set.
         * @summary Delete LoRa network set tag.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraNetworkSetTag: async (nsId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('deleteLoraNetworkSetTag', 'nsId', nsId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteLoraNetworkSetTag', 'tagName', tagName)
            const localVarPath = `/lora_network_sets/{ns_id}/tags/{tag_name}`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified LoRa network set.
         * @summary Get LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraNetworkSet: async (nsId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('getLoraNetworkSet', 'nsId', nsId)
            const localVarPath = `/lora_network_sets/{ns_id}`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways in a Network Set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewaysInLoraNetworkSet: async (nsId: string, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('listGatewaysInLoraNetworkSet', 'nsId', nsId)
            const localVarPath = `/lora_network_sets/{ns_id}/gateways`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Network Sets.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraNetworkSets: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lora_network_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified LoRa network set.
         * @summary Bulk Insert or Update LoRa network set tags.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraNetworkSetTags: async (nsId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('putLoraNetworkSetTags', 'nsId', nsId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putLoraNetworkSetTags', 'tags', tags)
            const localVarPath = `/lora_network_sets/{ns_id}/tags`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a permission and removes an operator from the list of allowed operators in the network set.
         * @summary Revokes a permission from a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionFromLoraNetworkSet: async (nsId: string, operatorId: UpdatePermissionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nsId' is not null or undefined
            assertParamExists('revokePermissionFromLoraNetworkSet', 'nsId', nsId)
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('revokePermissionFromLoraNetworkSet', 'operatorId', operatorId)
            const localVarPath = `/lora_network_sets/{ns_id}/revoke_permission`
                .replace(`{${"ns_id"}}`, encodeURIComponent(String(nsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operatorId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoraNetworkSetApi - functional programming interface
 * @export
 */
export const LoraNetworkSetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoraNetworkSetApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds permission to allow another operator to use the network set.
         * @summary Adds permission to a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionToLoraNetworkSet(nsId, operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a specified LoRa network set
         * @summary Create a LoRa network set.
         * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLoraNetworkSet(loraNetworkSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified LoRa network set
         * @summary Delete LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoraNetworkSet(nsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoraNetworkSet(nsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a tag from the specified LoRa network set.
         * @summary Delete LoRa network set tag.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoraNetworkSetTag(nsId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified LoRa network set.
         * @summary Get LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoraNetworkSet(nsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoraNetworkSet(nsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways in a Network Set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraGateway>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGatewaysInLoraNetworkSet(nsId, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Network Sets.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoraNetworkSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLoraNetworkSets(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified LoRa network set.
         * @summary Bulk Insert or Update LoRa network set tags.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLoraNetworkSetTags(nsId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revokes a permission and removes an operator from the list of allowed operators in the network set.
         * @summary Revokes a permission from a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoraNetworkSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePermissionFromLoraNetworkSet(nsId, operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoraNetworkSetApi - factory interface
 * @export
 */
export const LoraNetworkSetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoraNetworkSetApiFp(configuration)
    return {
        /**
         * Adds permission to allow another operator to use the network set.
         * @summary Adds permission to a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet> {
            return localVarFp.addPermissionToLoraNetworkSet(nsId, operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a specified LoRa network set
         * @summary Create a LoRa network set.
         * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): AxiosPromise<LoraNetworkSet> {
            return localVarFp.createLoraNetworkSet(loraNetworkSet, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified LoRa network set
         * @summary Delete LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraNetworkSet(nsId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLoraNetworkSet(nsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tag from the specified LoRa network set.
         * @summary Delete LoRa network set tag.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLoraNetworkSetTag(nsId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified LoRa network set.
         * @summary Get LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoraNetworkSet(nsId: string, options?: any): AxiosPromise<LoraNetworkSet> {
            return localVarFp.getLoraNetworkSet(nsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Gateways in a Network Set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>> {
            return localVarFp.listGatewaysInLoraNetworkSet(nsId, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List LoRa Network Sets.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of LoRa devices to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraNetworkSet>> {
            return localVarFp.listLoraNetworkSets(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified LoRa network set.
         * @summary Bulk Insert or Update LoRa network set tags.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraNetworkSet> {
            return localVarFp.putLoraNetworkSetTags(nsId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a permission and removes an operator from the list of allowed operators in the network set.
         * @summary Revokes a permission from a LoRa network set.
         * @param {string} nsId ID of the target LoRa network set.
         * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet> {
            return localVarFp.revokePermissionFromLoraNetworkSet(nsId, operatorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoraNetworkSetApi - interface
 * @export
 * @interface LoraNetworkSetApi
 */
export interface LoraNetworkSetApiInterface {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;

    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any): AxiosPromise<LoraNetworkSet>;

    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    deleteLoraNetworkSet(nsId: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    getLoraNetworkSet(nsId: string, options?: any): AxiosPromise<LoraNetworkSet>;

    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraGateway>>;

    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<LoraNetworkSet>>;

    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<LoraNetworkSet>;

    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApiInterface
     */
    revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any): AxiosPromise<LoraNetworkSet>;

}

/**
 * LoraNetworkSetApi - object-oriented interface
 * @export
 * @class LoraNetworkSetApi
 * @extends {BaseAPI}
 */
export class LoraNetworkSetApi extends BaseAPI implements LoraNetworkSetApiInterface {
    /**
     * Adds permission to allow another operator to use the network set.
     * @summary Adds permission to a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public addPermissionToLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).addPermissionToLoraNetworkSet(nsId, operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a specified LoRa network set
     * @summary Create a LoRa network set.
     * @param {LoraNetworkSet} loraNetworkSet Additional metadata such as tags for a LoRa network set to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public createLoraNetworkSet(loraNetworkSet: LoraNetworkSet, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).createLoraNetworkSet(loraNetworkSet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified LoRa network set
     * @summary Delete LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public deleteLoraNetworkSet(nsId: string, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).deleteLoraNetworkSet(nsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tag from the specified LoRa network set.
     * @summary Delete LoRa network set tag.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {string} tagName Name of tag to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public deleteLoraNetworkSetTag(nsId: string, tagName: string, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).deleteLoraNetworkSetTag(nsId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified LoRa network set.
     * @summary Get LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public getLoraNetworkSet(nsId: string, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).getLoraNetworkSet(nsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of LoRa gateways that belong to the specified network set. If the total number of LoRa gateways does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Gateways in a Network Set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {number} [limit] Maximum number of LoRa gateways to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last gateway retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public listGatewaysInLoraNetworkSet(nsId: string, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).listGatewaysInLoraNetworkSet(nsId, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of LoRa network sets that match certain criteria. If the total number of LoRa network sets does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List LoRa Network Sets.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of LoRa devices to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last network set retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public listLoraNetworkSets(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).listLoraNetworkSets(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified LoRa network set.
     * @summary Bulk Insert or Update LoRa network set tags.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public putLoraNetworkSetTags(nsId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).putLoraNetworkSetTags(nsId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a permission and removes an operator from the list of allowed operators in the network set.
     * @summary Revokes a permission from a LoRa network set.
     * @param {string} nsId ID of the target LoRa network set.
     * @param {UpdatePermissionRequest} operatorId ID of the operator to be added to the list of allowed operators.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoraNetworkSetApi
     */
    public revokePermissionFromLoraNetworkSet(nsId: string, operatorId: UpdatePermissionRequest, options?: any) {
        return LoraNetworkSetApiFp(this.configuration).revokePermissionFromLoraNetworkSet(nsId, operatorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OperatorApi - axios parameter creator
 * @export
 */
export const OperatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the operator\'s coverage type.
         * @summary Add coverage type.
         * @param {string} operatorId operator_id
         * @param {string} coverageType coverage_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCoverageType: async (operatorId: string, coverageType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('addCoverageType', 'operatorId', operatorId)
            // verify required parameter 'coverageType' is not null or undefined
            assertParamExists('addCoverageType', 'coverageType', coverageType)
            const localVarPath = `/operators/{operator_id}/coverage_type/{coverage_type}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"coverage_type"}}`, encodeURIComponent(String(coverageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the operator\'s contract.
         * @summary Add Operator Contract.
         * @param {string} operatorId operator_id
         * @param {ContractUpdatingRequest} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperatorContract: async (operatorId: string, request: ContractUpdatingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('addOperatorContract', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addOperatorContract', 'request', request)
            const localVarPath = `/operators/{operator_id}/contracts`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates the operator\'s company information.
         * @summary Create company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyInformation: async (operatorId: string, request: CompanyInformationModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createCompanyInformation', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createCompanyInformation', 'request', request)
            const localVarPath = `/operators/{operator_id}/company_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates the operator\'s individual information.
         * @summary Create individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndividualInformation: async (operatorId: string, request: IndividualInformationModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createIndividualInformation', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createIndividualInformation', 'request', request)
            const localVarPath = `/operators/{operator_id}/individual_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
         * @summary Create Operator.
         * @param {RegisterOperatorsRequest} request email, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperator: async (request: RegisterOperatorsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createOperator', 'request', request)
            const localVarPath = `/operators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an AuthKey from the operator.
         * @summary Delete Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorAuthKey: async (operatorId: string, authKeyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteOperatorAuthKey', 'operatorId', operatorId)
            // verify required parameter 'authKeyId' is not null or undefined
            assertParamExists('deleteOperatorAuthKey', 'authKeyId', authKeyId)
            const localVarPath = `/operators/{operator_id}/auth_keys/{auth_key_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"auth_key_id"}}`, encodeURIComponent(String(authKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the operator\'s contract.
         * @summary Delete Operator Contract.
         * @param {string} operatorId operator_id
         * @param {string} contractName contract_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorContract: async (operatorId: string, contractName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteOperatorContract', 'operatorId', operatorId)
            // verify required parameter 'contractName' is not null or undefined
            assertParamExists('deleteOperatorContract', 'contractName', contractName)
            const localVarPath = `/operators/{operator_id}/contracts/{contract_name}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"contract_name"}}`, encodeURIComponent(String(contractName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
         * @summary Enable Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('enableMFA', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
         * @summary Generate Authentication Token.
         * @param {string} operatorId operator_id
         * @param {GenerateTokenRequest} request token timeout seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAuthToken: async (operatorId: string, request: GenerateTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('generateAuthToken', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('generateAuthToken', 'request', request)
            const localVarPath = `/operators/{operator_id}/token`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an AuthKey for the operator.
         * @summary Generate Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOperatorAuthKey: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('generateOperatorAuthKey', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/auth_keys`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a token for accessing the support console.
         * @summary Generate Token for Support Console.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSupportToken: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('generateSupportToken', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/support/token`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the operator\'s company information.
         * @summary Get company information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyInformation: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getCompanyInformation', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/company_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the operator\'s individual information.
         * @summary Get individual information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualInformation: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getIndividualInformation', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/individual_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
         * @summary Get Operator\'s MFA Status.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMFAStatus: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getMFAStatus', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the operator.
         * @summary Get Operator.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperator: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getOperator', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an e-mail with a one-time token for executing the e-mail address change.
         * @summary Issue Email Change Token.
         * @param {IssueEmailChangeTokenRequest} request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEmailChangeToken: async (request: IssueEmailChangeTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueEmailChangeToken', 'request', request)
            const localVarPath = `/operators/email_change_token/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
         * @summary Issue Operator\'s MFA Revoke Token.
         * @param {MFAIssueRevokingTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueMFARevokingToken: async (request: MFAIssueRevokingTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueMFARevokingToken', 'request', request)
            const localVarPath = `/operators/mfa_revoke_token/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the operator\'s AuthKey list.
         * @summary List Operator AuthKeys.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperatorAuthKeys: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listOperatorAuthKeys', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/auth_keys`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes operator\'s MFA without backup codes.
         * @summary Revoke Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMFA: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('revokeMFA', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the operator\'s company information.
         * @summary Update company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyInformation: async (operatorId: string, request: CompanyInformationModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateCompanyInformation', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateCompanyInformation', 'request', request)
            const localVarPath = `/operators/{operator_id}/company_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the operator\'s individual information.
         * @summary Update individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIndividualInformation: async (operatorId: string, request: IndividualInformationModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateIndividualInformation', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateIndividualInformation', 'request', request)
            const localVarPath = `/operators/{operator_id}/individual_information`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the operator\'s password.
         * @summary Update Operator Password.
         * @param {string} operatorId operator_id
         * @param {UpdatePasswordRequest} request current password, new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperatorPassword: async (operatorId: string, request: UpdatePasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateOperatorPassword', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateOperatorPassword', 'request', request)
            const localVarPath = `/operators/{operator_id}/password`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the token for the e-mail address change, and then changes the e-mail address.
         * @summary Verify Email Change Token.
         * @param {VerifyEmailChangeTokenRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailChangeToken: async (token: VerifyEmailChangeTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmailChangeToken', 'token', token)
            const localVarPath = `/operators/email_change_token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(token, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
         * @summary Verify Operator\'s MFA OTP Code.
         * @param {string} operatorId operator_id
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMFA: async (operatorId: string, request: MFAAuthenticationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('verifyMFA', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verifyMFA', 'request', request)
            const localVarPath = `/operators/{operator_id}/mfa/verify`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
         * @summary Verify Operator\'s MFA revoke token.
         * @param {MFARevokingTokenVerifyRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMFARevokingToken: async (request: MFARevokingTokenVerifyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verifyMFARevokingToken', 'request', request)
            const localVarPath = `/operators/mfa_revoke_token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
         * @summary Verify Operator.
         * @param {VerifyOperatorsRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOperator: async (token: VerifyOperatorsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyOperator', 'token', token)
            const localVarPath = `/operators/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(token, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperatorApi - functional programming interface
 * @export
 */
export const OperatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperatorApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the operator\'s coverage type.
         * @summary Add coverage type.
         * @param {string} operatorId operator_id
         * @param {string} coverageType coverage_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCoverageType(operatorId: string, coverageType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCoverageType(operatorId, coverageType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds the operator\'s contract.
         * @summary Add Operator Contract.
         * @param {string} operatorId operator_id
         * @param {ContractUpdatingRequest} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUpdatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOperatorContract(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates the operator\'s company information.
         * @summary Create company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompanyInformation(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates the operator\'s individual information.
         * @summary Create individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIndividualInformation(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
         * @summary Create Operator.
         * @param {RegisterOperatorsRequest} request email, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOperator(request: RegisterOperatorsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOperator(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an AuthKey from the operator.
         * @summary Delete Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperatorAuthKey(operatorId, authKeyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the operator\'s contract.
         * @summary Delete Operator Contract.
         * @param {string} operatorId operator_id
         * @param {string} contractName contract_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperatorContract(operatorId: string, contractName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperatorContract(operatorId, contractName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
         * @summary Enable Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMFA(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMFAOTPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMFA(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
         * @summary Generate Authentication Token.
         * @param {string} operatorId operator_id
         * @param {GenerateTokenRequest} request token timeout seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAuthToken(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates an AuthKey for the operator.
         * @summary Generate Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateOperatorAuthKey(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateOperatorsAuthKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOperatorAuthKey(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a token for accessing the support console.
         * @summary Generate Token for Support Console.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSupportToken(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSupportToken(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the operator\'s company information.
         * @summary Get company information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyInformation(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyInformationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyInformation(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the operator\'s individual information.
         * @summary Get individual information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualInformation(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndividualInformationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualInformation(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
         * @summary Get Operator\'s MFA Status.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMFAStatus(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MFAStatusOfUseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMFAStatus(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the operator.
         * @summary Get Operator.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperator(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOperatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperator(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an e-mail with a one-time token for executing the e-mail address change.
         * @summary Issue Email Change Token.
         * @param {IssueEmailChangeTokenRequest} request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEmailChangeToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
         * @summary Issue Operator\'s MFA Revoke Token.
         * @param {MFAIssueRevokingTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueMFARevokingToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the operator\'s AuthKey list.
         * @summary List Operator AuthKeys.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOperatorAuthKeys(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOperatorAuthKeys(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revokes operator\'s MFA without backup codes.
         * @summary Revoke Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeMFA(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeMFA(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the operator\'s company information.
         * @summary Update company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyInformation(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the operator\'s individual information.
         * @summary Update individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIndividualInformation(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the operator\'s password.
         * @summary Update Operator Password.
         * @param {string} operatorId operator_id
         * @param {UpdatePasswordRequest} request current password, new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperatorPassword(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the token for the e-mail address change, and then changes the e-mail address.
         * @summary Verify Email Change Token.
         * @param {VerifyEmailChangeTokenRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailChangeToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
         * @summary Verify Operator\'s MFA OTP Code.
         * @param {string} operatorId operator_id
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperatorMFAVerifyingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMFA(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
         * @summary Verify Operator\'s MFA revoke token.
         * @param {MFARevokingTokenVerifyRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMFARevokingToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
         * @summary Verify Operator.
         * @param {VerifyOperatorsRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOperator(token: VerifyOperatorsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOperator(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OperatorApi - factory interface
 * @export
 */
export const OperatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperatorApiFp(configuration)
    return {
        /**
         * Adds the operator\'s coverage type.
         * @summary Add coverage type.
         * @param {string} operatorId operator_id
         * @param {string} coverageType coverage_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCoverageType(operatorId: string, coverageType: string, options?: any): AxiosPromise<void> {
            return localVarFp.addCoverageType(operatorId, coverageType, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the operator\'s contract.
         * @summary Add Operator Contract.
         * @param {string} operatorId operator_id
         * @param {ContractUpdatingRequest} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): AxiosPromise<ContractUpdatedResponse> {
            return localVarFp.addOperatorContract(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates the operator\'s company information.
         * @summary Create company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void> {
            return localVarFp.createCompanyInformation(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates the operator\'s individual information.
         * @summary Create individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void> {
            return localVarFp.createIndividualInformation(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
         * @summary Create Operator.
         * @param {RegisterOperatorsRequest} request email, password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperator(request: RegisterOperatorsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOperator(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an AuthKey from the operator.
         * @summary Delete Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOperatorAuthKey(operatorId, authKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the operator\'s contract.
         * @summary Delete Operator Contract.
         * @param {string} operatorId operator_id
         * @param {string} contractName contract_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorContract(operatorId: string, contractName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOperatorContract(operatorId, contractName, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
         * @summary Enable Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMFA(operatorId: string, options?: any): AxiosPromise<EnableMFAOTPResponse> {
            return localVarFp.enableMFA(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
         * @summary Generate Authentication Token.
         * @param {string} operatorId operator_id
         * @param {GenerateTokenRequest} request token timeout seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): AxiosPromise<GenerateTokenResponse> {
            return localVarFp.generateAuthToken(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an AuthKey for the operator.
         * @summary Generate Operator AuthKey.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOperatorAuthKey(operatorId: string, options?: any): AxiosPromise<GenerateOperatorsAuthKeyResponse> {
            return localVarFp.generateOperatorAuthKey(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a token for accessing the support console.
         * @summary Generate Token for Support Console.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSupportToken(operatorId: string, options?: any): AxiosPromise<SupportTokenResponse> {
            return localVarFp.generateSupportToken(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the operator\'s company information.
         * @summary Get company information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyInformation(operatorId: string, options?: any): AxiosPromise<CompanyInformationModel> {
            return localVarFp.getCompanyInformation(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the operator\'s individual information.
         * @summary Get individual information.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualInformation(operatorId: string, options?: any): AxiosPromise<IndividualInformationModel> {
            return localVarFp.getIndividualInformation(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
         * @summary Get Operator\'s MFA Status.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMFAStatus(operatorId: string, options?: any): AxiosPromise<MFAStatusOfUseResponse> {
            return localVarFp.getMFAStatus(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the operator.
         * @summary Get Operator.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperator(operatorId: string, options?: any): AxiosPromise<GetOperatorResponse> {
            return localVarFp.getOperator(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an e-mail with a one-time token for executing the e-mail address change.
         * @summary Issue Email Change Token.
         * @param {IssueEmailChangeTokenRequest} request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.issueEmailChangeToken(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
         * @summary Issue Operator\'s MFA Revoke Token.
         * @param {MFAIssueRevokingTokenRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.issueMFARevokingToken(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the operator\'s AuthKey list.
         * @summary List Operator AuthKeys.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperatorAuthKeys(operatorId: string, options?: any): AxiosPromise<Array<AuthKeyResponse>> {
            return localVarFp.listOperatorAuthKeys(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes operator\'s MFA without backup codes.
         * @summary Revoke Operator\'s MFA.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMFA(operatorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeMFA(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the operator\'s company information.
         * @summary Update company information.
         * @param {string} operatorId operator_id
         * @param {CompanyInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateCompanyInformation(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the operator\'s individual information.
         * @summary Update individual information.
         * @param {string} operatorId operator_id
         * @param {IndividualInformationModel} request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateIndividualInformation(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the operator\'s password.
         * @summary Update Operator Password.
         * @param {string} operatorId operator_id
         * @param {UpdatePasswordRequest} request current password, new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateOperatorPassword(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the token for the e-mail address change, and then changes the e-mail address.
         * @summary Verify Email Change Token.
         * @param {VerifyEmailChangeTokenRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyEmailChangeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
         * @summary Verify Operator\'s MFA OTP Code.
         * @param {string} operatorId operator_id
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<OperatorMFAVerifyingResponse> {
            return localVarFp.verifyMFA(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
         * @summary Verify Operator\'s MFA revoke token.
         * @param {MFARevokingTokenVerifyRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyMFARevokingToken(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
         * @summary Verify Operator.
         * @param {VerifyOperatorsRequest} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOperator(token: VerifyOperatorsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyOperator(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperatorApi - interface
 * @export
 * @interface OperatorApi
 */
export interface OperatorApiInterface {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    addCoverageType(operatorId: string, coverageType: string, options?: any): AxiosPromise<void>;

    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any): AxiosPromise<ContractUpdatedResponse>;

    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;

    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;

    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    createOperator(request: RegisterOperatorsRequest, options?: any): AxiosPromise<void>;

    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    deleteOperatorContract(operatorId: string, contractName: string, options?: any): AxiosPromise<void>;

    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    enableMFA(operatorId: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;

    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any): AxiosPromise<GenerateTokenResponse>;

    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateOperatorAuthKey(operatorId: string, options?: any): AxiosPromise<GenerateOperatorsAuthKeyResponse>;

    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    generateSupportToken(operatorId: string, options?: any): AxiosPromise<SupportTokenResponse>;

    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getCompanyInformation(operatorId: string, options?: any): AxiosPromise<CompanyInformationModel>;

    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getIndividualInformation(operatorId: string, options?: any): AxiosPromise<IndividualInformationModel>;

    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getMFAStatus(operatorId: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;

    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    getOperator(operatorId: string, options?: any): AxiosPromise<GetOperatorResponse>;

    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any): AxiosPromise<void>;

    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any): AxiosPromise<void>;

    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    listOperatorAuthKeys(operatorId: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;

    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    revokeMFA(operatorId: string, options?: any): AxiosPromise<void>;

    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any): AxiosPromise<void>;

    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any): AxiosPromise<void>;

    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;

    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any): AxiosPromise<void>;

    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<OperatorMFAVerifyingResponse>;

    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any): AxiosPromise<void>;

    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApiInterface
     */
    verifyOperator(token: VerifyOperatorsRequest, options?: any): AxiosPromise<void>;

}

/**
 * OperatorApi - object-oriented interface
 * @export
 * @class OperatorApi
 * @extends {BaseAPI}
 */
export class OperatorApi extends BaseAPI implements OperatorApiInterface {
    /**
     * Adds the operator\'s coverage type.
     * @summary Add coverage type.
     * @param {string} operatorId operator_id
     * @param {string} coverageType coverage_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public addCoverageType(operatorId: string, coverageType: string, options?: any) {
        return OperatorApiFp(this.configuration).addCoverageType(operatorId, coverageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the operator\'s contract.
     * @summary Add Operator Contract.
     * @param {string} operatorId operator_id
     * @param {ContractUpdatingRequest} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public addOperatorContract(operatorId: string, request: ContractUpdatingRequest, options?: any) {
        return OperatorApiFp(this.configuration).addOperatorContract(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates the operator\'s company information.
     * @summary Create company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public createCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any) {
        return OperatorApiFp(this.configuration).createCompanyInformation(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates the operator\'s individual information.
     * @summary Create individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public createIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any) {
        return OperatorApiFp(this.configuration).createIndividualInformation(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes a request to create a new operator. An e-mail is sent to the e-mail address specified in the parameters, containing a one-time token for verifying the operator’s registration.
     * @summary Create Operator.
     * @param {RegisterOperatorsRequest} request email, password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public createOperator(request: RegisterOperatorsRequest, options?: any) {
        return OperatorApiFp(this.configuration).createOperator(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an AuthKey from the operator.
     * @summary Delete Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public deleteOperatorAuthKey(operatorId: string, authKeyId: string, options?: any) {
        return OperatorApiFp(this.configuration).deleteOperatorAuthKey(operatorId, authKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the operator\'s contract.
     * @summary Delete Operator Contract.
     * @param {string} operatorId operator_id
     * @param {string} contractName contract_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public deleteOperatorContract(operatorId: string, contractName: string, options?: any) {
        return OperatorApiFp(this.configuration).deleteOperatorContract(operatorId, contractName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables operator\'s MFA. After calling this APIg, it should be verified by calling `Operator:verifyMFA` API.
     * @summary Enable Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public enableMFA(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).enableMFA(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new API token. If you insert the current API token into the header and make a request, a response is returned containing the new API token. You can then use the new API token in future requests.
     * @summary Generate Authentication Token.
     * @param {string} operatorId operator_id
     * @param {GenerateTokenRequest} request token timeout seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public generateAuthToken(operatorId: string, request: GenerateTokenRequest, options?: any) {
        return OperatorApiFp(this.configuration).generateAuthToken(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an AuthKey for the operator.
     * @summary Generate Operator AuthKey.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public generateOperatorAuthKey(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).generateOperatorAuthKey(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a token for accessing the support console.
     * @summary Generate Token for Support Console.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public generateSupportToken(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).generateSupportToken(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the operator\'s company information.
     * @summary Get company information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getCompanyInformation(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).getCompanyInformation(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the operator\'s individual information.
     * @summary Get individual information.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getIndividualInformation(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).getIndividualInformation(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets operator\'s MFA status. The MFA status is one of `ACTIVE`, `INACTIVE` or `UNCONFIRMED`.
     * @summary Get Operator\'s MFA Status.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getMFAStatus(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).getMFAStatus(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the operator.
     * @summary Get Operator.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getOperator(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).getOperator(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an e-mail with a one-time token for executing the e-mail address change.
     * @summary Issue Email Change Token.
     * @param {IssueEmailChangeTokenRequest} request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public issueEmailChangeToken(request: IssueEmailChangeTokenRequest, options?: any) {
        return OperatorApiFp(this.configuration).issueEmailChangeToken(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issues a token to revoke operator\'s MFA. The issued token will be sent to the operator via email.
     * @summary Issue Operator\'s MFA Revoke Token.
     * @param {MFAIssueRevokingTokenRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public issueMFARevokingToken(request: MFAIssueRevokingTokenRequest, options?: any) {
        return OperatorApiFp(this.configuration).issueMFARevokingToken(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the operator\'s AuthKey list.
     * @summary List Operator AuthKeys.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public listOperatorAuthKeys(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).listOperatorAuthKeys(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes operator\'s MFA without backup codes.
     * @summary Revoke Operator\'s MFA.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public revokeMFA(operatorId: string, options?: any) {
        return OperatorApiFp(this.configuration).revokeMFA(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the operator\'s company information.
     * @summary Update company information.
     * @param {string} operatorId operator_id
     * @param {CompanyInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public updateCompanyInformation(operatorId: string, request: CompanyInformationModel, options?: any) {
        return OperatorApiFp(this.configuration).updateCompanyInformation(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the operator\'s individual information.
     * @summary Update individual information.
     * @param {string} operatorId operator_id
     * @param {IndividualInformationModel} request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public updateIndividualInformation(operatorId: string, request: IndividualInformationModel, options?: any) {
        return OperatorApiFp(this.configuration).updateIndividualInformation(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the operator\'s password.
     * @summary Update Operator Password.
     * @param {string} operatorId operator_id
     * @param {UpdatePasswordRequest} request current password, new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public updateOperatorPassword(operatorId: string, request: UpdatePasswordRequest, options?: any) {
        return OperatorApiFp(this.configuration).updateOperatorPassword(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the token for the e-mail address change, and then changes the e-mail address.
     * @summary Verify Email Change Token.
     * @param {VerifyEmailChangeTokenRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public verifyEmailChangeToken(token: VerifyEmailChangeTokenRequest, options?: any) {
        return OperatorApiFp(this.configuration).verifyEmailChangeToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies operator\'s MFA with OTP code after calling `Operator:enableMFA` API. MFA will not be activated unless the MFA OTP is verified with this API. Backup codes are going to be returned in the response. These codes must be securely stored.
     * @summary Verify Operator\'s MFA OTP Code.
     * @param {string} operatorId operator_id
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public verifyMFA(operatorId: string, request: MFAAuthenticationRequest, options?: any) {
        return OperatorApiFp(this.configuration).verifyMFA(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the one-time token which is previously issued by calling `/operators/mfa_revoke_token/issue` API, operator\'s email address, password, and one of the backup codes. If verified, operator\'s MFA is going to be revoked.
     * @summary Verify Operator\'s MFA revoke token.
     * @param {MFARevokingTokenVerifyRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public verifyMFARevokingToken(request: MFARevokingTokenVerifyRequest, options?: any) {
        return OperatorApiFp(this.configuration).verifyMFARevokingToken(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the operator\'s registration. Called by setting as parameter the one-time verification token received via e-mail.
     * @summary Verify Operator.
     * @param {VerifyOperatorsRequest} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public verifyOperator(token: VerifyOperatorsRequest, options?: any) {
        return OperatorApiFp(this.configuration).verifyOperator(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels an order. If the order has already been dispatched, an error is returned.
         * @summary Cancel order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId)
            const localVarPath = `/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm coupon order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCouponOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('confirmCouponOrder', 'orderId', orderId)
            const localVarPath = `/coupons/{order_id}/confirm`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('confirmOrder', 'orderId', orderId)
            const localVarPath = `/orders/{order_id}/confirm`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm long term discount order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmVolumeDiscountOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('confirmVolumeDiscountOrder', 'orderId', orderId)
            const localVarPath = `/volume_discounts/{order_id}/confirm`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create coupon quotation.
         * @param {CreateEstimatedCouponRequest} request Coupon details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCouponQuotation: async (request: CreateEstimatedCouponRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createCouponQuotation', 'request', request)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create Quotation.
         * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotation: async (request: CreateEstimatedOrderRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createQuotation', 'request', request)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
         * @summary Create long term discount quotation.
         * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolumeDiscountQuotation: async (request: CreateEstimatedVolumeDiscountRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createVolumeDiscountQuotation', 'request', request)
            const localVarPath = `/volume_discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a confirmed order.
         * @summary Get confirmed order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available long term discounts.
         * @summary List available long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableDiscounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volume_discounts/available_discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ordered subscribers
         * @summary List ordered subscribers.
         * @param {string} orderId order_id
         * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
         * @param {number} [limit] Max number of subscribers in a response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderedSubscribers: async (orderId: string, lastEvaluatedKey?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('listOrderedSubscribers', 'orderId', orderId)
            const localVarPath = `/orders/{order_id}/subscribers`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of confirmed orders.
         * @summary List confirmed orders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of products.
         * @summary List products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers the ordered SIM with the operator.
         * @summary Register subscribers for operator.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrderedSim: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('registerOrderedSim', 'orderId', orderId)
            const localVarPath = `/orders/{order_id}/subscribers/register`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels an order. If the order has already been dispatched, an error is returned.
         * @summary Cancel order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm coupon order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmCouponOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmCouponOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm long term discount order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmVolumeDiscountOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVolumeDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmVolumeDiscountOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create coupon quotation.
         * @param {CreateEstimatedCouponRequest} request Coupon details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedCouponModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCouponQuotation(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create Quotation.
         * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuotation(request: CreateEstimatedOrderRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedOrderModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuotation(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
         * @summary Create long term discount quotation.
         * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedVolumeDiscountModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolumeDiscountQuotation(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a confirmed order.
         * @summary Get confirmed order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of available long term discounts.
         * @summary List available long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableDiscounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableLongTermDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableDiscounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ordered subscribers
         * @summary List ordered subscribers.
         * @param {string} orderId order_id
         * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
         * @param {number} [limit] Max number of subscribers in a response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrderedSubscriberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrderedSubscribers(orderId, lastEvaluatedKey, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of confirmed orders.
         * @summary List confirmed orders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of products.
         * @summary List products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers the ordered SIM with the operator.
         * @summary Register subscribers for operator.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOrderedSim(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOrderedSim(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Cancels an order. If the order has already been dispatched, an error is returned.
         * @summary Cancel order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm coupon order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCouponOrder(orderId: string, options?: any): AxiosPromise<CouponResponse> {
            return localVarFp.confirmCouponOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrder(orderId: string, options?: any): AxiosPromise<string> {
            return localVarFp.confirmOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a credit limit and confirms the order if no problems are encountered.
         * @summary Confirm long term discount order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmVolumeDiscountOrder(orderId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse> {
            return localVarFp.confirmVolumeDiscountOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create coupon quotation.
         * @param {CreateEstimatedCouponRequest} request Coupon details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): AxiosPromise<EstimatedCouponModel> {
            return localVarFp.createCouponQuotation(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
         * @summary Create Quotation.
         * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotation(request: CreateEstimatedOrderRequest, options?: any): AxiosPromise<EstimatedOrderModel> {
            return localVarFp.createQuotation(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
         * @summary Create long term discount quotation.
         * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): AxiosPromise<EstimatedVolumeDiscountModel> {
            return localVarFp.createVolumeDiscountQuotation(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a confirmed order.
         * @summary Get confirmed order.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any): AxiosPromise<GetOrderResponse> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available long term discounts.
         * @summary List available long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableDiscounts(options?: any): AxiosPromise<AvailableLongTermDiscountResponse> {
            return localVarFp.listAvailableDiscounts(options).then((request) => request(axios, basePath));
        },
        /**
         * List ordered subscribers
         * @summary List ordered subscribers.
         * @param {string} orderId order_id
         * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
         * @param {number} [limit] Max number of subscribers in a response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<ListOrderedSubscriberResponse> {
            return localVarFp.listOrderedSubscribers(orderId, lastEvaluatedKey, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of confirmed orders.
         * @summary List confirmed orders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(options?: any): AxiosPromise<ListOrderResponse> {
            return localVarFp.listOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of products.
         * @summary List products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(options?: any): AxiosPromise<ListProductResponse> {
            return localVarFp.listProducts(options).then((request) => request(axios, basePath));
        },
        /**
         * Registers the ordered SIM with the operator.
         * @summary Register subscribers for operator.
         * @param {string} orderId order_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrderedSim(orderId: string, options?: any): AxiosPromise<string> {
            return localVarFp.registerOrderedSim(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    cancelOrder(orderId: string, options?: any): AxiosPromise<string>;

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmCouponOrder(orderId: string, options?: any): AxiosPromise<CouponResponse>;

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmOrder(orderId: string, options?: any): AxiosPromise<string>;

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    confirmVolumeDiscountOrder(orderId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;

    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any): AxiosPromise<EstimatedCouponModel>;

    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createQuotation(request: CreateEstimatedOrderRequest, options?: any): AxiosPromise<EstimatedOrderModel>;

    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any): AxiosPromise<EstimatedVolumeDiscountModel>;

    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrder(orderId: string, options?: any): AxiosPromise<GetOrderResponse>;

    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listAvailableDiscounts(options?: any): AxiosPromise<AvailableLongTermDiscountResponse>;

    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<ListOrderedSubscriberResponse>;

    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listOrders(options?: any): AxiosPromise<ListOrderResponse>;

    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    listProducts(options?: any): AxiosPromise<ListProductResponse>;

    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    registerOrderedSim(orderId: string, options?: any): AxiosPromise<string>;

}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Cancels an order. If the order has already been dispatched, an error is returned.
     * @summary Cancel order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm coupon order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmCouponOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).confirmCouponOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).confirmOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a credit limit and confirms the order if no problems are encountered.
     * @summary Confirm long term discount order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmVolumeDiscountOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).confirmVolumeDiscountOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new coupon quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create coupon quotation.
     * @param {CreateEstimatedCouponRequest} request Coupon details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createCouponQuotation(request: CreateEstimatedCouponRequest, options?: any) {
        return OrderApiFp(this.configuration).createCouponQuotation(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new order quotation. If the orderId is put in /confirm, the order is complete.
     * @summary Create Quotation.
     * @param {CreateEstimatedOrderRequest} request Order item list and shipping address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createQuotation(request: CreateEstimatedOrderRequest, options?: any) {
        return OrderApiFp(this.configuration).createQuotation(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new long term discount quotation. If the orderId is put in /confirm, the order is complete. (Currently, long term discount is only applied to plan-D, plan-K)
     * @summary Create long term discount quotation.
     * @param {CreateEstimatedVolumeDiscountRequest} request Long term discount contract details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createVolumeDiscountQuotation(request: CreateEstimatedVolumeDiscountRequest, options?: any) {
        return OrderApiFp(this.configuration).createVolumeDiscountQuotation(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a confirmed order.
     * @summary Get confirmed order.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available long term discounts.
     * @summary List available long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listAvailableDiscounts(options?: any) {
        return OrderApiFp(this.configuration).listAvailableDiscounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ordered subscribers
     * @summary List ordered subscribers.
     * @param {string} orderId order_id
     * @param {string} [lastEvaluatedKey] Serial number of the last subscriber in the previous page that is set to response header with X-Soracom-Next-Key.
     * @param {number} [limit] Max number of subscribers in a response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrderedSubscribers(orderId: string, lastEvaluatedKey?: string, limit?: number, options?: any) {
        return OrderApiFp(this.configuration).listOrderedSubscribers(orderId, lastEvaluatedKey, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of confirmed orders.
     * @summary List confirmed orders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrders(options?: any) {
        return OrderApiFp(this.configuration).listOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of products.
     * @summary List products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listProducts(options?: any) {
        return OrderApiFp(this.configuration).listProducts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers the ordered SIM with the operator.
     * @summary Register subscribers for operator.
     * @param {string} orderId order_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public registerOrderedSim(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).registerOrderedSim(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates a current payment method that has an error.
         * @summary Activate payment method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePaymentMethod: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_methods/current/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export payment statement.
         * @summary Export payment statement.
         * @param {string} paymentStatementId Payment statement ID
         * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPaymentStatement: async (paymentStatementId: string, exportMode?: 'async' | 'sync', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentStatementId' is not null or undefined
            assertParamExists('exportPaymentStatement', 'paymentStatementId', paymentStatementId)
            const localVarPath = `/payment_statements/{payment_statement_id}/export`
                .replace(`{${"payment_statement_id"}}`, encodeURIComponent(String(paymentStatementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (exportMode !== undefined) {
                localVarQueryParameter['export_mode'] = exportMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export payer information.
         * @summary Export payer information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInformation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_statements/payer_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current payment methods. Detailed information is included in the properties.
         * @summary Get payment method information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_methods/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns result of a payment transaction.
         * @summary Get payment transaction result.
         * @param {string} paymentTransactionId Payment transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTransaction: async (paymentTransactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentTransactionId' is not null or undefined
            assertParamExists('getPaymentTransaction', 'paymentTransactionId', paymentTransactionId)
            const localVarPath = `/payment_history/transactions/{payment_transaction_id}`
                .replace(`{${"payment_transaction_id"}}`, encodeURIComponent(String(paymentTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns contracted long term discount.
         * @summary Get long term discount.
         * @param {string} contractId contract_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeDiscount: async (contractId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getVolumeDiscount', 'contractId', contractId)
            const localVarPath = `/volume_discounts/{contract_id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of currently registered coupons.
         * @summary List coupons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoupons: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List payment statements.
         * @summary List payment statements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentStatements: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_statements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of contracted long term discounts.
         * @summary List long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeDiscounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volume_discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a coupon.
         * @summary Register Coupon.
         * @param {string} couponCode Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCoupon: async (couponCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'couponCode' is not null or undefined
            assertParamExists('registerCoupon', 'couponCode', couponCode)
            const localVarPath = `/coupons/{coupon_code}/register`
                .replace(`{${"coupon_code"}}`, encodeURIComponent(String(couponCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register payer information.
         * @summary Register payer information.
         * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPayerInformation: async (req: RegisterPayerInformationModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('registerPayerInformation', 'req', req)
            const localVarPath = `/payment_statements/payer_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates a current payment method that has an error.
         * @summary Activate payment method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePaymentMethod(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePaymentMethod(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export payment statement.
         * @summary Export payment statement.
         * @param {string} paymentStatementId Payment statement ID
         * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPaymentStatement(paymentStatementId, exportMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export payer information.
         * @summary Export payer information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayerInformation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterPayerInformationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayerInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current payment methods. Detailed information is included in the properties.
         * @summary Get payment method information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentMethodResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns result of a payment transaction.
         * @summary Get payment transaction result.
         * @param {string} paymentTransactionId Payment transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentTransaction(paymentTransactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentTransactionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentTransaction(paymentTransactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns contracted long term discount.
         * @summary Get long term discount.
         * @param {string} contractId contract_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolumeDiscount(contractId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVolumeDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeDiscount(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of currently registered coupons.
         * @summary List coupons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoupons(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCouponResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCoupons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List payment statements.
         * @summary List payment statements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentStatements(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentStatementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentStatements(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of contracted long term discounts.
         * @summary List long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeDiscounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVolumeDiscountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolumeDiscounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a coupon.
         * @summary Register Coupon.
         * @param {string} couponCode Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerCoupon(couponCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerCoupon(couponCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register payer information.
         * @summary Register payer information.
         * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPayerInformation(req: RegisterPayerInformationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPayerInformation(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Activates a current payment method that has an error.
         * @summary Activate payment method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePaymentMethod(options?: any): AxiosPromise<object> {
            return localVarFp.activatePaymentMethod(options).then((request) => request(axios, basePath));
        },
        /**
         * Export payment statement.
         * @summary Export payment statement.
         * @param {string} paymentStatementId Payment statement ID
         * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse> {
            return localVarFp.exportPaymentStatement(paymentStatementId, exportMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Export payer information.
         * @summary Export payer information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInformation(options?: any): AxiosPromise<RegisterPayerInformationModel> {
            return localVarFp.getPayerInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current payment methods. Detailed information is included in the properties.
         * @summary Get payment method information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(options?: any): AxiosPromise<GetPaymentMethodResult> {
            return localVarFp.getPaymentMethod(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns result of a payment transaction.
         * @summary Get payment transaction result.
         * @param {string} paymentTransactionId Payment transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTransaction(paymentTransactionId: string, options?: any): AxiosPromise<GetPaymentTransactionResult> {
            return localVarFp.getPaymentTransaction(paymentTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns contracted long term discount.
         * @summary Get long term discount.
         * @param {string} contractId contract_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeDiscount(contractId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse> {
            return localVarFp.getVolumeDiscount(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of currently registered coupons.
         * @summary List coupons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoupons(options?: any): AxiosPromise<ListCouponResponse> {
            return localVarFp.listCoupons(options).then((request) => request(axios, basePath));
        },
        /**
         * List payment statements.
         * @summary List payment statements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentStatements(options?: any): AxiosPromise<ListPaymentStatementResponse> {
            return localVarFp.listPaymentStatements(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of contracted long term discounts.
         * @summary List long term discounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeDiscounts(options?: any): AxiosPromise<ListVolumeDiscountResponse> {
            return localVarFp.listVolumeDiscounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a coupon.
         * @summary Register Coupon.
         * @param {string} couponCode Coupon code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCoupon(couponCode: string, options?: any): AxiosPromise<CouponResponse> {
            return localVarFp.registerCoupon(couponCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Register payer information.
         * @summary Register payer information.
         * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPayerInformation(req: RegisterPayerInformationModel, options?: any): AxiosPromise<void> {
            return localVarFp.registerPayerInformation(req, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - interface
 * @export
 * @interface PaymentApi
 */
export interface PaymentApiInterface {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    activatePaymentMethod(options?: any): AxiosPromise<object>;

    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;

    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPayerInformation(options?: any): AxiosPromise<RegisterPayerInformationModel>;

    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPaymentMethod(options?: any): AxiosPromise<GetPaymentMethodResult>;

    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPaymentTransaction(paymentTransactionId: string, options?: any): AxiosPromise<GetPaymentTransactionResult>;

    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getVolumeDiscount(contractId: string, options?: any): AxiosPromise<GetVolumeDiscountResponse>;

    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listCoupons(options?: any): AxiosPromise<ListCouponResponse>;

    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listPaymentStatements(options?: any): AxiosPromise<ListPaymentStatementResponse>;

    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    listVolumeDiscounts(options?: any): AxiosPromise<ListVolumeDiscountResponse>;

    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    registerCoupon(couponCode: string, options?: any): AxiosPromise<CouponResponse>;

    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    registerPayerInformation(req: RegisterPayerInformationModel, options?: any): AxiosPromise<void>;

}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI implements PaymentApiInterface {
    /**
     * Activates a current payment method that has an error.
     * @summary Activate payment method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public activatePaymentMethod(options?: any) {
        return PaymentApiFp(this.configuration).activatePaymentMethod(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export payment statement.
     * @summary Export payment statement.
     * @param {string} paymentStatementId Payment statement ID
     * @param {'async' | 'sync'} [exportMode] Export mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public exportPaymentStatement(paymentStatementId: string, exportMode?: 'async' | 'sync', options?: any) {
        return PaymentApiFp(this.configuration).exportPaymentStatement(paymentStatementId, exportMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export payer information.
     * @summary Export payer information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPayerInformation(options?: any) {
        return PaymentApiFp(this.configuration).getPayerInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current payment methods. Detailed information is included in the properties.
     * @summary Get payment method information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentMethod(options?: any) {
        return PaymentApiFp(this.configuration).getPaymentMethod(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns result of a payment transaction.
     * @summary Get payment transaction result.
     * @param {string} paymentTransactionId Payment transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentTransaction(paymentTransactionId: string, options?: any) {
        return PaymentApiFp(this.configuration).getPaymentTransaction(paymentTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns contracted long term discount.
     * @summary Get long term discount.
     * @param {string} contractId contract_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getVolumeDiscount(contractId: string, options?: any) {
        return PaymentApiFp(this.configuration).getVolumeDiscount(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of currently registered coupons.
     * @summary List coupons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public listCoupons(options?: any) {
        return PaymentApiFp(this.configuration).listCoupons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List payment statements.
     * @summary List payment statements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public listPaymentStatements(options?: any) {
        return PaymentApiFp(this.configuration).listPaymentStatements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of contracted long term discounts.
     * @summary List long term discounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public listVolumeDiscounts(options?: any) {
        return PaymentApiFp(this.configuration).listVolumeDiscounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a coupon.
     * @summary Register Coupon.
     * @param {string} couponCode Coupon code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public registerCoupon(couponCode: string, options?: any) {
        return PaymentApiFp(this.configuration).registerCoupon(couponCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register payer information.
     * @summary Register payer information.
     * @param {RegisterPayerInformationModel} req Payer information to be registered in the accounting specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public registerPayerInformation(req: RegisterPayerInformationModel, options?: any) {
        return PaymentApiFp(this.configuration).registerPayerInformation(req, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortMappingApi - axios parameter creator
 * @export
 */
export const PortMappingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new port mapping.
         * @summary Create Port Mapping.
         * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortMapping: async (portMapping: CreatePortMappingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portMapping' is not null or undefined
            assertParamExists('createPortMapping', 'portMapping', portMapping)
            const localVarPath = `/port_mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified port mapping entry
         * @summary Delete PortMapping.
         * @param {string} ipAddress IP address of the target port mapping entry
         * @param {string} port Port of the target port mapping entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortMapping: async (ipAddress: string, port: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('deletePortMapping', 'ipAddress', ipAddress)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('deletePortMapping', 'port', port)
            const localVarPath = `/port_mappings/{ip_address}/{port}`
                .replace(`{${"ip_address"}}`, encodeURIComponent(String(ipAddress)))
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of port mappings.
         * @summary List Port Mapping Entries.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortMappings: async (limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/port_mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the port mapping entries for a subscriber.
         * @summary Get Port Mapping entries for a subscriber.
         * @param {string} imsi Target subscriber IMSI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortMappingsForSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('listPortMappingsForSubscriber', 'imsi', imsi)
            const localVarPath = `/port_mappings/subscribers/{imsi}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortMappingApi - functional programming interface
 * @export
 */
export const PortMappingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortMappingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new port mapping.
         * @summary Create Port Mapping.
         * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPortMapping(portMapping: CreatePortMappingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPortMapping(portMapping, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified port mapping entry
         * @summary Delete PortMapping.
         * @param {string} ipAddress IP address of the target port mapping entry
         * @param {string} port Port of the target port mapping entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePortMapping(ipAddress: string, port: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePortMapping(ipAddress, port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of port mappings.
         * @summary List Port Mapping Entries.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPortMappings(limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the port mapping entries for a subscriber.
         * @summary Get Port Mapping entries for a subscriber.
         * @param {string} imsi Target subscriber IMSI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortMappingsForSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPortMappingsForSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortMappingApi - factory interface
 * @export
 */
export const PortMappingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortMappingApiFp(configuration)
    return {
        /**
         * Create a new port mapping.
         * @summary Create Port Mapping.
         * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortMapping(portMapping: CreatePortMappingRequest, options?: any): AxiosPromise<PortMapping> {
            return localVarFp.createPortMapping(portMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified port mapping entry
         * @summary Delete PortMapping.
         * @param {string} ipAddress IP address of the target port mapping entry
         * @param {string} port Port of the target port mapping entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortMapping(ipAddress: string, port: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePortMapping(ipAddress, port, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of port mappings.
         * @summary List Port Mapping Entries.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<PortMapping>> {
            return localVarFp.listPortMappings(limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the port mapping entries for a subscriber.
         * @summary Get Port Mapping entries for a subscriber.
         * @param {string} imsi Target subscriber IMSI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortMappingsForSubscriber(imsi: string, options?: any): AxiosPromise<PortMapping> {
            return localVarFp.listPortMappingsForSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortMappingApi - interface
 * @export
 * @interface PortMappingApi
 */
export interface PortMappingApiInterface {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    createPortMapping(portMapping: CreatePortMappingRequest, options?: any): AxiosPromise<PortMapping>;

    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    deletePortMapping(ipAddress: string, port: string, options?: any): AxiosPromise<void>;

    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<PortMapping>>;

    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApiInterface
     */
    listPortMappingsForSubscriber(imsi: string, options?: any): AxiosPromise<PortMapping>;

}

/**
 * PortMappingApi - object-oriented interface
 * @export
 * @class PortMappingApi
 * @extends {BaseAPI}
 */
export class PortMappingApi extends BaseAPI implements PortMappingApiInterface {
    /**
     * Create a new port mapping.
     * @summary Create Port Mapping.
     * @param {CreatePortMappingRequest} portMapping Port mapping to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    public createPortMapping(portMapping: CreatePortMappingRequest, options?: any) {
        return PortMappingApiFp(this.configuration).createPortMapping(portMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified port mapping entry
     * @summary Delete PortMapping.
     * @param {string} ipAddress IP address of the target port mapping entry
     * @param {string} port Port of the target port mapping entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    public deletePortMapping(ipAddress: string, port: string, options?: any) {
        return PortMappingApiFp(this.configuration).deletePortMapping(ipAddress, port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of port mappings.
     * @summary List Port Mapping Entries.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last Port Mapping ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next group onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    public listPortMappings(limit?: number, lastEvaluatedKey?: string, options?: any) {
        return PortMappingApiFp(this.configuration).listPortMappings(limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the port mapping entries for a subscriber.
     * @summary Get Port Mapping entries for a subscriber.
     * @param {string} imsi Target subscriber IMSI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortMappingApi
     */
    public listPortMappingsForSubscriber(imsi: string, options?: any) {
        return PortMappingApiFp(this.configuration).listPortMappingsForSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
         * @summary Search SORACOM Inventory devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
         * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices: async (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/query/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (deviceId) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (imsi) {
                localVarQueryParameter['imsi'] = imsi;
            }

            if (imei) {
                localVarQueryParameter['imei'] = imei;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
         * @summary Search Sigfox devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] Sigfox device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
         * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSigfoxDevices: async (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/query/sigfox_devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (deviceId) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (registration !== undefined) {
                localVarQueryParameter['registration'] = registration;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary Search SIMs by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [simId] Identifier of the SIM to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [bundles] Bundles type to search
         * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSims: async (name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/query/sims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (simId) {
                localVarQueryParameter['sim_id'] = simId;
            }

            if (imsi) {
                localVarQueryParameter['imsi'] = imsi;
            }

            if (msisdn) {
                localVarQueryParameter['msisdn'] = msisdn;
            }

            if (iccid) {
                localVarQueryParameter['iccid'] = iccid;
            }

            if (serialNumber) {
                localVarQueryParameter['serial_number'] = serialNumber;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (bundles) {
                localVarQueryParameter['bundles'] = bundles;
            }

            if (sessionStatus !== undefined) {
                localVarQueryParameter['session_status'] = sessionStatus;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search traffic volume ranking of subscribers
         * @summary Search traffic volume ranking of subscribers
         * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
         * @param {number} to The end point of searching range (unixtime: in milliseconds)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {'asc' | 'desc'} [order] The order of ranking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSubscriberTrafficVolumeRanking: async (from: number, to: number, limit?: number, order?: 'asc' | 'desc', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('searchSubscriberTrafficVolumeRanking', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('searchSubscriberTrafficVolumeRanking', 'to', to)
            const localVarPath = `/query/subscribers/traffic_volume/ranking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary (DEPRECATED) Search subscribers by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSubscribers: async (name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/query/subscribers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (imsi) {
                localVarQueryParameter['imsi'] = imsi;
            }

            if (msisdn) {
                localVarQueryParameter['msisdn'] = msisdn;
            }

            if (iccid) {
                localVarQueryParameter['iccid'] = iccid;
            }

            if (serialNumber) {
                localVarQueryParameter['serial_number'] = serialNumber;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
         * @summary Search SORACOM Inventory devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
         * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDevices(name, group, deviceId, tag, imsi, imei, limit, lastEvaluatedKey, searchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
         * @summary Search Sigfox devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] Sigfox device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
         * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SigfoxDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSigfoxDevices(name, group, deviceId, tag, status, registration, limit, lastEvaluatedKey, searchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary Search SIMs by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [simId] Identifier of the SIM to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [bundles] Bundles type to search
         * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSims(name, group, simId, imsi, msisdn, iccid, serialNumber, tag, bundles, sessionStatus, limit, lastEvaluatedKey, searchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search traffic volume ranking of subscribers
         * @summary Search traffic volume ranking of subscribers
         * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
         * @param {number} to The end point of searching range (unixtime: in milliseconds)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {'asc' | 'desc'} [order] The order of ranking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrafficVolumeRanking>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSubscriberTrafficVolumeRanking(from, to, limit, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary (DEPRECATED) Search subscribers by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscriber>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSubscribers(name, group, imsi, msisdn, iccid, serialNumber, tag, limit, lastEvaluatedKey, searchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
         * @summary Search SORACOM Inventory devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
         * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.searchDevices(name, group, deviceId, tag, imsi, imei, limit, lastEvaluatedKey, searchType, options).then((request) => request(axios, basePath));
        },
        /**
         * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
         * @summary Search Sigfox devices by query
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [deviceId] Sigfox device ID to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
         * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<SigfoxDevice>> {
            return localVarFp.searchSigfoxDevices(name, group, deviceId, tag, status, registration, limit, lastEvaluatedKey, searchType, options).then((request) => request(axios, basePath));
        },
        /**
         * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary Search SIMs by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [simId] Identifier of the SIM to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {Array<string>} [bundles] Bundles type to search
         * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Sim>> {
            return localVarFp.searchSims(name, group, simId, imsi, msisdn, iccid, serialNumber, tag, bundles, sessionStatus, limit, lastEvaluatedKey, searchType, options).then((request) => request(axios, basePath));
        },
        /**
         * Search traffic volume ranking of subscribers
         * @summary Search traffic volume ranking of subscribers
         * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
         * @param {number} to The end point of searching range (unixtime: in milliseconds)
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {'asc' | 'desc'} [order] The order of ranking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): AxiosPromise<Array<TrafficVolumeRanking>> {
            return localVarFp.searchSubscriberTrafficVolumeRanking(from, to, limit, order, options).then((request) => request(axios, basePath));
        },
        /**
         * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
         * @summary (DEPRECATED) Search subscribers by query terms
         * @param {Array<string>} [name] Name to search
         * @param {Array<string>} [group] Group name to search
         * @param {Array<string>} [imsi] IMSI to search
         * @param {Array<string>} [msisdn] MSISDN to search
         * @param {Array<string>} [iccid] ICCID to search
         * @param {Array<string>} [serialNumber] Serial number to search
         * @param {Array<string>} [tag] String of tag values to search
         * @param {number} [limit] The maximum number of item to retrieve
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Subscriber>> {
            return localVarFp.searchSubscribers(name, group, imsi, msisdn, iccid, serialNumber, tag, limit, lastEvaluatedKey, searchType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - interface
 * @export
 * @interface QueryApi
 */
export interface QueryApiInterface {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Device>>;

    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<SigfoxDevice>>;

    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Sim>>;

    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any): AxiosPromise<Array<TrafficVolumeRanking>>;

    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApiInterface
     */
    searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any): AxiosPromise<Array<Subscriber>>;

}

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI implements QueryApiInterface {
    /**
     * Search SORACOM Inventory devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SORACOM Inventory devices that includes their group information.
     * @summary Search SORACOM Inventory devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] SORACOM Inventory device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [imsi] IMSI of the device that was used on bootstrapping
     * @param {Array<string>} [imei] IMEI of the device that was used on bootstrapping
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SORACOM Inventory device ID of the last Inventory device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Inventory device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public searchDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) {
        return QueryApiFp(this.configuration).searchDevices(name, group, deviceId, tag, imsi, imei, limit, lastEvaluatedKey, searchType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search Sigfox devices by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all Sigfox devices that includes their group information.
     * @summary Search Sigfox devices by query
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [deviceId] Sigfox device ID to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'} [status] Status of sigfox devices
     * @param {'notStarted' | 'pending' | 'success' | 'failed'} [registration] Registration status of sigfox devices
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The Sigfox device ID of the last Sigfox device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Sigfox device onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public searchSigfoxDevices(name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) {
        return QueryApiFp(this.configuration).searchSigfoxDevices(name, group, deviceId, tag, status, registration, limit, lastEvaluatedKey, searchType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search SIMs by query terms. It returns partial match results. When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary Search SIMs by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [simId] Identifier of the SIM to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {Array<string>} [bundles] Bundles type to search
     * @param {'NA' | 'ONLINE' | 'OFFLINE'} [sessionStatus] Status of the session to search (ONLINE or OFFLINE)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The SIM ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public searchSims(name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) {
        return QueryApiFp(this.configuration).searchSims(name, group, simId, imsi, msisdn, iccid, serialNumber, tag, bundles, sessionStatus, limit, lastEvaluatedKey, searchType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search traffic volume ranking of subscribers
     * @summary Search traffic volume ranking of subscribers
     * @param {number} from The beginning point of searching range (unixtime: in milliseconds)
     * @param {number} to The end point of searching range (unixtime: in milliseconds)
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {'asc' | 'desc'} [order] The order of ranking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public searchSubscriberTrafficVolumeRanking(from: number, to: number, limit?: number, order?: 'asc' | 'desc', options?: any) {
        return QueryApiFp(this.configuration).searchSubscriberTrafficVolumeRanking(from, to, limit, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (DEPRECATED: please consider to use `/query/sims` API instead) Search subscribers by query terms. It returns partial match results.  When this API permission is allowed, it grants the authority to search and retrieve all SIMs that includes their group information.
     * @summary (DEPRECATED) Search subscribers by query terms
     * @param {Array<string>} [name] Name to search
     * @param {Array<string>} [group] Group name to search
     * @param {Array<string>} [imsi] IMSI to search
     * @param {Array<string>} [msisdn] MSISDN to search
     * @param {Array<string>} [iccid] ICCID to search
     * @param {Array<string>} [serialNumber] Serial number to search
     * @param {Array<string>} [tag] String of tag values to search
     * @param {number} [limit] The maximum number of item to retrieve
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {'and' | 'or'} [searchType] Type of the search (\&#39;AND searching\&#39; or \&#39;OR searching\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public searchSubscribers(name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options?: any) {
        return QueryApiFp(this.configuration).searchSubscribers(name, group, imsi, msisdn, iccid, serialNumber, tag, limit, lastEvaluatedKey, searchType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attaches a role to a user.
         * @summary Attach Role to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {AttachRoleRequest} request role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachRole: async (operatorId: string, userName: string, request: AttachRoleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('attachRole', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('attachRole', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('attachRole', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/roles`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new role.
         * @summary Create Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createRole', 'operatorId', operatorId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('createRole', 'roleId', roleId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createRole', 'request', request)
            const localVarPath = `/operators/{operator_id}/roles/{role_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a role.
         * @summary Delete Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (operatorId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteRole', 'operatorId', operatorId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRole', 'roleId', roleId)
            const localVarPath = `/operators/{operator_id}/roles/{role_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches a role from a user.
         * @summary Detach Role from User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachRole: async (operatorId: string, userName: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('detachRole', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('detachRole', 'userName', userName)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('detachRole', 'roleId', roleId)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/roles/{role_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a role.
         * @summary Get Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (operatorId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getRole', 'operatorId', operatorId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRole', 'roleId', roleId)
            const localVarPath = `/operators/{operator_id}/roles/{role_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of users attached to a role.
         * @summary List Role Attached Users.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleAttachedUsers: async (operatorId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listRoleAttachedUsers', 'operatorId', operatorId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('listRoleAttachedUsers', 'roleId', roleId)
            const localVarPath = `/operators/{operator_id}/roles/{role_id}/users`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of roles.
         * @summary List Roles.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listRoles', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/roles`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of the user\'s roles.
         * @summary List User Roles.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listUserRoles', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('listUserRoles', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/roles`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a role.
         * @summary Update Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateRole', 'operatorId', operatorId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateRole', 'roleId', roleId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateRole', 'request', request)
            const localVarPath = `/operators/{operator_id}/roles/{role_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Attaches a role to a user.
         * @summary Attach Role to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {AttachRoleRequest} request role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachRole(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new role.
         * @summary Create Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(operatorId, roleId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a role.
         * @summary Delete Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(operatorId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detaches a role from a user.
         * @summary Detach Role from User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachRole(operatorId: string, userName: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachRole(operatorId, userName, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a role.
         * @summary Get Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(operatorId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of users attached to a role.
         * @summary List Role Attached Users.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleAttachedUsers(operatorId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of roles.
         * @summary List Roles.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListRolesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of the user\'s roles.
         * @summary List User Roles.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRoles(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRoles(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a role.
         * @summary Update Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(operatorId, roleId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         * Attaches a role to a user.
         * @summary Attach Role to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {AttachRoleRequest} request role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): AxiosPromise<void> {
            return localVarFp.attachRole(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new role.
         * @summary Create Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<CreateRoleResponse> {
            return localVarFp.createRole(operatorId, roleId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a role.
         * @summary Delete Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(operatorId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(operatorId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a role from a user.
         * @summary Detach Role from User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachRole(operatorId: string, userName: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.detachRole(operatorId, userName, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a role.
         * @summary Get Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(operatorId: string, roleId: string, options?: any): AxiosPromise<RoleResponse> {
            return localVarFp.getRole(operatorId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of users attached to a role.
         * @summary List Role Attached Users.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): AxiosPromise<Array<UserDetailResponse>> {
            return localVarFp.listRoleAttachedUsers(operatorId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of roles.
         * @summary List Roles.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(operatorId: string, options?: any): AxiosPromise<Array<ListRolesResponse>> {
            return localVarFp.listRoles(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of the user\'s roles.
         * @summary List User Roles.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles(operatorId: string, userName: string, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.listUserRoles(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a role.
         * @summary Update Role.
         * @param {string} operatorId operator_id
         * @param {string} roleId role_id
         * @param {CreateOrUpdateRoleRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateRole(operatorId, roleId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - interface
 * @export
 * @interface RoleApi
 */
export interface RoleApiInterface {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any): AxiosPromise<void>;

    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<CreateRoleResponse>;

    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    deleteRole(operatorId: string, roleId: string, options?: any): AxiosPromise<void>;

    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    detachRole(operatorId: string, userName: string, roleId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    getRole(operatorId: string, roleId: string, options?: any): AxiosPromise<RoleResponse>;

    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listRoleAttachedUsers(operatorId: string, roleId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;

    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listRoles(operatorId: string, options?: any): AxiosPromise<Array<ListRolesResponse>>;

    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    listUserRoles(operatorId: string, userName: string, options?: any): AxiosPromise<Array<RoleResponse>>;

    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApiInterface
     */
    updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any): AxiosPromise<void>;

}

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI implements RoleApiInterface {
    /**
     * Attaches a role to a user.
     * @summary Attach Role to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {AttachRoleRequest} request role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public attachRole(operatorId: string, userName: string, request: AttachRoleRequest, options?: any) {
        return RoleApiFp(this.configuration).attachRole(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new role.
     * @summary Create Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any) {
        return RoleApiFp(this.configuration).createRole(operatorId, roleId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a role.
     * @summary Delete Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public deleteRole(operatorId: string, roleId: string, options?: any) {
        return RoleApiFp(this.configuration).deleteRole(operatorId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches a role from a user.
     * @summary Detach Role from User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public detachRole(operatorId: string, userName: string, roleId: string, options?: any) {
        return RoleApiFp(this.configuration).detachRole(operatorId, userName, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a role.
     * @summary Get Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRole(operatorId: string, roleId: string, options?: any) {
        return RoleApiFp(this.configuration).getRole(operatorId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of users attached to a role.
     * @summary List Role Attached Users.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoleAttachedUsers(operatorId: string, roleId: string, options?: any) {
        return RoleApiFp(this.configuration).listRoleAttachedUsers(operatorId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of roles.
     * @summary List Roles.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoles(operatorId: string, options?: any) {
        return RoleApiFp(this.configuration).listRoles(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of the user\'s roles.
     * @summary List User Roles.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listUserRoles(operatorId: string, userName: string, options?: any) {
        return RoleApiFp(this.configuration).listUserRoles(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a role.
     * @summary Update Role.
     * @param {string} operatorId operator_id
     * @param {string} roleId role_id
     * @param {CreateOrUpdateRoleRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public updateRole(operatorId: string, roleId: string, request: CreateOrUpdateRoleRequest, options?: any) {
        return RoleApiFp(this.configuration).updateRole(operatorId, roleId, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShippingAddressApi - axios parameter creator
 * @export
 */
export const ShippingAddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new shipping address.
         * @summary Create shipping address.
         * @param {string} operatorId operator_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingAddress: async (operatorId: string, model: ShippingAddressModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createShippingAddress', 'operatorId', operatorId)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('createShippingAddress', 'model', model)
            const localVarPath = `/operators/{operator_id}/shipping_addresses`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a shipping address.
         * @summary Delete shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingAddress: async (operatorId: string, shippingAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteShippingAddress', 'operatorId', operatorId)
            // verify required parameter 'shippingAddressId' is not null or undefined
            assertParamExists('deleteShippingAddress', 'shippingAddressId', shippingAddressId)
            const localVarPath = `/operators/{operator_id}/shipping_addresses/{shipping_address_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"shipping_address_id"}}`, encodeURIComponent(String(shippingAddressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a shipping address.
         * @summary Get shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingAddress: async (operatorId: string, shippingAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getShippingAddress', 'operatorId', operatorId)
            // verify required parameter 'shippingAddressId' is not null or undefined
            assertParamExists('getShippingAddress', 'shippingAddressId', shippingAddressId)
            const localVarPath = `/operators/{operator_id}/shipping_addresses/{shipping_address_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"shipping_address_id"}}`, encodeURIComponent(String(shippingAddressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of shipping addresses.
         * @summary List shipping addresses.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShippingAddresses: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listShippingAddresses', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/shipping_addresses`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a shipping address.
         * @summary Update shipping address.
         * @param {string} operatorId Operator ID
         * @param {string} shippingAddressId shipping_address_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShippingAddress: async (operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateShippingAddress', 'operatorId', operatorId)
            // verify required parameter 'shippingAddressId' is not null or undefined
            assertParamExists('updateShippingAddress', 'shippingAddressId', shippingAddressId)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('updateShippingAddress', 'model', model)
            const localVarPath = `/operators/{operator_id}/shipping_addresses/{shipping_address_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"shipping_address_id"}}`, encodeURIComponent(String(shippingAddressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingAddressApi - functional programming interface
 * @export
 */
export const ShippingAddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShippingAddressApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new shipping address.
         * @summary Create shipping address.
         * @param {string} operatorId operator_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShippingAddress(operatorId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a shipping address.
         * @summary Delete shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShippingAddress(operatorId, shippingAddressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a shipping address.
         * @summary Get shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingAddress(operatorId, shippingAddressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of shipping addresses.
         * @summary List shipping addresses.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShippingAddresses(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListShippingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShippingAddresses(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a shipping address.
         * @summary Update shipping address.
         * @param {string} operatorId Operator ID
         * @param {string} shippingAddressId shipping_address_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShippingAddress(operatorId, shippingAddressId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShippingAddressApi - factory interface
 * @export
 */
export const ShippingAddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShippingAddressApiFp(configuration)
    return {
        /**
         * Creates a new shipping address.
         * @summary Create shipping address.
         * @param {string} operatorId operator_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): AxiosPromise<GetShippingAddressResponse> {
            return localVarFp.createShippingAddress(operatorId, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a shipping address.
         * @summary Delete shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteShippingAddress(operatorId, shippingAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a shipping address.
         * @summary Get shipping address.
         * @param {string} operatorId operator_id
         * @param {string} shippingAddressId shipping_address_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<GetShippingAddressResponse> {
            return localVarFp.getShippingAddress(operatorId, shippingAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of shipping addresses.
         * @summary List shipping addresses.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShippingAddresses(operatorId: string, options?: any): AxiosPromise<ListShippingAddressResponse> {
            return localVarFp.listShippingAddresses(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a shipping address.
         * @summary Update shipping address.
         * @param {string} operatorId Operator ID
         * @param {string} shippingAddressId shipping_address_id
         * @param {ShippingAddressModel} model model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateShippingAddress(operatorId, shippingAddressId, model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingAddressApi - interface
 * @export
 * @interface ShippingAddressApi
 */
export interface ShippingAddressApiInterface {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any): AxiosPromise<GetShippingAddressResponse>;

    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<void>;

    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    getShippingAddress(operatorId: string, shippingAddressId: string, options?: any): AxiosPromise<GetShippingAddressResponse>;

    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    listShippingAddresses(operatorId: string, options?: any): AxiosPromise<ListShippingAddressResponse>;

    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApiInterface
     */
    updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any): AxiosPromise<void>;

}

/**
 * ShippingAddressApi - object-oriented interface
 * @export
 * @class ShippingAddressApi
 * @extends {BaseAPI}
 */
export class ShippingAddressApi extends BaseAPI implements ShippingAddressApiInterface {
    /**
     * Creates a new shipping address.
     * @summary Create shipping address.
     * @param {string} operatorId operator_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    public createShippingAddress(operatorId: string, model: ShippingAddressModel, options?: any) {
        return ShippingAddressApiFp(this.configuration).createShippingAddress(operatorId, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a shipping address.
     * @summary Delete shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    public deleteShippingAddress(operatorId: string, shippingAddressId: string, options?: any) {
        return ShippingAddressApiFp(this.configuration).deleteShippingAddress(operatorId, shippingAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a shipping address.
     * @summary Get shipping address.
     * @param {string} operatorId operator_id
     * @param {string} shippingAddressId shipping_address_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    public getShippingAddress(operatorId: string, shippingAddressId: string, options?: any) {
        return ShippingAddressApiFp(this.configuration).getShippingAddress(operatorId, shippingAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of shipping addresses.
     * @summary List shipping addresses.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    public listShippingAddresses(operatorId: string, options?: any) {
        return ShippingAddressApiFp(this.configuration).listShippingAddresses(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a shipping address.
     * @summary Update shipping address.
     * @param {string} operatorId Operator ID
     * @param {string} shippingAddressId shipping_address_id
     * @param {ShippingAddressModel} model model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingAddressApi
     */
    public updateShippingAddress(operatorId: string, shippingAddressId: string, model: ShippingAddressModel, options?: any) {
        return ShippingAddressApiFp(this.configuration).updateShippingAddress(operatorId, shippingAddressId, model, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SigfoxDeviceApi - axios parameter creator
 * @export
 */
export const SigfoxDeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a tag from the specified Sigfox device.
         * @summary Delete Sigfox device Tag.
         * @param {string} deviceId device ID of the target Sigfox device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSigfoxDeviceTag: async (deviceId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deleteSigfoxDeviceTag', 'deviceId', deviceId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteSigfoxDeviceTag', 'tagName', tagName)
            const localVarPath = `/sigfox_devices/{device_id}/tags/{tag_name}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of specified Sigfox device.
         * @summary Disable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnSigfoxDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('disableTerminationOnSigfoxDevice', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}/disable_termination`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified Sigfox device.
         * @summary Enable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnSigfoxDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('enableTerminationOnSigfoxDevice', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}/enable_termination`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a Sigfox device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSigfoxDevice: async (deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDataFromSigfoxDevice', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}/data`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified Sigfox device.
         * @summary Get Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigfoxDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getSigfoxDevice', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Sigfox devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSigfoxDevices: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sigfox_devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified Sigfox device.
         * @summary Bulk Insert or Update Sigfox device Tags.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSigfoxDeviceTags: async (deviceId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('putSigfoxDeviceTags', 'deviceId', deviceId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putSigfoxDeviceTags', 'tags', tags)
            const localVarPath = `/sigfox_devices/{device_id}/tags`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Sigfox device
         * @summary Register a Sigfox device.
         * @param {string} deviceId Device ID of the target sigfox device to register
         * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSigfoxDevice: async (deviceId: string, registrationRequest: SigfoxRegistrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('registerSigfoxDevice', 'deviceId', deviceId)
            // verify required parameter 'registrationRequest' is not null or undefined
            assertParamExists('registerSigfoxDevice', 'registrationRequest', registrationRequest)
            const localVarPath = `/sigfox_devices/{device_id}/register`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a Sigfox device.
         * @param {string} deviceId ID of the recipient device.
         * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataToSigfoxDevice: async (deviceId: string, data: SigfoxData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('sendDataToSigfoxDevice', 'deviceId', deviceId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('sendDataToSigfoxDevice', 'data', data)
            const localVarPath = `/sigfox_devices/{device_id}/data`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites a group for the specified Sigfox device.
         * @summary Set Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSigfoxDeviceGroup: async (deviceId: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('setSigfoxDeviceGroup', 'deviceId', deviceId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('setSigfoxDeviceGroup', 'group', group)
            const localVarPath = `/sigfox_devices/{device_id}/set_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified Sigfox device
         * @summary Terminate Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSigfoxDevice: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('terminateSigfoxDevice', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}/terminate`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group configuration from the specified Sigfox device.
         * @summary Unset Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSigfoxDeviceGroup: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('unsetSigfoxDeviceGroup', 'deviceId', deviceId)
            const localVarPath = `/sigfox_devices/{device_id}/unset_group`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigfoxDeviceApi - functional programming interface
 * @export
 */
export const SigfoxDeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigfoxDeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a tag from the specified Sigfox device.
         * @summary Delete Sigfox device Tag.
         * @param {string} deviceId device ID of the target Sigfox device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSigfoxDeviceTag(deviceId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of specified Sigfox device.
         * @summary Disable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTerminationOnSigfoxDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified Sigfox device.
         * @summary Enable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTerminationOnSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTerminationOnSigfoxDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a Sigfox device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFromSigfoxDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified Sigfox device.
         * @summary Get Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSigfoxDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Sigfox devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SigfoxDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSigfoxDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified Sigfox device.
         * @summary Bulk Insert or Update Sigfox device Tags.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSigfoxDeviceTags(deviceId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a Sigfox device
         * @summary Register a Sigfox device.
         * @param {string} deviceId Device ID of the target sigfox device to register
         * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSigfoxDevice(deviceId, registrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a Sigfox device.
         * @param {string} deviceId ID of the recipient device.
         * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDataToSigfoxDevice(deviceId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites a group for the specified Sigfox device.
         * @summary Set Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSigfoxDeviceGroup(deviceId, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified Sigfox device
         * @summary Terminate Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSigfoxDevice(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSigfoxDevice(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the group configuration from the specified Sigfox device.
         * @summary Unset Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetSigfoxDeviceGroup(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigfoxDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetSigfoxDeviceGroup(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SigfoxDeviceApi - factory interface
 * @export
 */
export const SigfoxDeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigfoxDeviceApiFp(configuration)
    return {
        /**
         * Deletes a tag from the specified Sigfox device.
         * @summary Delete Sigfox device Tag.
         * @param {string} deviceId device ID of the target Sigfox device.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSigfoxDeviceTag(deviceId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of specified Sigfox device.
         * @summary Disable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.disableTerminationOnSigfoxDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified Sigfox device.
         * @summary Enable Termination of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.enableTerminationOnSigfoxDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a Sigfox device.
         * @param {string} deviceId Device ID of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataFromSigfoxDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified Sigfox device.
         * @summary Get Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.getSigfoxDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Sigfox devices.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
         * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SigfoxDevice>> {
            return localVarFp.listSigfoxDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified Sigfox device.
         * @summary Bulk Insert or Update Sigfox device Tags.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.putSigfoxDeviceTags(deviceId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a Sigfox device
         * @summary Register a Sigfox device.
         * @param {string} deviceId Device ID of the target sigfox device to register
         * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.registerSigfoxDevice(deviceId, registrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
         * @summary Send data to a Sigfox device.
         * @param {string} deviceId ID of the recipient device.
         * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): AxiosPromise<void> {
            return localVarFp.sendDataToSigfoxDevice(deviceId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites a group for the specified Sigfox device.
         * @summary Set Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {Group} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.setSigfoxDeviceGroup(deviceId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified Sigfox device
         * @summary Terminate Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.terminateSigfoxDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group configuration from the specified Sigfox device.
         * @summary Unset Group of Sigfox device.
         * @param {string} deviceId Device ID of the target Sigfox device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSigfoxDeviceGroup(deviceId: string, options?: any): AxiosPromise<SigfoxDevice> {
            return localVarFp.unsetSigfoxDeviceGroup(deviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigfoxDeviceApi - interface
 * @export
 * @interface SigfoxDeviceApi
 */
export interface SigfoxDeviceApiInterface {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    disableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    enableTerminationOnSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    getSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SigfoxDevice>>;

    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any): AxiosPromise<void>;

    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    terminateSigfoxDevice(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;

    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApiInterface
     */
    unsetSigfoxDeviceGroup(deviceId: string, options?: any): AxiosPromise<SigfoxDevice>;

}

/**
 * SigfoxDeviceApi - object-oriented interface
 * @export
 * @class SigfoxDeviceApi
 * @extends {BaseAPI}
 */
export class SigfoxDeviceApi extends BaseAPI implements SigfoxDeviceApiInterface {
    /**
     * Deletes a tag from the specified Sigfox device.
     * @summary Delete Sigfox device Tag.
     * @param {string} deviceId device ID of the target Sigfox device.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public deleteSigfoxDeviceTag(deviceId: string, tagName: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).deleteSigfoxDeviceTag(deviceId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of specified Sigfox device.
     * @summary Disable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public disableTerminationOnSigfoxDevice(deviceId: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).disableTerminationOnSigfoxDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified Sigfox device.
     * @summary Enable Termination of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public enableTerminationOnSigfoxDevice(deviceId: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).enableTerminationOnSigfoxDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a Sigfox device that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a Sigfox device.
     * @param {string} deviceId Device ID of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public getDataFromSigfoxDevice(deviceId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).getDataFromSigfoxDevice(deviceId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified Sigfox device.
     * @summary Get Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public getSigfoxDevice(deviceId: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).getSigfoxDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Sigfox devices that match certain criteria. If the total number of Sigfox devices does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Sigfox devices.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of Sigfox devices to retrieve.
     * @param {string} [lastEvaluatedKey] The device ID of the last device retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next device onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public listSigfoxDevices(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).listSigfoxDevices(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified Sigfox device.
     * @summary Bulk Insert or Update Sigfox device Tags.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public putSigfoxDeviceTags(deviceId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).putSigfoxDeviceTags(deviceId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a Sigfox device
     * @summary Register a Sigfox device.
     * @param {string} deviceId Device ID of the target sigfox device to register
     * @param {SigfoxRegistrationRequest} registrationRequest Sigfox device registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public registerSigfoxDevice(deviceId: string, registrationRequest: SigfoxRegistrationRequest, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).registerSigfoxDevice(deviceId, registrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends data to the specified Sigfox device. The data will be stored until the device sends a next uplink message. If another message destined for the same Sigfox device ID is already waiting to be sent, the existing message will be discarded, and the new message will be sent instead.
     * @summary Send data to a Sigfox device.
     * @param {string} deviceId ID of the recipient device.
     * @param {SigfoxData} data Binary data encoded as a hexadecimal string. Length of original binary data must be 8 octets (16 characters when encoded as a hexadecimal string).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public sendDataToSigfoxDevice(deviceId: string, data: SigfoxData, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).sendDataToSigfoxDevice(deviceId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites a group for the specified Sigfox device.
     * @summary Set Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {Group} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public setSigfoxDeviceGroup(deviceId: string, group: Group, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).setSigfoxDeviceGroup(deviceId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified Sigfox device
     * @summary Terminate Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public terminateSigfoxDevice(deviceId: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).terminateSigfoxDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group configuration from the specified Sigfox device.
     * @summary Unset Group of Sigfox device.
     * @param {string} deviceId Device ID of the target Sigfox device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigfoxDeviceApi
     */
    public unsetSigfoxDeviceGroup(deviceId: string, options?: any) {
        return SigfoxDeviceApiFp(this.configuration).unsetSigfoxDeviceGroup(deviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SimApi - axios parameter creator
 * @export
 */
export const SimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change status of specified SIM to active.
         * @summary Activate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateSim: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('activateSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/activate`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is used to trigger the OTA update of a new subscription container to a SIM profile. 
         * @summary Adds a new subscription container to a SIM profile
         * @param {string} simId Id of the target SIM
         * @param {string} iccid Iccid of the target profile
         * @param {InlineObject2} [subscriptionParameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscription: async (simId: string, iccid: string, subscriptionParameters?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('addSubscription', 'simId', simId)
            // verify required parameter 'iccid' is not null or undefined
            assertParamExists('addSubscription', 'iccid', iccid)
            const localVarPath = `/sims/{sim_id}/profiles/{iccid}/add_subscription`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"iccid"}}`, encodeURIComponent(String(iccid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change status of specified SIM to inactive.
         * @summary Deactivate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateSim: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('deactivateSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/deactivate`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes session for the specified SIM.
         * @summary Delete Session
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimSession: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('deleteSimSession', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/delete_session`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tag from the specified SIM.
         * @summary Delete SIM tag.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimTag: async (simId: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('deleteSimTag', 'simId', simId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteSimTag', 'tagName', tagName)
            const localVarPath = `/sims/{sim_id}/tags/{tag_name}`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete subscription container country mapping entries
         * @summary Delete subscription container mapping entries
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} mcc mobile country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionContainerCountryMappingEntry: async (simId: string, iccid: string, mcc: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('deleteSubscriptionContainerCountryMappingEntry', 'simId', simId)
            // verify required parameter 'iccid' is not null or undefined
            assertParamExists('deleteSubscriptionContainerCountryMappingEntry', 'iccid', iccid)
            // verify required parameter 'mcc' is not null or undefined
            assertParamExists('deleteSubscriptionContainerCountryMappingEntry', 'mcc', mcc)
            const localVarPath = `/sims/{sim_id}/profiles/{iccid}/subscription_containers/country_mapping/{mcc}`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"iccid"}}`, encodeURIComponent(String(iccid)))
                .replace(`{${"mcc"}}`, encodeURIComponent(String(mcc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of the specified SIM.
         * @summary Disable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableSimTermination: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('disableSimTermination', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/disable_termination`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified SIM.
         * @summary Enable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSimTermination: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('enableSimTermination', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/enable_termination`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the identified container to become the active one on the Sim.
         * @summary Enables a subscription container.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} containerId Identifier of the target container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSubscriptionContainer: async (simId: string, iccid: string, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('enableSubscriptionContainer', 'simId', simId)
            // verify required parameter 'iccid' is not null or undefined
            assertParamExists('enableSubscriptionContainer', 'iccid', iccid)
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('enableSubscriptionContainer', 'containerId', containerId)
            const localVarPath = `/sims/{sim_id}/profiles/{iccid}/subscription_containers/{containerId}/enable`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"iccid"}}`, encodeURIComponent(String(iccid)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSim: async (simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('getDataFromSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/data`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a SIM record identified by the sim_id
         * @summary Get a SIM identified by sim_id
         * @param {string} simId Id of the target SIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSim: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('getSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} simId SIM ID of the target SIM.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimSessionEvents: async (simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('listSimSessionEvents', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/events/sessions`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List SIMs.
         * @param {number} [limit] Maximum number of SIMs to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSims: async (limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
         * @summary Get subscription container status.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionContainers: async (simId: string, iccid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('listSubscriptionContainers', 'simId', simId)
            // verify required parameter 'iccid' is not null or undefined
            assertParamExists('listSubscriptionContainers', 'iccid', iccid)
            const localVarPath = `/sims/{sim_id}/profiles/{iccid}/subscription_containers`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"iccid"}}`, encodeURIComponent(String(iccid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified SIM.
         * @summary Bulk insert or update SIM tags.
         * @param {string} simId SIM ID of the target SIM.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimTags: async (simId: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('putSimTags', 'simId', simId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putSimTags', 'tags', tags)
            const localVarPath = `/sims/{sim_id}/tags`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
         * @summary Updates subscription container country mapping entries.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubscriptionContainerCountryMappingEntries: async (simId: string, iccid: string, mappingEntries: MappingEntries, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('putSubscriptionContainerCountryMappingEntries', 'simId', simId)
            // verify required parameter 'iccid' is not null or undefined
            assertParamExists('putSubscriptionContainerCountryMappingEntries', 'iccid', iccid)
            // verify required parameter 'mappingEntries' is not null or undefined
            assertParamExists('putSubscriptionContainerCountryMappingEntries', 'mappingEntries', mappingEntries)
            const localVarPath = `/sims/{sim_id}/profiles/{iccid}/subscription_containers/country_mapping`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)))
                .replace(`{${"iccid"}}`, encodeURIComponent(String(iccid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mappingEntries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a SIM to an operator.
         * @summary Register SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {RegisterSimRequest} registerSimRequest A SIM registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSim: async (simId: string, registerSimRequest: RegisterSimRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('registerSim', 'simId', simId)
            // verify required parameter 'registerSimRequest' is not null or undefined
            assertParamExists('registerSim', 'registerSimRequest', registerSimRequest)
            const localVarPath = `/sims/{sim_id}/register`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerSimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers SIM to report SIM local info.
         * @summary Triggers SIM to report SIM local info.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSimLocalInfo: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('reportSimLocalInfo', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/report_local_info`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send SMS to the specified SIM.
         * @summary Send SMS to SIM
         * @param {string} simId SIM ID of the target SIM.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsToSim: async (simId: string, smsForwardingRequest: SmsForwardingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('sendSmsToSim', 'simId', simId)
            // verify required parameter 'smsForwardingRequest' is not null or undefined
            assertParamExists('sendSmsToSim', 'smsForwardingRequest', smsForwardingRequest)
            const localVarPath = `/sims/{sim_id}/send_sms`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smsForwardingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates expiry time of the specified SIM.
         * @summary Update expiry time of SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimExpiryTime: async (simId: string, request: ExpiryTime, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('setSimExpiryTime', 'simId', simId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('setSimExpiryTime', 'request', request)
            const localVarPath = `/sims/{sim_id}/set_expiry_time`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites a group for the specified SIM.
         * @summary Set Group id of a SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimGroup: async (simId: string, group: SetGroupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('setSimGroup', 'simId', simId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('setSimGroup', 'group', group)
            const localVarPath = `/sims/{sim_id}/set_group`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set IMEI that the SIM should be locked to.
         * @summary Set IMEI lock configuration for the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimImeiLock: async (simId: string, imeiLock?: SetImeiLockRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('setSimImeiLock', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/set_imei_lock`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imeiLock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the specified SIM to standby mode.
         * @summary Set SIM to standby mode.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimToStandby: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('setSimToStandby', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/set_to_standby`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspends the specified SIM
         * @summary Suspend SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSim: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('suspendSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/suspend`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified SIM.
         * @summary Terminate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSim: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('terminateSim', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/terminate`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes expiry time of specified SIM and changes it to indefinite.
         * @summary Delete expiry time of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimExpiryTime: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('unsetSimExpiryTime', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/unset_expiry_time`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group configuration from the specified SIM.
         * @summary Unset Group to SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimGroup: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('unsetSimGroup', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/unset_group`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove any existing IMEI lock configuration for the SIM.
         * @summary Unset IMEI lock configuration for SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimImeiLock: async (simId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('unsetSimImeiLock', 'simId', simId)
            const localVarPath = `/sims/{sim_id}/unset_imei_lock`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the speed class of the specified SIM.
         * @summary Update SIM speed class.
         * @param {string} simId SIM ID of the target SIM.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSimSpeedClass: async (simId: string, speedClass: UpdateSpeedClassRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('updateSimSpeedClass', 'simId', simId)
            // verify required parameter 'speedClass' is not null or undefined
            assertParamExists('updateSimSpeedClass', 'speedClass', speedClass)
            const localVarPath = `/sims/{sim_id}/update_speed_class`
                .replace(`{${"sim_id"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(speedClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimApi - functional programming interface
 * @export
 */
export const SimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimApiAxiosParamCreator(configuration)
    return {
        /**
         * Change status of specified SIM to active.
         * @summary Activate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateSim(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to trigger the OTA update of a new subscription container to a SIM profile. 
         * @summary Adds a new subscription container to a SIM profile
         * @param {string} simId Id of the target SIM
         * @param {string} iccid Iccid of the target profile
         * @param {InlineObject2} [subscriptionParameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubscription(simId, iccid, subscriptionParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change status of specified SIM to inactive.
         * @summary Deactivate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateSim(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes session for the specified SIM.
         * @summary Delete Session
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSimSession(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSimSession(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a tag from the specified SIM.
         * @summary Delete SIM tag.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSimTag(simId: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSimTag(simId, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete subscription container country mapping entries
         * @summary Delete subscription container mapping entries
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} mcc mobile country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriptionContainerCountryMappingEntry(simId, iccid, mcc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of the specified SIM.
         * @summary Disable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableSimTermination(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableSimTermination(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified SIM.
         * @summary Enable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableSimTermination(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableSimTermination(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the identified container to become the active one on the Sim.
         * @summary Enables a subscription container.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} containerId Identifier of the target container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableSubscriptionContainer(simId, iccid, containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFromSim(simId, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain a SIM record identified by the sim_id
         * @summary Get a SIM identified by sim_id
         * @param {string} simId Id of the target SIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSim(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} simId SIM ID of the target SIM.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSimSessionEvents(simId, from, to, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List SIMs.
         * @param {number} [limit] Maximum number of SIMs to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSims(limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSims(limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
         * @summary Get subscription container status.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionContainers(simId: string, iccid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionContainers(simId, iccid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified SIM.
         * @summary Bulk insert or update SIM tags.
         * @param {string} simId SIM ID of the target SIM.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSimTags(simId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
         * @summary Updates subscription container country mapping entries.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionContainerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSubscriptionContainerCountryMappingEntries(simId, iccid, mappingEntries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a SIM to an operator.
         * @summary Register SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {RegisterSimRequest} registerSimRequest A SIM registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSim(simId, registerSimRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers SIM to report SIM local info.
         * @summary Triggers SIM to report SIM local info.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSimLocalInfo(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportSimLocalInfo(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send SMS to the specified SIM.
         * @summary Send SMS to SIM
         * @param {string} simId SIM ID of the target SIM.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSmsToSim(simId, smsForwardingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates expiry time of the specified SIM.
         * @summary Update expiry time of SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSimExpiryTime(simId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites a group for the specified SIM.
         * @summary Set Group id of a SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSimGroup(simId: string, group: SetGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSimGroup(simId, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set IMEI that the SIM should be locked to.
         * @summary Set IMEI lock configuration for the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSimImeiLock(simId, imeiLock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the specified SIM to standby mode.
         * @summary Set SIM to standby mode.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSimToStandby(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSimToStandby(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Suspends the specified SIM
         * @summary Suspend SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suspendSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suspendSim(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified SIM.
         * @summary Terminate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSim(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSim(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes expiry time of specified SIM and changes it to indefinite.
         * @summary Delete expiry time of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetSimExpiryTime(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetSimExpiryTime(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the group configuration from the specified SIM.
         * @summary Unset Group to SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetSimGroup(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetSimGroup(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove any existing IMEI lock configuration for the SIM.
         * @summary Unset IMEI lock configuration for SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetSimImeiLock(simId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetSimImeiLock(simId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes the speed class of the specified SIM.
         * @summary Update SIM speed class.
         * @param {string} simId SIM ID of the target SIM.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSimSpeedClass(simId, speedClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SimApi - factory interface
 * @export
 */
export const SimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimApiFp(configuration)
    return {
        /**
         * Change status of specified SIM to active.
         * @summary Activate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateSim(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.activateSim(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to trigger the OTA update of a new subscription container to a SIM profile. 
         * @summary Adds a new subscription container to a SIM profile
         * @param {string} simId Id of the target SIM
         * @param {string} iccid Iccid of the target profile
         * @param {InlineObject2} [subscriptionParameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): AxiosPromise<SimProfile> {
            return localVarFp.addSubscription(simId, iccid, subscriptionParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Change status of specified SIM to inactive.
         * @summary Deactivate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateSim(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.deactivateSim(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes session for the specified SIM.
         * @summary Delete Session
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimSession(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.deleteSimSession(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tag from the specified SIM.
         * @summary Delete SIM tag.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimTag(simId: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSimTag(simId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete subscription container country mapping entries
         * @summary Delete subscription container mapping entries
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} mcc mobile country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): AxiosPromise<SubscriptionContainerStatus> {
            return localVarFp.deleteSubscriptionContainerCountryMappingEntry(simId, iccid, mcc, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of the specified SIM.
         * @summary Disable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableSimTermination(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.disableSimTermination(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified SIM.
         * @summary Enable termination of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSimTermination(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.enableSimTermination(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the identified container to become the active one on the Sim.
         * @summary Enables a subscription container.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {string} containerId Identifier of the target container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): AxiosPromise<SubscriptionContainerStatus> {
            return localVarFp.enableSubscriptionContainer(simId, iccid, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataFromSim(simId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain a SIM record identified by the sim_id
         * @summary Get a SIM identified by sim_id
         * @param {string} simId Id of the target SIM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSim(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.getSim(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} simId SIM ID of the target SIM.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>> {
            return localVarFp.listSimSessionEvents(simId, from, to, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List SIMs.
         * @param {number} [limit] Maximum number of SIMs to retrieve.
         * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSims(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Sim>> {
            return localVarFp.listSims(limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
         * @summary Get subscription container status.
         * @param {string} simId Sim Id of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionContainers(simId: string, iccid: string, options?: any): AxiosPromise<SubscriptionContainerStatus> {
            return localVarFp.listSubscriptionContainers(simId, iccid, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified SIM.
         * @summary Bulk insert or update SIM tags.
         * @param {string} simId SIM ID of the target SIM.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Sim> {
            return localVarFp.putSimTags(simId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
         * @summary Updates subscription container country mapping entries.
         * @param {string} simId SIM ID of the target SIM.
         * @param {string} iccid Iccid of the target profile
         * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): AxiosPromise<SubscriptionContainerStatus> {
            return localVarFp.putSubscriptionContainerCountryMappingEntries(simId, iccid, mappingEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a SIM to an operator.
         * @summary Register SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {RegisterSimRequest} registerSimRequest A SIM registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): AxiosPromise<Sim> {
            return localVarFp.registerSim(simId, registerSimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers SIM to report SIM local info.
         * @summary Triggers SIM to report SIM local info.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSimLocalInfo(simId: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.reportSimLocalInfo(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send SMS to the specified SIM.
         * @summary Send SMS to SIM
         * @param {string} simId SIM ID of the target SIM.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport> {
            return localVarFp.sendSmsToSim(simId, smsForwardingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates expiry time of the specified SIM.
         * @summary Update expiry time of SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): AxiosPromise<Sim> {
            return localVarFp.setSimExpiryTime(simId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites a group for the specified SIM.
         * @summary Set Group id of a SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimGroup(simId: string, group: SetGroupRequest, options?: any): AxiosPromise<Sim> {
            return localVarFp.setSimGroup(simId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Set IMEI that the SIM should be locked to.
         * @summary Set IMEI lock configuration for the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Sim> {
            return localVarFp.setSimImeiLock(simId, imeiLock, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the specified SIM to standby mode.
         * @summary Set SIM to standby mode.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimToStandby(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.setSimToStandby(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Suspends the specified SIM
         * @summary Suspend SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSim(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.suspendSim(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified SIM.
         * @summary Terminate SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSim(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.terminateSim(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes expiry time of specified SIM and changes it to indefinite.
         * @summary Delete expiry time of the SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimExpiryTime(simId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unsetSimExpiryTime(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group configuration from the specified SIM.
         * @summary Unset Group to SIM.
         * @param {string} simId SIM ID of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimGroup(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.unsetSimGroup(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove any existing IMEI lock configuration for the SIM.
         * @summary Unset IMEI lock configuration for SIM.
         * @param {string} simId Sim Id of the target SIM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetSimImeiLock(simId: string, options?: any): AxiosPromise<Sim> {
            return localVarFp.unsetSimImeiLock(simId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the speed class of the specified SIM.
         * @summary Update SIM speed class.
         * @param {string} simId SIM ID of the target SIM.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Sim> {
            return localVarFp.updateSimSpeedClass(simId, speedClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimApi - interface
 * @export
 * @interface SimApi
 */
export interface SimApiInterface {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    activateSim(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile. 
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any): AxiosPromise<SimProfile>;

    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deactivateSim(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSimSession(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSimTag(simId: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;

    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    disableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    enableSimTermination(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;

    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    getSim(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;

    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSims(limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Sim>>;

    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    listSubscriptionContainers(simId: string, iccid: string, options?: any): AxiosPromise<SubscriptionContainerStatus>;

    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Sim>;

    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any): AxiosPromise<SubscriptionContainerStatus>;

    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any): AxiosPromise<Sim>;

    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    reportSimLocalInfo(simId: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;

    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimExpiryTime(simId: string, request: ExpiryTime, options?: any): AxiosPromise<Sim>;

    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimGroup(simId: string, group: SetGroupRequest, options?: any): AxiosPromise<Sim>;

    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Sim>;

    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    setSimToStandby(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    suspendSim(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    terminateSim(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimExpiryTime(simId: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimGroup(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    unsetSimImeiLock(simId: string, options?: any): AxiosPromise<Sim>;

    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApiInterface
     */
    updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Sim>;

}

/**
 * SimApi - object-oriented interface
 * @export
 * @class SimApi
 * @extends {BaseAPI}
 */
export class SimApi extends BaseAPI implements SimApiInterface {
    /**
     * Change status of specified SIM to active.
     * @summary Activate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public activateSim(simId: string, options?: any) {
        return SimApiFp(this.configuration).activateSim(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to trigger the OTA update of a new subscription container to a SIM profile. 
     * @summary Adds a new subscription container to a SIM profile
     * @param {string} simId Id of the target SIM
     * @param {string} iccid Iccid of the target profile
     * @param {InlineObject2} [subscriptionParameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public addSubscription(simId: string, iccid: string, subscriptionParameters?: InlineObject2, options?: any) {
        return SimApiFp(this.configuration).addSubscription(simId, iccid, subscriptionParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change status of specified SIM to inactive.
     * @summary Deactivate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public deactivateSim(simId: string, options?: any) {
        return SimApiFp(this.configuration).deactivateSim(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes session for the specified SIM.
     * @summary Delete Session
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public deleteSimSession(simId: string, options?: any) {
        return SimApiFp(this.configuration).deleteSimSession(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tag from the specified SIM.
     * @summary Delete SIM tag.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public deleteSimTag(simId: string, tagName: string, options?: any) {
        return SimApiFp(this.configuration).deleteSimTag(simId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete subscription container country mapping entries
     * @summary Delete subscription container mapping entries
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} mcc mobile country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public deleteSubscriptionContainerCountryMappingEntry(simId: string, iccid: string, mcc: string, options?: any) {
        return SimApiFp(this.configuration).deleteSubscriptionContainerCountryMappingEntry(simId, iccid, mcc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of the specified SIM.
     * @summary Disable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public disableSimTermination(simId: string, options?: any) {
        return SimApiFp(this.configuration).disableSimTermination(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified SIM.
     * @summary Enable termination of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public enableSimTermination(simId: string, options?: any) {
        return SimApiFp(this.configuration).enableSimTermination(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the identified container to become the active one on the Sim.
     * @summary Enables a subscription container.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {string} containerId Identifier of the target container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public enableSubscriptionContainer(simId: string, iccid: string, containerId: string, options?: any) {
        return SimApiFp(this.configuration).enableSubscriptionContainer(simId, iccid, containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a SIM that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public getDataFromSim(simId: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SimApiFp(this.configuration).getDataFromSim(simId, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain a SIM record identified by the sim_id
     * @summary Get a SIM identified by sim_id
     * @param {string} simId Id of the target SIM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public getSim(simId: string, options?: any) {
        return SimApiFp(this.configuration).getSim(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the history of session creation, change, and deletion events occurred on the target SIM in the last 14 days. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} simId SIM ID of the target SIM.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public listSimSessionEvents(simId: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SimApiFp(this.configuration).listSimSessionEvents(simId, from, to, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of SIMs that match certain criteria. If the total number of SIMs does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List SIMs.
     * @param {number} [limit] Maximum number of SIMs to retrieve.
     * @param {string} [lastEvaluatedKey] The ID of the last SIM retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next SIM onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public listSims(limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SimApiFp(this.configuration).listSims(limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a schema listing subscription containers and containing a map of PLMN codes to subscription containers
     * @summary Get subscription container status.
     * @param {string} simId Sim Id of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public listSubscriptionContainers(simId: string, iccid: string, options?: any) {
        return SimApiFp(this.configuration).listSubscriptionContainers(simId, iccid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified SIM.
     * @summary Bulk insert or update SIM tags.
     * @param {string} simId SIM ID of the target SIM.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public putSimTags(simId: string, tags: Array<TagUpdateRequest>, options?: any) {
        return SimApiFp(this.configuration).putSimTags(simId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates Country (and optionally network) to subscription container mapping entries in the mapping table.
     * @summary Updates subscription container country mapping entries.
     * @param {string} simId SIM ID of the target SIM.
     * @param {string} iccid Iccid of the target profile
     * @param {MappingEntries} mappingEntries collection of country (and optionally network) to subscription container mapping entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public putSubscriptionContainerCountryMappingEntries(simId: string, iccid: string, mappingEntries: MappingEntries, options?: any) {
        return SimApiFp(this.configuration).putSubscriptionContainerCountryMappingEntries(simId, iccid, mappingEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a SIM to an operator.
     * @summary Register SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {RegisterSimRequest} registerSimRequest A SIM registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public registerSim(simId: string, registerSimRequest: RegisterSimRequest, options?: any) {
        return SimApiFp(this.configuration).registerSim(simId, registerSimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers SIM to report SIM local info.
     * @summary Triggers SIM to report SIM local info.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public reportSimLocalInfo(simId: string, options?: any) {
        return SimApiFp(this.configuration).reportSimLocalInfo(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send SMS to the specified SIM.
     * @summary Send SMS to SIM
     * @param {string} simId SIM ID of the target SIM.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public sendSmsToSim(simId: string, smsForwardingRequest: SmsForwardingRequest, options?: any) {
        return SimApiFp(this.configuration).sendSmsToSim(simId, smsForwardingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates expiry time of the specified SIM.
     * @summary Update expiry time of SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public setSimExpiryTime(simId: string, request: ExpiryTime, options?: any) {
        return SimApiFp(this.configuration).setSimExpiryTime(simId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites a group for the specified SIM.
     * @summary Set Group id of a SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public setSimGroup(simId: string, group: SetGroupRequest, options?: any) {
        return SimApiFp(this.configuration).setSimGroup(simId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set IMEI that the SIM should be locked to.
     * @summary Set IMEI lock configuration for the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the SIM. (IMEI can be left blank for locking to the current IMEI of an online SIM.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public setSimImeiLock(simId: string, imeiLock?: SetImeiLockRequest, options?: any) {
        return SimApiFp(this.configuration).setSimImeiLock(simId, imeiLock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the specified SIM to standby mode.
     * @summary Set SIM to standby mode.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public setSimToStandby(simId: string, options?: any) {
        return SimApiFp(this.configuration).setSimToStandby(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suspends the specified SIM
     * @summary Suspend SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public suspendSim(simId: string, options?: any) {
        return SimApiFp(this.configuration).suspendSim(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified SIM.
     * @summary Terminate SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public terminateSim(simId: string, options?: any) {
        return SimApiFp(this.configuration).terminateSim(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes expiry time of specified SIM and changes it to indefinite.
     * @summary Delete expiry time of the SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public unsetSimExpiryTime(simId: string, options?: any) {
        return SimApiFp(this.configuration).unsetSimExpiryTime(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group configuration from the specified SIM.
     * @summary Unset Group to SIM.
     * @param {string} simId SIM ID of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public unsetSimGroup(simId: string, options?: any) {
        return SimApiFp(this.configuration).unsetSimGroup(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove any existing IMEI lock configuration for the SIM.
     * @summary Unset IMEI lock configuration for SIM.
     * @param {string} simId Sim Id of the target SIM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public unsetSimImeiLock(simId: string, options?: any) {
        return SimApiFp(this.configuration).unsetSimImeiLock(simId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the speed class of the specified SIM.
     * @summary Update SIM speed class.
     * @param {string} simId SIM ID of the target SIM.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimApi
     */
    public updateSimSpeedClass(simId: string, speedClass: UpdateSpeedClassRequest, options?: any) {
        return SimApiFp(this.configuration).updateSimSpeedClass(simId, speedClass, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SoraletApi - axios parameter creator
 * @export
 */
export const SoraletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Soralet.
         * @summary Create a Soralet.
         * @param {CreateSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSoralet: async (request: CreateSoraletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createSoralet', 'request', request)
            const localVarPath = `/soralets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Soralet.
         * @summary Delete Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoralet: async (soraletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('deleteSoralet', 'soraletId', soraletId)
            const localVarPath = `/soralets/{soralet_id}`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Soralet version.
         * @summary Delete a Soralet version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {number} version Soralet version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoraletVersion: async (soraletId: string, version: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('deleteSoraletVersion', 'soraletId', soraletId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteSoraletVersion', 'version', version)
            const localVarPath = `/soralets/{soralet_id}/versions/{version}`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Soralet.
         * @summary Get a Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoralet: async (soraletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('getSoralet', 'soraletId', soraletId)
            const localVarPath = `/soralets/{soralet_id}`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of log messages from the specified Soralet.
         * @summary Get log messages from Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoraletLogs: async (soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('getSoraletLogs', 'soraletId', soraletId)
            const localVarPath = `/soralets/{soralet_id}/logs`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Soralet versions.
         * @summary List versions of Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoraletVersions: async (soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('listSoraletVersions', 'soraletId', soraletId)
            const localVarPath = `/soralets/{soralet_id}/versions`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Soralets.
         * @summary List Soralets.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response
         * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoralets: async (sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/soralets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute the specified Soralet with the specified arguments.
         * @summary Execute Soralet with arguments.
         * @param {string} soraletId The identifier of Soralet.
         * @param {ExecuteSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSoralet: async (soraletId: string, request: ExecuteSoraletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('testSoralet', 'soraletId', soraletId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('testSoralet', 'request', request)
            const localVarPath = `/soralets/{soralet_id}/test`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload code and create a new version.
         * @summary Upload code and create a new version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSoraletCode: async (soraletId: string, body: any, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'soraletId' is not null or undefined
            assertParamExists('uploadSoraletCode', 'soraletId', soraletId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadSoraletCode', 'body', body)
            const localVarPath = `/soralets/{soralet_id}/versions`
                .replace(`{${"soralet_id"}}`, encodeURIComponent(String(soraletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['content-type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SoraletApi - functional programming interface
 * @export
 */
export const SoraletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SoraletApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Soralet.
         * @summary Create a Soralet.
         * @param {CreateSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSoralet(request: CreateSoraletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSoralet(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the specified Soralet.
         * @summary Delete Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSoralet(soraletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSoralet(soraletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the specified Soralet version.
         * @summary Delete a Soralet version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {number} version Soralet version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSoraletVersion(soraletId: string, version: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSoraletVersion(soraletId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Soralet.
         * @summary Get a Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSoralet(soraletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Soralet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSoralet(soraletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of log messages from the specified Soralet.
         * @summary Get log messages from Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoraletLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSoraletLogs(soraletId, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Soralet versions.
         * @summary List versions of Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoraletVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSoraletVersions(soraletId, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Soralets.
         * @summary List Soralets.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response
         * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Soralet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSoralets(sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Execute the specified Soralet with the specified arguments.
         * @summary Execute Soralet with arguments.
         * @param {string} soraletId The identifier of Soralet.
         * @param {ExecuteSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSoraletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSoralet(soraletId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload code and create a new version.
         * @summary Upload code and create a new version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoraletVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSoraletCode(soraletId, body, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SoraletApi - factory interface
 * @export
 */
export const SoraletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SoraletApiFp(configuration)
    return {
        /**
         * Create a Soralet.
         * @summary Create a Soralet.
         * @param {CreateSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSoralet(request: CreateSoraletRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createSoralet(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified Soralet.
         * @summary Delete Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoralet(soraletId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSoralet(soraletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified Soralet version.
         * @summary Delete a Soralet version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {number} version Soralet version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoraletVersion(soraletId: string, version: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSoraletVersion(soraletId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Soralet.
         * @summary Get a Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoralet(soraletId: string, options?: any): AxiosPromise<Soralet> {
            return localVarFp.getSoralet(soraletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of log messages from the specified Soralet.
         * @summary Get log messages from Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletLog>> {
            return localVarFp.getSoraletLogs(soraletId, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Soralet versions.
         * @summary List versions of Soralet.
         * @param {string} soraletId The identifier of Soralet.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response.
         * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletVersion>> {
            return localVarFp.listSoraletVersions(soraletId, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Soralets.
         * @summary List Soralets.
         * @param {'asc' | 'desc'} [sort] Sort order
         * @param {number} [limit] The maximum number of items in a response
         * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Soralet>> {
            return localVarFp.listSoralets(sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute the specified Soralet with the specified arguments.
         * @summary Execute Soralet with arguments.
         * @param {string} soraletId The identifier of Soralet.
         * @param {ExecuteSoraletRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): AxiosPromise<ExecuteSoraletResponse> {
            return localVarFp.testSoralet(soraletId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload code and create a new version.
         * @summary Upload code and create a new version.
         * @param {string} soraletId The identifier of Soralet.
         * @param {any} body Content of the file to upload
         * @param {string} [contentType] Content type of the file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): AxiosPromise<SoraletVersion> {
            return localVarFp.uploadSoraletCode(soraletId, body, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SoraletApi - interface
 * @export
 * @interface SoraletApi
 */
export interface SoraletApiInterface {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    createSoralet(request: CreateSoraletRequest, options?: any): AxiosPromise<void>;

    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    deleteSoralet(soraletId: string, options?: any): AxiosPromise<void>;

    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    deleteSoraletVersion(soraletId: string, version: number, options?: any): AxiosPromise<void>;

    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    getSoralet(soraletId: string, options?: any): AxiosPromise<Soralet>;

    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletLog>>;

    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SoraletVersion>>;

    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Soralet>>;

    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any): AxiosPromise<ExecuteSoraletResponse>;

    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApiInterface
     */
    uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any): AxiosPromise<SoraletVersion>;

}

/**
 * SoraletApi - object-oriented interface
 * @export
 * @class SoraletApi
 * @extends {BaseAPI}
 */
export class SoraletApi extends BaseAPI implements SoraletApiInterface {
    /**
     * Create a Soralet.
     * @summary Create a Soralet.
     * @param {CreateSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public createSoralet(request: CreateSoraletRequest, options?: any) {
        return SoraletApiFp(this.configuration).createSoralet(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the specified Soralet.
     * @summary Delete Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public deleteSoralet(soraletId: string, options?: any) {
        return SoraletApiFp(this.configuration).deleteSoralet(soraletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the specified Soralet version.
     * @summary Delete a Soralet version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {number} version Soralet version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public deleteSoraletVersion(soraletId: string, version: number, options?: any) {
        return SoraletApiFp(this.configuration).deleteSoraletVersion(soraletId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Soralet.
     * @summary Get a Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public getSoralet(soraletId: string, options?: any) {
        return SoraletApiFp(this.configuration).getSoralet(soraletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of log messages from the specified Soralet.
     * @summary Get log messages from Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last log message retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next log message onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public getSoraletLogs(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SoraletApiFp(this.configuration).getSoraletLogs(soraletId, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Soralet versions.
     * @summary List versions of Soralet.
     * @param {string} soraletId The identifier of Soralet.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response.
     * @param {string} [lastEvaluatedKey] The identifier of the last version retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next version onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public listSoraletVersions(soraletId: string, sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SoraletApiFp(this.configuration).listSoraletVersions(soraletId, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Soralets.
     * @summary List Soralets.
     * @param {'asc' | 'desc'} [sort] Sort order
     * @param {number} [limit] The maximum number of items in a response
     * @param {string} [lastEvaluatedKey] The identifier of the last Soralet retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next Soralet onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public listSoralets(sort?: 'asc' | 'desc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SoraletApiFp(this.configuration).listSoralets(sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute the specified Soralet with the specified arguments.
     * @summary Execute Soralet with arguments.
     * @param {string} soraletId The identifier of Soralet.
     * @param {ExecuteSoraletRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public testSoralet(soraletId: string, request: ExecuteSoraletRequest, options?: any) {
        return SoraletApiFp(this.configuration).testSoralet(soraletId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload code and create a new version.
     * @summary Upload code and create a new version.
     * @param {string} soraletId The identifier of Soralet.
     * @param {any} body Content of the file to upload
     * @param {string} [contentType] Content type of the file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SoraletApi
     */
    public uploadSoraletCode(soraletId: string, body: any, contentType?: string, options?: any) {
        return SoraletApiFp(this.configuration).uploadSoraletCode(soraletId, body, contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Air Usage Report of All Subscribers.
         * @param {string} operatorId operator_id
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAirStats: async (operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('exportAirStats', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('exportAirStats', 'request', request)
            const localVarPath = `/stats/air/operators/{operator_id}/export`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (exportMode !== undefined) {
                localVarQueryParameter['export_mode'] = exportMode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Beam Usage Report of All Subscribers.
         * @param {string} operatorId operator ID
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBeamStats: async (operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('exportBeamStats', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('exportBeamStats', 'request', request)
            const localVarPath = `/stats/beam/operators/{operator_id}/export`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (exportMode !== undefined) {
                localVarQueryParameter['export_mode'] = exportMode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the usage report for the subscriber specified by the IMSI.
         * @summary Get Air Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirStats: async (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('getAirStats', 'imsi', imsi)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getAirStats', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getAirStats', 'to', to)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getAirStats', 'period', period)
            const localVarPath = `/stats/air/subscribers/{imsi}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the usage report for the SIM specified by the simId.
         * @summary Get Air Usage Report of SIM.
         * @param {string} simId SIM ID
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirStatsOfSim: async (simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'simId' is not null or undefined
            assertParamExists('getAirStatsOfSim', 'simId', simId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getAirStatsOfSim', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getAirStatsOfSim', 'to', to)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getAirStatsOfSim', 'period', period)
            const localVarPath = `/stats/air/sims/{simId}`
                .replace(`{${"simId"}}`, encodeURIComponent(String(simId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
         * @summary Get Beam Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeamStats: async (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('getBeamStats', 'imsi', imsi)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getBeamStats', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getBeamStats', 'to', to)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getBeamStats', 'period', period)
            const localVarPath = `/stats/beam/subscribers/{imsi}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the SORACOM Harvest usage report for the operator.
         * @summary Get \'Harvest usage report\' for the specified operator.
         * @param {string} operatorId operator_id
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHarvestExportedDataStats: async (operatorId: string, yearMonth?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getHarvestExportedDataStats', 'operatorId', operatorId)
            const localVarPath = `/stats/harvest/operators/{operator_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (yearMonth !== undefined) {
                localVarQueryParameter['year_month'] = yearMonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Napter audit logs\' monthly exported data stats
         * @summary Get Napter audit logs\' monthly exported data stats
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNapterAuditLogsExportedDataStats: async (yearMonth?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats/napter/audit_logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (yearMonth !== undefined) {
                localVarQueryParameter['year_month'] = yearMonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Air Usage Report of All Subscribers.
         * @param {string} operatorId operator_id
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAirStats(operatorId, request, exportMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Beam Usage Report of All Subscribers.
         * @param {string} operatorId operator ID
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportBeamStats(operatorId, request, exportMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the usage report for the subscriber specified by the IMSI.
         * @summary Get Air Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AirStatsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAirStats(imsi, from, to, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the usage report for the SIM specified by the simId.
         * @summary Get Air Usage Report of SIM.
         * @param {string} simId SIM ID
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AirStatsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAirStatsOfSim(simId, from, to, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
         * @summary Get Beam Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BeamStatsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBeamStats(imsi, from, to, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the SORACOM Harvest usage report for the operator.
         * @summary Get \'Harvest usage report\' for the specified operator.
         * @param {string} operatorId operator_id
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HarvestExportedDataStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHarvestExportedDataStats(operatorId, yearMonth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Napter audit logs\' monthly exported data stats
         * @summary Get Napter audit logs\' monthly exported data stats
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NapterAuditLogsExportedDataStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNapterAuditLogsExportedDataStats(yearMonth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Air Usage Report of All Subscribers.
         * @param {string} operatorId operator_id
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse> {
            return localVarFp.exportAirStats(operatorId, request, exportMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
         * @summary Export Beam Usage Report of All Subscribers.
         * @param {string} operatorId operator ID
         * @param {ExportRequest} request export time period
         * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse> {
            return localVarFp.exportBeamStats(operatorId, request, exportMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the usage report for the subscriber specified by the IMSI.
         * @summary Get Air Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>> {
            return localVarFp.getAirStats(imsi, from, to, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the usage report for the SIM specified by the simId.
         * @summary Get Air Usage Report of SIM.
         * @param {string} simId SIM ID
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>> {
            return localVarFp.getAirStatsOfSim(simId, from, to, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
         * @summary Get Beam Usage Report of Subscriber.
         * @param {string} imsi imsi
         * @param {number} from Start time in unixtime for the aggregate data.
         * @param {number} to End time in unixtime for the aggregate data.
         * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<BeamStatsResponse>> {
            return localVarFp.getBeamStats(imsi, from, to, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the SORACOM Harvest usage report for the operator.
         * @summary Get \'Harvest usage report\' for the specified operator.
         * @param {string} operatorId operator_id
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): AxiosPromise<HarvestExportedDataStatsResponse> {
            return localVarFp.getHarvestExportedDataStats(operatorId, yearMonth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Napter audit logs\' monthly exported data stats
         * @summary Get Napter audit logs\' monthly exported data stats
         * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): AxiosPromise<NapterAuditLogsExportedDataStatsResponse> {
            return localVarFp.getNapterAuditLogsExportedDataStats(yearMonth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - interface
 * @export
 * @interface StatsApi
 */
export interface StatsApiInterface {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;

    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any): AxiosPromise<FileExportResponse>;

    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;

    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<AirStatsResponse>>;

    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any): AxiosPromise<Array<BeamStatsResponse>>;

    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any): AxiosPromise<HarvestExportedDataStatsResponse>;

    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApiInterface
     */
    getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any): AxiosPromise<NapterAuditLogsExportedDataStatsResponse>;

}

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI implements StatsApiInterface {
    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Air Usage Report of All Subscribers.
     * @param {string} operatorId operator_id
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public exportAirStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any) {
        return StatsApiFp(this.configuration).exportAirStats(operatorId, request, exportMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a file containing the usage report of all subscribers for the specified operator. The report data range is specified with from, to in unixtime. The report contains monthly data. The file output destination is AWS S3. The file output format is CSV.
     * @summary Export Beam Usage Report of All Subscribers.
     * @param {string} operatorId operator ID
     * @param {ExportRequest} request export time period
     * @param {'async' | 'sync'} [exportMode] export_mode (async, sync)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public exportBeamStats(operatorId: string, request: ExportRequest, exportMode?: 'async' | 'sync', options?: any) {
        return StatsApiFp(this.configuration).exportBeamStats(operatorId, request, exportMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the usage report for the subscriber specified by the IMSI.
     * @summary Get Air Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getAirStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) {
        return StatsApiFp(this.configuration).getAirStats(imsi, from, to, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the usage report for the SIM specified by the simId.
     * @summary Get Air Usage Report of SIM.
     * @param {string} simId SIM ID
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getAirStatsOfSim(simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) {
        return StatsApiFp(this.configuration).getAirStatsOfSim(simId, from, to, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Soracom Beam usage report for the subscriber specified by the IMSI.
     * @summary Get Beam Usage Report of Subscriber.
     * @param {string} imsi imsi
     * @param {number} from Start time in unixtime for the aggregate data.
     * @param {number} to End time in unixtime for the aggregate data.
     * @param {'month' | 'day' | 'minutes'} period Units of aggregate data. For minutes, the interval is around 5 minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getBeamStats(imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options?: any) {
        return StatsApiFp(this.configuration).getBeamStats(imsi, from, to, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the SORACOM Harvest usage report for the operator.
     * @summary Get \'Harvest usage report\' for the specified operator.
     * @param {string} operatorId operator_id
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getHarvestExportedDataStats(operatorId: string, yearMonth?: string, options?: any) {
        return StatsApiFp(this.configuration).getHarvestExportedDataStats(operatorId, yearMonth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Napter audit logs\' monthly exported data stats
     * @summary Get Napter audit logs\' monthly exported data stats
     * @param {string} [yearMonth] Year/Month in \&#39;YYYYMM\&#39; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getNapterAuditLogsExportedDataStats(yearMonth?: string, options?: any) {
        return StatsApiFp(this.configuration).getNapterAuditLogsExportedDataStats(yearMonth, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriberApi - axios parameter creator
 * @export
 */
export const SubscriberApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates status of specified subscriber.
         * @summary Activate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('activateSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/activate`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates specified subscriber.
         * @summary Deactivate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('deactivateSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/deactivate`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes session for the specified subscriber.
         * @summary Delete Session
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberSession: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('deleteSubscriberSession', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/delete_session`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a tag from the specified subscriber.
         * @summary Delete Subscriber Tag.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberTag: async (imsi: string, tagName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('deleteSubscriberTag', 'imsi', imsi)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteSubscriberTag', 'tagName', tagName)
            const localVarPath = `/subscribers/{imsi}/tags/{tag_name}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
         * @summary Delete Subscribers Transfer Token.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberTransferToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteSubscriberTransferToken', 'token', token)
            const localVarPath = `/subscribers/transfer_token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables termination of specified subscriber.
         * @summary Disable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTermination: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('disableTermination', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/disable_termination`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables termination of specified subscriber.
         * @summary Enable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTermination: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('enableTermination', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/enable_termination`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a subscriber.
         * @param {string} imsi IMSI of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSubscriber: async (imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('getDataFromSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/data`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the specified subscriber.
         * @summary Get Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('getSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
         * @summary Issue Subscribers Transfer Token.
         * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriberTransferToken: async (request: IssueSubscriberTransferTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueSubscriberTransferToken', 'request', request)
            const localVarPath = `/subscribers/transfer_token/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessionEvents: async (imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('listSessionEvents', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/events/sessions`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Subscribers.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
         * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
         * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
         * @param {number} [limit] Maximum number of subscribers to retrieve.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribers: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscribers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (statusFilter !== undefined) {
                localVarQueryParameter['status_filter'] = statusFilter;
            }

            if (speedClassFilter !== undefined) {
                localVarQueryParameter['speed_class_filter'] = speedClassFilter;
            }

            if (serialNumberFilter !== undefined) {
                localVarQueryParameter['serial_number_filter'] = serialNumberFilter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets bundles to the specified subscriber.
         * @summary Set Bundles to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<string>} bundles Array of bundles to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBundles: async (imsi: string, bundles: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('putBundles', 'imsi', imsi)
            // verify required parameter 'bundles' is not null or undefined
            assertParamExists('putBundles', 'bundles', bundles)
            const localVarPath = `/subscribers/{imsi}/bundles`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bundles, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts/updates tags for the specified subscriber.
         * @summary Bulk Insert or Update Subscriber Tags.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubscriberTags: async (imsi: string, tags: Array<TagUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('putSubscriberTags', 'imsi', imsi)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('putSubscriberTags', 'tags', tags)
            const localVarPath = `/subscribers/{imsi}/tags`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a subscriber.
         * @summary Register Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {RegisterSubscribersRequest} subscriber subscriber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSubscriber: async (imsi: string, subscriber: RegisterSubscribersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('registerSubscriber', 'imsi', imsi)
            // verify required parameter 'subscriber' is not null or undefined
            assertParamExists('registerSubscriber', 'subscriber', subscriber)
            const localVarPath = `/subscribers/{imsi}/register`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriber, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers Subscriber to report SIM local info.
         * @summary Triggers Subscriber to report SIM local info.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportLocalInfo: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('reportLocalInfo', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/report_local_info`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send SMS to the specified subscriber.
         * @summary Send SMS to Subscriber
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSms: async (imsi: string, smsForwardingRequest: SmsForwardingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('sendSms', 'imsi', imsi)
            // verify required parameter 'smsForwardingRequest' is not null or undefined
            assertParamExists('sendSms', 'smsForwardingRequest', smsForwardingRequest)
            const localVarPath = `/subscribers/{imsi}/send_sms`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smsForwardingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send SMS to a subscriber specified with MSISDN.
         * @summary Send SMS to Subscriber by MSISDN
         * @param {string} msisdn MSISDN of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsByMsisdn: async (msisdn: string, smsForwardingRequest: SmsForwardingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'msisdn' is not null or undefined
            assertParamExists('sendSmsByMsisdn', 'msisdn', msisdn)
            // verify required parameter 'smsForwardingRequest' is not null or undefined
            assertParamExists('sendSmsByMsisdn', 'smsForwardingRequest', smsForwardingRequest)
            const localVarPath = `/subscribers/msisdn/{msisdn}/send_sms`
                .replace(`{${"msisdn"}}`, encodeURIComponent(String(msisdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smsForwardingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates expiry time of specified subscriber.
         * @summary Update Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExpiryTime: async (imsi: string, request: ExpiryTime, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('setExpiryTime', 'imsi', imsi)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('setExpiryTime', 'request', request)
            const localVarPath = `/subscribers/{imsi}/set_expiry_time`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or overwrites a group for the specified subscriber.
         * @summary Set Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroup: async (imsi: string, group: SetGroupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('setGroup', 'imsi', imsi)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('setGroup', 'group', group)
            const localVarPath = `/subscribers/{imsi}/set_group`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set IMEI that the subscriber should be locked to.
         * @summary Set IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setImeiLock: async (imsi: string, imeiLock?: SetImeiLockRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('setImeiLock', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/set_imei_lock`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imeiLock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the specified subscriber to standby mode.
         * @summary Set Subscriber to standby mode.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriberToStandby: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('setSubscriberToStandby', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/set_to_standby`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspends the specified subscriber
         * @summary Suspend Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('suspendSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/suspend`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified subscriber
         * @summary Terminate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriber: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('terminateSubscriber', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/terminate`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes expiry time of specified subscriber and changes it to indefinite.
         * @summary Delete Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetExpiryTime: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('unsetExpiryTime', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/unset_expiry_time`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group configuration from the specified subscriber.
         * @summary Unset Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetGroup: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('unsetGroup', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/unset_group`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove any existing IMEI lock configuration for the subscriber.
         * @summary Unset IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetImeiLock: async (imsi: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('unsetImeiLock', 'imsi', imsi)
            const localVarPath = `/subscribers/{imsi}/unset_imei_lock`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the speed class of the specified subscriber.
         * @summary Update Subscriber speed class.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpeedClass: async (imsi: string, speedClass: UpdateSpeedClassRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imsi' is not null or undefined
            assertParamExists('updateSpeedClass', 'imsi', imsi)
            // verify required parameter 'speedClass' is not null or undefined
            assertParamExists('updateSpeedClass', 'speedClass', speedClass)
            const localVarPath = `/subscribers/{imsi}/update_speed_class`
                .replace(`{${"imsi"}}`, encodeURIComponent(String(imsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(speedClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
         * @summary Verify Subscriber Transfer Token.
         * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifySubscriberTransferToken: async (token: VerifySubscriberTransferTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifySubscriberTransferToken', 'token', token)
            const localVarPath = `/subscribers/transfer_token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(token, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriberApi - functional programming interface
 * @export
 */
export const SubscriberApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriberApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates status of specified subscriber.
         * @summary Activate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivates specified subscriber.
         * @summary Deactivate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes session for the specified subscriber.
         * @summary Delete Session
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriberSession(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriberSession(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a tag from the specified subscriber.
         * @summary Delete Subscriber Tag.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriberTag(imsi: string, tagName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriberTag(imsi, tagName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
         * @summary Delete Subscribers Transfer Token.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriberTransferToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriberTransferToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables termination of specified subscriber.
         * @summary Disable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTermination(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTermination(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables termination of specified subscriber.
         * @summary Enable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTermination(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTermination(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a subscriber.
         * @param {string} imsi IMSI of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFromSubscriber(imsi, from, to, sort, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the specified subscriber.
         * @summary Get Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
         * @summary Issue Subscribers Transfer Token.
         * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueSubscriberTransferTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSubscriberTransferToken(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSessionEvents(imsi, from, to, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Subscribers.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
         * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
         * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
         * @param {number} [limit] Maximum number of subscribers to retrieve.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscriber>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscribers(tagName, tagValue, tagValueMatchMode, statusFilter, speedClassFilter, serialNumberFilter, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets bundles to the specified subscriber.
         * @summary Set Bundles to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<string>} bundles Array of bundles to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBundles(imsi: string, bundles: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBundles(imsi, bundles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inserts/updates tags for the specified subscriber.
         * @summary Bulk Insert or Update Subscriber Tags.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSubscriberTags(imsi, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a subscriber.
         * @summary Register Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {RegisterSubscribersRequest} subscriber subscriber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSubscriber(imsi, subscriber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers Subscriber to report SIM local info.
         * @summary Triggers Subscriber to report SIM local info.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportLocalInfo(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportLocalInfo(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send SMS to the specified subscriber.
         * @summary Send SMS to Subscriber
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSms(imsi, smsForwardingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send SMS to a subscriber specified with MSISDN.
         * @summary Send SMS to Subscriber by MSISDN
         * @param {string} msisdn MSISDN of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsForwardingReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSmsByMsisdn(msisdn, smsForwardingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates expiry time of specified subscriber.
         * @summary Update Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExpiryTime(imsi: string, request: ExpiryTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExpiryTime(imsi, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets or overwrites a group for the specified subscriber.
         * @summary Set Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroup(imsi: string, group: SetGroupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroup(imsi, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set IMEI that the subscriber should be locked to.
         * @summary Set IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setImeiLock(imsi, imeiLock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the specified subscriber to standby mode.
         * @summary Set Subscriber to standby mode.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSubscriberToStandby(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSubscriberToStandby(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Suspends the specified subscriber
         * @summary Suspend Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suspendSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suspendSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified subscriber
         * @summary Terminate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSubscriber(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSubscriber(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes expiry time of specified subscriber and changes it to indefinite.
         * @summary Delete Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetExpiryTime(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetExpiryTime(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the group configuration from the specified subscriber.
         * @summary Unset Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetGroup(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetGroup(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove any existing IMEI lock configuration for the subscriber.
         * @summary Unset IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetImeiLock(imsi: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetImeiLock(imsi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes the speed class of the specified subscriber.
         * @summary Update Subscriber speed class.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpeedClass(imsi, speedClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
         * @summary Verify Subscriber Transfer Token.
         * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifySubscriberTransferTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifySubscriberTransferToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriberApi - factory interface
 * @export
 */
export const SubscriberApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriberApiFp(configuration)
    return {
        /**
         * Activates status of specified subscriber.
         * @summary Activate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.activateSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates specified subscriber.
         * @summary Deactivate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.deactivateSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes session for the specified subscriber.
         * @summary Delete Session
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberSession(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.deleteSubscriberSession(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a tag from the specified subscriber.
         * @summary Delete Subscriber Tag.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberTag(imsi: string, tagName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscriberTag(imsi, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
         * @summary Delete Subscribers Transfer Token.
         * @param {string} token token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriberTransferToken(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscriberTransferToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables termination of specified subscriber.
         * @summary Disable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTermination(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.disableTermination(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables termination of specified subscriber.
         * @summary Enable Termination of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTermination(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.enableTermination(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary Get data sent from a subscriber.
         * @param {string} imsi IMSI of the target subscriber that generated data entries.
         * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
         * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
         * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
         * @param {number} [limit] Maximum number of data entries to retrieve.
         * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>> {
            return localVarFp.getDataFromSubscriber(imsi, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the specified subscriber.
         * @summary Get Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.getSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
         * @summary Issue Subscribers Transfer Token.
         * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): AxiosPromise<IssueSubscriberTransferTokenResponse> {
            return localVarFp.issueSubscriberTransferToken(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
         * @summary List Session Events.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {number} [from] Start time for the events search range (unixtime).
         * @param {number} [to] End time for the events search range (unixtime).
         * @param {number} [limit] Maximum number of events to retrieve.
         * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>> {
            return localVarFp.listSessionEvents(imsi, from, to, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
         * @summary List Subscribers.
         * @param {string} [tagName] Tag name for filtering the search (exact match).
         * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
         * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
         * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
         * @param {number} [limit] Maximum number of subscribers to retrieve.
         * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Subscriber>> {
            return localVarFp.listSubscribers(tagName, tagValue, tagValueMatchMode, statusFilter, speedClassFilter, serialNumberFilter, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets bundles to the specified subscriber.
         * @summary Set Bundles to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<string>} bundles Array of bundles to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBundles(imsi: string, bundles: Array<string>, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.putBundles(imsi, bundles, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts/updates tags for the specified subscriber.
         * @summary Bulk Insert or Update Subscriber Tags.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.putSubscriberTags(imsi, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a subscriber.
         * @summary Register Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {RegisterSubscribersRequest} subscriber subscriber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.registerSubscriber(imsi, subscriber, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers Subscriber to report SIM local info.
         * @summary Triggers Subscriber to report SIM local info.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportLocalInfo(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.reportLocalInfo(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Send SMS to the specified subscriber.
         * @summary Send SMS to Subscriber
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport> {
            return localVarFp.sendSms(imsi, smsForwardingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send SMS to a subscriber specified with MSISDN.
         * @summary Send SMS to Subscriber by MSISDN
         * @param {string} msisdn MSISDN of the target subscriber.
         * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport> {
            return localVarFp.sendSmsByMsisdn(msisdn, smsForwardingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates expiry time of specified subscriber.
         * @summary Update Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExpiryTime(imsi: string, request: ExpiryTime, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.setExpiryTime(imsi, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or overwrites a group for the specified subscriber.
         * @summary Set Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetGroupRequest} group Group (may include ID only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroup(imsi: string, group: SetGroupRequest, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.setGroup(imsi, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Set IMEI that the subscriber should be locked to.
         * @summary Set IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.setImeiLock(imsi, imeiLock, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the specified subscriber to standby mode.
         * @summary Set Subscriber to standby mode.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriberToStandby(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.setSubscriberToStandby(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Suspends the specified subscriber
         * @summary Suspend Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.suspendSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified subscriber
         * @summary Terminate Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.terminateSubscriber(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes expiry time of specified subscriber and changes it to indefinite.
         * @summary Delete Expiry Time of Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetExpiryTime(imsi: string, options?: any): AxiosPromise<void> {
            return localVarFp.unsetExpiryTime(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group configuration from the specified subscriber.
         * @summary Unset Group to Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetGroup(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.unsetGroup(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove any existing IMEI lock configuration for the subscriber.
         * @summary Unset IMEI lock configuration for Subscriber.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetImeiLock(imsi: string, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.unsetImeiLock(imsi, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the speed class of the specified subscriber.
         * @summary Update Subscriber speed class.
         * @param {string} imsi IMSI of the target subscriber.
         * @param {UpdateSpeedClassRequest} speedClass speed_class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Subscriber> {
            return localVarFp.updateSpeedClass(imsi, speedClass, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
         * @summary Verify Subscriber Transfer Token.
         * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): AxiosPromise<VerifySubscriberTransferTokenResponse> {
            return localVarFp.verifySubscriberTransferToken(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriberApi - interface
 * @export
 * @interface SubscriberApi
 */
export interface SubscriberApiInterface {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    activateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deactivateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberSession(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberTag(imsi: string, tagName: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    deleteSubscriberTransferToken(token: string, options?: any): AxiosPromise<void>;

    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    disableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    enableTermination(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<DataEntry>>;

    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    getSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any): AxiosPromise<IssueSubscriberTransferTokenResponse>;

    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<SessionEvent>>;

    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<Subscriber>>;

    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    putBundles(imsi: string, bundles: Array<string>, options?: any): AxiosPromise<Subscriber>;

    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any): AxiosPromise<Subscriber>;

    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any): AxiosPromise<Subscriber>;

    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    reportLocalInfo(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;

    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any): AxiosPromise<SmsForwardingReport>;

    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setExpiryTime(imsi: string, request: ExpiryTime, options?: any): AxiosPromise<Subscriber>;

    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setGroup(imsi: string, group: SetGroupRequest, options?: any): AxiosPromise<Subscriber>;

    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any): AxiosPromise<Subscriber>;

    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    setSubscriberToStandby(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    suspendSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    terminateSubscriber(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetExpiryTime(imsi: string, options?: any): AxiosPromise<void>;

    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetGroup(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    unsetImeiLock(imsi: string, options?: any): AxiosPromise<Subscriber>;

    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any): AxiosPromise<Subscriber>;

    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApiInterface
     */
    verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any): AxiosPromise<VerifySubscriberTransferTokenResponse>;

}

/**
 * SubscriberApi - object-oriented interface
 * @export
 * @class SubscriberApi
 * @extends {BaseAPI}
 */
export class SubscriberApi extends BaseAPI implements SubscriberApiInterface {
    /**
     * Activates status of specified subscriber.
     * @summary Activate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public activateSubscriber(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).activateSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates specified subscriber.
     * @summary Deactivate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public deactivateSubscriber(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).deactivateSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes session for the specified subscriber.
     * @summary Delete Session
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public deleteSubscriberSession(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).deleteSubscriberSession(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a tag from the specified subscriber.
     * @summary Delete Subscriber Tag.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {string} tagName Tag name to be deleted. (This will be part of a URL path, so it needs to be percent-encoded. In JavaScript, specify the name after it has been encoded using encodeURIComponent().)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public deleteSubscriberTag(imsi: string, tagName: string, options?: any) {
        return SubscriberApiFp(this.configuration).deleteSubscriberTag(imsi, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the subscriber\'s inter-operator control transfer token, and cancels the control transfer.
     * @summary Delete Subscribers Transfer Token.
     * @param {string} token token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public deleteSubscriberTransferToken(token: string, options?: any) {
        return SubscriberApiFp(this.configuration).deleteSubscriberTransferToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables termination of specified subscriber.
     * @summary Disable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public disableTermination(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).disableTermination(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables termination of specified subscriber.
     * @summary Enable Termination of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public enableTermination(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).enableTermination(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of data entries sent from a subscriber that match certain criteria. If the total number of entries does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary Get data sent from a subscriber.
     * @param {string} imsi IMSI of the target subscriber that generated data entries.
     * @param {number} [from] Start time for the data entries search range (unixtime in milliseconds).
     * @param {number} [to] End time for the data entries search range (unixtime in milliseconds).
     * @param {'desc' | 'asc'} [sort] Sort order of the data entries. Either descending (latest data entry first) or ascending (oldest data entry first).
     * @param {number} [limit] Maximum number of data entries to retrieve.
     * @param {string} [lastEvaluatedKey] The value of &#x60;time&#x60; in the last log entry retrieved in the previous page. By specifying this parameter, you can continue to retrieve the list from the next page onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public getDataFromSubscriber(imsi: string, from?: number, to?: number, sort?: 'desc' | 'asc', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SubscriberApiFp(this.configuration).getDataFromSubscriber(imsi, from, to, sort, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the specified subscriber.
     * @summary Get Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public getSubscriber(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).getSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends the subscriber\'s inter-operator control transfer token to the control destination operator.
     * @summary Issue Subscribers Transfer Token.
     * @param {IssueSubscriberTransferTokenRequest} request Destination operator\&#39;s email address, Operator ID, transferring IMSI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public issueSubscriberTransferToken(request: IssueSubscriberTransferTokenRequest, options?: any) {
        return SubscriberApiFp(this.configuration).issueSubscriberTransferToken(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the event history for the specified subscriber, including session creation, change, and deletion. If the total number of events does not fit in one page, a URL for accessing the next page is returned in the `Link` header of the response.
     * @summary List Session Events.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {number} [from] Start time for the events search range (unixtime).
     * @param {number} [to] End time for the events search range (unixtime).
     * @param {number} [limit] Maximum number of events to retrieve.
     * @param {string} [lastEvaluatedKey] The time stamp of the last event retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next event onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public listSessionEvents(imsi: string, from?: number, to?: number, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SubscriberApiFp(this.configuration).listSessionEvents(imsi, from, to, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of subscribers that match certain criteria. If the total number of subscribers does not fit in one page, a URL for accessing the next page is returned in the \'Link\' header of the response.
     * @summary List Subscribers.
     * @param {string} [tagName] Tag name for filtering the search (exact match).
     * @param {string} [tagValue] Tag search string for filtering the search. Required when &#x60;tag_name&#x60; has been specified.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {string} [statusFilter] Status for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;active&#x60;, &#x60;inactive&#x60;, &#x60;ready&#x60;, &#x60;instock&#x60;, &#x60;shipped&#x60;, &#x60;suspended&#x60;, and &#x60;terminated&#x60;.
     * @param {string} [speedClassFilter] Speed class for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Valid values include: &#x60;s1.minimum&#x60;, &#x60;s1.slow&#x60;, &#x60;s1.standard&#x60;, &#x60;s1.fast&#x60;
     * @param {string} [serialNumberFilter] Serial number for filtering the search. Can specify multiple values delimited by &#x60;|&#x60;. Returns subscribers with serial number starting with the specified value(s).
     * @param {number} [limit] Maximum number of subscribers to retrieve.
     * @param {string} [lastEvaluatedKey] The IMSI of the last subscriber retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next subscriber onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public listSubscribers(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', statusFilter?: string, speedClassFilter?: string, serialNumberFilter?: string, limit?: number, lastEvaluatedKey?: string, options?: any) {
        return SubscriberApiFp(this.configuration).listSubscribers(tagName, tagValue, tagValueMatchMode, statusFilter, speedClassFilter, serialNumberFilter, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets bundles to the specified subscriber.
     * @summary Set Bundles to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<string>} bundles Array of bundles to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public putBundles(imsi: string, bundles: Array<string>, options?: any) {
        return SubscriberApiFp(this.configuration).putBundles(imsi, bundles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts/updates tags for the specified subscriber.
     * @summary Bulk Insert or Update Subscriber Tags.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {Array<TagUpdateRequest>} tags Array of tags to be inserted/updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public putSubscriberTags(imsi: string, tags: Array<TagUpdateRequest>, options?: any) {
        return SubscriberApiFp(this.configuration).putSubscriberTags(imsi, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a subscriber.
     * @summary Register Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {RegisterSubscribersRequest} subscriber subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public registerSubscriber(imsi: string, subscriber: RegisterSubscribersRequest, options?: any) {
        return SubscriberApiFp(this.configuration).registerSubscriber(imsi, subscriber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers Subscriber to report SIM local info.
     * @summary Triggers Subscriber to report SIM local info.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public reportLocalInfo(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).reportLocalInfo(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send SMS to the specified subscriber.
     * @summary Send SMS to Subscriber
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public sendSms(imsi: string, smsForwardingRequest: SmsForwardingRequest, options?: any) {
        return SubscriberApiFp(this.configuration).sendSms(imsi, smsForwardingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send SMS to a subscriber specified with MSISDN.
     * @summary Send SMS to Subscriber by MSISDN
     * @param {string} msisdn MSISDN of the target subscriber.
     * @param {SmsForwardingRequest} smsForwardingRequest SMS forwarding request that contains message body and its encoding type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public sendSmsByMsisdn(msisdn: string, smsForwardingRequest: SmsForwardingRequest, options?: any) {
        return SubscriberApiFp(this.configuration).sendSmsByMsisdn(msisdn, smsForwardingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates expiry time of specified subscriber.
     * @summary Update Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {ExpiryTime} request Expiry time after the update (unixtime: in milliseconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public setExpiryTime(imsi: string, request: ExpiryTime, options?: any) {
        return SubscriberApiFp(this.configuration).setExpiryTime(imsi, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or overwrites a group for the specified subscriber.
     * @summary Set Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetGroupRequest} group Group (may include ID only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public setGroup(imsi: string, group: SetGroupRequest, options?: any) {
        return SubscriberApiFp(this.configuration).setGroup(imsi, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set IMEI that the subscriber should be locked to.
     * @summary Set IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {SetImeiLockRequest} [imeiLock] IMEI lock configuration for the subscriber. (IMEI can be left blank for locking to the current IMEI of an online subscriber.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public setImeiLock(imsi: string, imeiLock?: SetImeiLockRequest, options?: any) {
        return SubscriberApiFp(this.configuration).setImeiLock(imsi, imeiLock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the specified subscriber to standby mode.
     * @summary Set Subscriber to standby mode.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public setSubscriberToStandby(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).setSubscriberToStandby(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suspends the specified subscriber
     * @summary Suspend Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public suspendSubscriber(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).suspendSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified subscriber
     * @summary Terminate Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public terminateSubscriber(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).terminateSubscriber(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes expiry time of specified subscriber and changes it to indefinite.
     * @summary Delete Expiry Time of Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public unsetExpiryTime(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).unsetExpiryTime(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group configuration from the specified subscriber.
     * @summary Unset Group to Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public unsetGroup(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).unsetGroup(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove any existing IMEI lock configuration for the subscriber.
     * @summary Unset IMEI lock configuration for Subscriber.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public unsetImeiLock(imsi: string, options?: any) {
        return SubscriberApiFp(this.configuration).unsetImeiLock(imsi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the speed class of the specified subscriber.
     * @summary Update Subscriber speed class.
     * @param {string} imsi IMSI of the target subscriber.
     * @param {UpdateSpeedClassRequest} speedClass speed_class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public updateSpeedClass(imsi: string, speedClass: UpdateSpeedClassRequest, options?: any) {
        return SubscriberApiFp(this.configuration).updateSpeedClass(imsi, speedClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the subscriber\'s control transfer token, and executes the transfer. This API is called from the operator of the control destination.
     * @summary Verify Subscriber Transfer Token.
     * @param {VerifySubscriberTransferTokenRequest} token Subscriber transfer token that noficed via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriberApi
     */
    public verifySubscriberTransferToken(token: VerifySubscriberTransferTokenRequest, options?: any) {
        return SubscriberApiFp(this.configuration).verifySubscriberTransferToken(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemNotificationApi - axios parameter creator
 * @export
 */
export const SystemNotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a system notification.
         * @summary Delete system notification
         * @param {string} operatorId operator_id
         * @param {'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystemNotification: async (operatorId: string, type: 'billing', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteSystemNotification', 'operatorId', operatorId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteSystemNotification', 'type', type)
            const localVarPath = `/operators/{operator_id}/system_notifications/{type}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a system notification.
         * @summary Get system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemNotification: async (operatorId: string, type: 'primary' | 'recovery' | 'billing', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getSystemNotification', 'operatorId', operatorId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getSystemNotification', 'type', type)
            const localVarPath = `/operators/{operator_id}/system_notifications/{type}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of system notifications.
         * @summary List system notifications
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystemNotifications: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listSystemNotifications', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/system_notifications`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a system notification.
         * @summary Set system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {SetSystemNotificationsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemNotification: async (operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('setSystemNotification', 'operatorId', operatorId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('setSystemNotification', 'type', type)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('setSystemNotification', 'request', request)
            const localVarPath = `/operators/{operator_id}/system_notifications/{type}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemNotificationApi - functional programming interface
 * @export
 */
export const SystemNotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemNotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a system notification.
         * @summary Delete system notification
         * @param {string} operatorId operator_id
         * @param {'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSystemNotification(operatorId: string, type: 'billing', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSystemNotification(operatorId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a system notification.
         * @summary Get system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNotificationsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemNotification(operatorId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of system notifications.
         * @summary List system notifications
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSystemNotifications(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SystemNotificationsModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSystemNotifications(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets a system notification.
         * @summary Set system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {SetSystemNotificationsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNotificationsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSystemNotification(operatorId, type, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemNotificationApi - factory interface
 * @export
 */
export const SystemNotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemNotificationApiFp(configuration)
    return {
        /**
         * Deletes a system notification.
         * @summary Delete system notification
         * @param {string} operatorId operator_id
         * @param {'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystemNotification(operatorId: string, type: 'billing', options?: any): AxiosPromise<void> {
            return localVarFp.deleteSystemNotification(operatorId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a system notification.
         * @summary Get system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): AxiosPromise<SystemNotificationsModel> {
            return localVarFp.getSystemNotification(operatorId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of system notifications.
         * @summary List system notifications
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystemNotifications(operatorId: string, options?: any): AxiosPromise<Array<SystemNotificationsModel>> {
            return localVarFp.listSystemNotifications(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a system notification.
         * @summary Set system notification
         * @param {string} operatorId operator_id
         * @param {'primary' | 'recovery' | 'billing'} type system notification type
         * @param {SetSystemNotificationsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): AxiosPromise<SystemNotificationsModel> {
            return localVarFp.setSystemNotification(operatorId, type, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemNotificationApi - interface
 * @export
 * @interface SystemNotificationApi
 */
export interface SystemNotificationApiInterface {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    deleteSystemNotification(operatorId: string, type: 'billing', options?: any): AxiosPromise<void>;

    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any): AxiosPromise<SystemNotificationsModel>;

    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    listSystemNotifications(operatorId: string, options?: any): AxiosPromise<Array<SystemNotificationsModel>>;

    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApiInterface
     */
    setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any): AxiosPromise<SystemNotificationsModel>;

}

/**
 * SystemNotificationApi - object-oriented interface
 * @export
 * @class SystemNotificationApi
 * @extends {BaseAPI}
 */
export class SystemNotificationApi extends BaseAPI implements SystemNotificationApiInterface {
    /**
     * Deletes a system notification.
     * @summary Delete system notification
     * @param {string} operatorId operator_id
     * @param {'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    public deleteSystemNotification(operatorId: string, type: 'billing', options?: any) {
        return SystemNotificationApiFp(this.configuration).deleteSystemNotification(operatorId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a system notification.
     * @summary Get system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    public getSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', options?: any) {
        return SystemNotificationApiFp(this.configuration).getSystemNotification(operatorId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of system notifications.
     * @summary List system notifications
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    public listSystemNotifications(operatorId: string, options?: any) {
        return SystemNotificationApiFp(this.configuration).listSystemNotifications(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a system notification.
     * @summary Set system notification
     * @param {string} operatorId operator_id
     * @param {'primary' | 'recovery' | 'billing'} type system notification type
     * @param {SetSystemNotificationsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemNotificationApi
     */
    public setSystemNotification(operatorId: string, type: 'primary' | 'recovery' | 'billing', request: SetSystemNotificationsRequest, options?: any) {
        return SystemNotificationApiFp(this.configuration).setSystemNotification(operatorId, type, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new SAM user.
         * @summary Create User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (operatorId: string, userName: string, request: CreateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createUser', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('createUser', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createUser', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a password for the SAM user.
         * @summary Create Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserPasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPassword: async (operatorId: string, userName: string, request: CreateUserPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('createUserPassword', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('createUserPassword', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createUserPassword', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/password`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the SAM user.
         * @summary Delete User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteUser', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('deleteUser', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an AuthKey from the SAM user.
         * @summary Delete User AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAuthKey: async (operatorId: string, userName: string, authKeyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteUserAuthKey', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('deleteUserAuthKey', 'userName', userName)
            // verify required parameter 'authKeyId' is not null or undefined
            assertParamExists('deleteUserAuthKey', 'authKeyId', authKeyId)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/auth_keys/{auth_key_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)))
                .replace(`{${"auth_key_id"}}`, encodeURIComponent(String(authKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user\'s password.
         * @summary Delete Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPassword: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('deleteUserPassword', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('deleteUserPassword', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/password`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable SAM user\'s MFA
         * @summary Enable SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableUserMFA: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('enableUserMFA', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('enableUserMFA', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an AuthKey for the SAM user.
         * @summary Generate AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUserAuthKey: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('generateUserAuthKey', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('generateUserAuthKey', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/auth_keys`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the default permissions rule that is applied to all of the SAM users
         * @summary Get the default permissions
         * @param {string} operatorId Operator ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultPermissions: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getDefaultPermissions', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/users/default_permissions`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a SAM user.
         * @summary Get User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getUser', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUser', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the SAM user\'s AuthKey.
         * @summary Get AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthKey: async (operatorId: string, userName: string, authKeyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getUserAuthKey', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserAuthKey', 'userName', userName)
            // verify required parameter 'authKeyId' is not null or undefined
            assertParamExists('getUserAuthKey', 'authKeyId', authKeyId)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/auth_keys/{auth_key_id}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)))
                .replace(`{${"auth_key_id"}}`, encodeURIComponent(String(authKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SAM user\'s MFA status
         * @summary Get SAM user\'s MFA status
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getUserMFAStatus', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserMFAStatus', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the SAM user\'s permissions.
         * @summary Get User Permission.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermission: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('getUserPermission', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserPermission', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/permission`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves whether the SAM user has a password or not.
         * @summary Has User Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasUserPassword: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('hasUserPassword', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('hasUserPassword', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/password`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the SAM user\'s AuthKey list.
         * @summary List User AuthKeys.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAuthKeys: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listUserAuthKeys', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('listUserAuthKeys', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/auth_keys`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of SAM users.
         * @summary List Users.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (operatorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('listUsers', 'operatorId', operatorId)
            const localVarPath = `/operators/{operator_id}/users`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke SAM user\'s MFA
         * @summary Revoke SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserMFA: async (operatorId: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('revokeUserMFA', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('revokeUserMFA', 'userName', userName)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/mfa`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the default permissions rule that is applied to all of the SAM
         * @summary Update the default permissions
         * @param {string} operatorId Operator ID
         * @param {UpdateDefaultPermissionsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultPermissions: async (operatorId: string, request: UpdateDefaultPermissionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateDefaultPermissions', 'operatorId', operatorId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateDefaultPermissions', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/default_permissions`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the SAM user.
         * @summary Update User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (operatorId: string, userName: string, request: UpdateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateUser', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('updateUser', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateUser', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the password of the SAM user.
         * @summary Update Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdatePasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (operatorId: string, userName: string, request: UpdatePasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateUserPassword', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('updateUserPassword', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateUserPassword', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/password`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the SAM user\'s permissions.
         * @summary Update Permission to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {SetUserPermissionRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPermission: async (operatorId: string, userName: string, request: SetUserPermissionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('updateUserPermission', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('updateUserPermission', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateUserPermission', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/permission`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify SAM user\'s MFA OTP code when MFA activation phase
         * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserMFA: async (operatorId: string, userName: string, request: MFAAuthenticationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('verifyUserMFA', 'operatorId', operatorId)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('verifyUserMFA', 'userName', userName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('verifyUserMFA', 'request', request)
            const localVarPath = `/operators/{operator_id}/users/{user_name}/mfa/verify`
                .replace(`{${"operator_id"}}`, encodeURIComponent(String(operatorId)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new SAM user.
         * @summary Create User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a password for the SAM user.
         * @summary Create Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserPasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserPassword(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the SAM user.
         * @summary Delete User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an AuthKey from the SAM user.
         * @summary Delete User AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAuthKey(operatorId, userName, authKeyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user\'s password.
         * @summary Delete Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPassword(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPassword(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable SAM user\'s MFA
         * @summary Enable SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableUserMFA(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMFAOTPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableUserMFA(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates an AuthKey for the SAM user.
         * @summary Generate AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateUserAuthKey(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateUserAuthKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateUserAuthKey(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the default permissions rule that is applied to all of the SAM users
         * @summary Get the default permissions
         * @param {string} operatorId Operator ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultPermissions(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDefaultPermissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultPermissions(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a SAM user.
         * @summary Get User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the SAM user\'s AuthKey.
         * @summary Get AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAuthKey(operatorId, userName, authKeyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get SAM user\'s MFA status
         * @summary Get SAM user\'s MFA status
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMFAStatus(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MFAStatusOfUseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMFAStatus(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the SAM user\'s permissions.
         * @summary Get User Permission.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPermission(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermission(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves whether the SAM user has a password or not.
         * @summary Has User Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasUserPassword(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasUserPassword(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the SAM user\'s AuthKey list.
         * @summary List User AuthKeys.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAuthKeys(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAuthKeys(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of SAM users.
         * @summary List Users.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(operatorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(operatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revoke SAM user\'s MFA
         * @summary Revoke SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserMFA(operatorId: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserMFA(operatorId, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the default permissions rule that is applied to all of the SAM
         * @summary Update the default permissions
         * @param {string} operatorId Operator ID
         * @param {UpdateDefaultPermissionsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefaultPermissions(operatorId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the SAM user.
         * @summary Update User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the password of the SAM user.
         * @summary Update Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdatePasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the SAM user\'s permissions.
         * @summary Update Permission to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {SetUserPermissionRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPermission(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify SAM user\'s MFA OTP code when MFA activation phase
         * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyUserMFA(operatorId, userName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Adds a new SAM user.
         * @summary Create User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUser(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a password for the SAM user.
         * @summary Create Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {CreateUserPasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserPassword(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the SAM user.
         * @summary Delete User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(operatorId: string, userName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an AuthKey from the SAM user.
         * @summary Delete User AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAuthKey(operatorId, userName, authKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user\'s password.
         * @summary Delete Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserPassword(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable SAM user\'s MFA
         * @summary Enable SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<EnableMFAOTPResponse> {
            return localVarFp.enableUserMFA(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an AuthKey for the SAM user.
         * @summary Generate AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUserAuthKey(operatorId: string, userName: string, options?: any): AxiosPromise<GenerateUserAuthKeyResponse> {
            return localVarFp.generateUserAuthKey(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the default permissions rule that is applied to all of the SAM users
         * @summary Get the default permissions
         * @param {string} operatorId Operator ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultPermissions(operatorId: string, options?: any): AxiosPromise<GetDefaultPermissionsResponse> {
            return localVarFp.getDefaultPermissions(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a SAM user.
         * @summary Get User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(operatorId: string, userName: string, options?: any): AxiosPromise<UserDetailResponse> {
            return localVarFp.getUser(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the SAM user\'s AuthKey.
         * @summary Get AuthKey.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {string} authKeyId auth_key_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<AuthKeyResponse> {
            return localVarFp.getUserAuthKey(operatorId, userName, authKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SAM user\'s MFA status
         * @summary Get SAM user\'s MFA status
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus(operatorId: string, userName: string, options?: any): AxiosPromise<MFAStatusOfUseResponse> {
            return localVarFp.getUserMFAStatus(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the SAM user\'s permissions.
         * @summary Get User Permission.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermission(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPermissionResponse> {
            return localVarFp.getUserPermission(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves whether the SAM user has a password or not.
         * @summary Has User Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPasswordResponse> {
            return localVarFp.hasUserPassword(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the SAM user\'s AuthKey list.
         * @summary List User AuthKeys.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAuthKeys(operatorId: string, userName: string, options?: any): AxiosPromise<Array<AuthKeyResponse>> {
            return localVarFp.listUserAuthKeys(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of SAM users.
         * @summary List Users.
         * @param {string} operatorId operator_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(operatorId: string, options?: any): AxiosPromise<Array<UserDetailResponse>> {
            return localVarFp.listUsers(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke SAM user\'s MFA
         * @summary Revoke SAM user\'s MFA
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeUserMFA(operatorId, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the default permissions rule that is applied to all of the SAM
         * @summary Update the default permissions
         * @param {string} operatorId Operator ID
         * @param {UpdateDefaultPermissionsRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDefaultPermissions(operatorId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the SAM user.
         * @summary Update User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdateUserRequest} request description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the password of the SAM user.
         * @summary Update Password.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {UpdatePasswordRequest} request password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the SAM user\'s permissions.
         * @summary Update Permission to User.
         * @param {string} operatorId operator_id
         * @param {string} userName user_name
         * @param {SetUserPermissionRequest} request permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPermission(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify SAM user\'s MFA OTP code when MFA activation phase
         * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
         * @param {string} operatorId Operator ID
         * @param {string} userName SAM user name
         * @param {MFAAuthenticationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyUserMFA(operatorId, userName, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any): AxiosPromise<void>;

    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any): AxiosPromise<void>;

    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(operatorId: string, userName: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<void>;

    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<void>;

    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    enableUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<EnableMFAOTPResponse>;

    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    generateUserAuthKey(operatorId: string, userName: string, options?: any): AxiosPromise<GenerateUserAuthKeyResponse>;

    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getDefaultPermissions(operatorId: string, options?: any): AxiosPromise<GetDefaultPermissionsResponse>;

    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(operatorId: string, userName: string, options?: any): AxiosPromise<UserDetailResponse>;

    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any): AxiosPromise<AuthKeyResponse>;

    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserMFAStatus(operatorId: string, userName: string, options?: any): AxiosPromise<MFAStatusOfUseResponse>;

    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserPermission(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPermissionResponse>;

    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    hasUserPassword(operatorId: string, userName: string, options?: any): AxiosPromise<GetUserPasswordResponse>;

    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUserAuthKeys(operatorId: string, userName: string, options?: any): AxiosPromise<Array<AuthKeyResponse>>;

    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listUsers(operatorId: string, options?: any): AxiosPromise<Array<UserDetailResponse>>;

    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    revokeUserMFA(operatorId: string, userName: string, options?: any): AxiosPromise<void>;

    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any): AxiosPromise<void>;

    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any): AxiosPromise<void>;

    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any): AxiosPromise<void>;

    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any): AxiosPromise<void>;

    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any): AxiosPromise<void>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Adds a new SAM user.
     * @summary Create User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(operatorId: string, userName: string, request: CreateUserRequest, options?: any) {
        return UserApiFp(this.configuration).createUser(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a password for the SAM user.
     * @summary Create Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {CreateUserPasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserPassword(operatorId: string, userName: string, request: CreateUserPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).createUserPassword(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the SAM user.
     * @summary Delete User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an AuthKey from the SAM user.
     * @summary Delete User AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any) {
        return UserApiFp(this.configuration).deleteUserAuthKey(operatorId, userName, authKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user\'s password.
     * @summary Delete Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserPassword(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).deleteUserPassword(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable SAM user\'s MFA
     * @summary Enable SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public enableUserMFA(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).enableUserMFA(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an AuthKey for the SAM user.
     * @summary Generate AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public generateUserAuthKey(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).generateUserAuthKey(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the default permissions rule that is applied to all of the SAM users
     * @summary Get the default permissions
     * @param {string} operatorId Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getDefaultPermissions(operatorId: string, options?: any) {
        return UserApiFp(this.configuration).getDefaultPermissions(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a SAM user.
     * @summary Get User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).getUser(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the SAM user\'s AuthKey.
     * @summary Get AuthKey.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {string} authKeyId auth_key_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserAuthKey(operatorId: string, userName: string, authKeyId: string, options?: any) {
        return UserApiFp(this.configuration).getUserAuthKey(operatorId, userName, authKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SAM user\'s MFA status
     * @summary Get SAM user\'s MFA status
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserMFAStatus(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).getUserMFAStatus(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the SAM user\'s permissions.
     * @summary Get User Permission.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserPermission(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).getUserPermission(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves whether the SAM user has a password or not.
     * @summary Has User Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public hasUserPassword(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).hasUserPassword(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the SAM user\'s AuthKey list.
     * @summary List User AuthKeys.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserAuthKeys(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).listUserAuthKeys(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of SAM users.
     * @summary List Users.
     * @param {string} operatorId operator_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUsers(operatorId: string, options?: any) {
        return UserApiFp(this.configuration).listUsers(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke SAM user\'s MFA
     * @summary Revoke SAM user\'s MFA
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeUserMFA(operatorId: string, userName: string, options?: any) {
        return UserApiFp(this.configuration).revokeUserMFA(operatorId, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the default permissions rule that is applied to all of the SAM
     * @summary Update the default permissions
     * @param {string} operatorId Operator ID
     * @param {UpdateDefaultPermissionsRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateDefaultPermissions(operatorId: string, request: UpdateDefaultPermissionsRequest, options?: any) {
        return UserApiFp(this.configuration).updateDefaultPermissions(operatorId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the SAM user.
     * @summary Update User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdateUserRequest} request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(operatorId: string, userName: string, request: UpdateUserRequest, options?: any) {
        return UserApiFp(this.configuration).updateUser(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the password of the SAM user.
     * @summary Update Password.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {UpdatePasswordRequest} request password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(operatorId: string, userName: string, request: UpdatePasswordRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPassword(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the SAM user\'s permissions.
     * @summary Update Permission to User.
     * @param {string} operatorId operator_id
     * @param {string} userName user_name
     * @param {SetUserPermissionRequest} request permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPermission(operatorId: string, userName: string, request: SetUserPermissionRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPermission(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify SAM user\'s MFA OTP code when MFA activation phase
     * @summary Verify SAM user\'s MFA OTP code when MFA activation phase
     * @param {string} operatorId Operator ID
     * @param {string} userName SAM user name
     * @param {MFAAuthenticationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyUserMFA(operatorId: string, userName: string, request: MFAAuthenticationRequest, options?: any) {
        return UserApiFp(this.configuration).verifyUserMFA(operatorId, userName, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VirtualPrivateGatewayApi - axios parameter creator
 * @export
 */
export const VirtualPrivateGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close SORACOM Gate on the specified VPG.
         * @summary Close SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeGate: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('closeGate', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/gate/close`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add node in the list of Junction mirroring peers
         * @summary Add node in the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMirroringPeer: async (vpgId: string, mirroringPeer: JunctionMirroringPeer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('createMirroringPeer', 'vpgId', vpgId)
            // verify required parameter 'mirroringPeer' is not null or undefined
            assertParamExists('createMirroringPeer', 'mirroringPeer', mirroringPeer)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/mirroring/peers`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mirroringPeer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a packet capture sessins associated the VPG
         * @summary Create Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPacketCaptureSession: async (vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('createPacketCaptureSession', 'vpgId', vpgId)
            // verify required parameter 'packetCaptureSessionRequest' is not null or undefined
            assertParamExists('createPacketCaptureSession', 'packetCaptureSessionRequest', packetCaptureSessionRequest)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/packet_capture_sessions`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packetCaptureSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new VPG.
         * @summary Create Virtual Private Gateway.
         * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualPrivateGateway: async (createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVirtualPrivateGatewayRequest' is not null or undefined
            assertParamExists('createVirtualPrivateGateway', 'createVirtualPrivateGatewayRequest', createVirtualPrivateGatewayRequest)
            const localVarPath = `/virtual_private_gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVirtualPrivateGatewayRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a VPC peering connection for the specified VPG.
         * @summary Create VPC Peering Connection
         * @param {string} vpgId Target VPG ID.
         * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVpcPeeringConnection: async (vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('createVpcPeeringConnection', 'vpgId', vpgId)
            // verify required parameter 'vpcPeeringConnection' is not null or undefined
            assertParamExists('createVpcPeeringConnection', 'vpcPeeringConnection', vpcPeeringConnection)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/vpc_peering_connections`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vpcPeeringConnection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove peer from the list of Junction mirroring peers
         * @summary Remove peer from the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr IP address of mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMirroringPeer: async (vpgId: string, ipaddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('deleteMirroringPeer', 'vpgId', vpgId)
            // verify required parameter 'ipaddr' is not null or undefined
            assertParamExists('deleteMirroringPeer', 'ipaddr', ipaddr)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"ipaddr"}}`, encodeURIComponent(String(ipaddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a packet capture sessins associated the VPG
         * @summary Delete Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePacketCaptureSession: async (vpgId: string, sessionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('deletePacketCaptureSession', 'vpgId', vpgId)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deletePacketCaptureSession', 'sessionId', sessionId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an entry in VPG IP address map.
         * @summary Delete VPG IP address map entry
         * @param {string} vpgId Target VPG ID.
         * @param {string} key Target key to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualPrivateGatewayIpAddressMapEntry: async (vpgId: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('deleteVirtualPrivateGatewayIpAddressMapEntry', 'vpgId', vpgId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteVirtualPrivateGatewayIpAddressMapEntry', 'key', key)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/ip_address_map/{key}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified VPC peering connection.
         * @summary Delete VPC Peering Connection.
         * @param {string} vpgId Target VPG ID.
         * @param {string} pcxId VPC peering connection ID to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVpcPeeringConnection: async (vpgId: string, pcxId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('deleteVpcPeeringConnection', 'vpgId', vpgId)
            // verify required parameter 'pcxId' is not null or undefined
            assertParamExists('deleteVpcPeeringConnection', 'pcxId', pcxId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/vpc_peering_connections/{pcx_id}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"pcx_id"}}`, encodeURIComponent(String(pcxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a packet capture sessins associated the VPG
         * @summary Get Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPacketCaptureSession: async (vpgId: string, sessionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('getPacketCaptureSession', 'vpgId', vpgId)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getPacketCaptureSession', 'sessionId', sessionId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/packet_capture_sessions/{session_id}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about the specified VPG.
         * @summary Get Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualPrivateGateway: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('getVirtualPrivateGateway', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Gate peers registered in the Virtual Private Gateway
         * @summary List VPG Gate peers
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatePeers: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('listGatePeers', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/gate/peers`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List packet capture sessins associated with the VPG
         * @summary List Packet Capture Sessions
         * @param {string} vpgId VPG ID
         * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
         * @param {number} [limit] Max number of results in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacketCaptureSessions: async (vpgId: string, lastEvaluatedKey?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('listPacketCaptureSessions', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/packet_capture_sessions`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Describes the list of IP addresse map entries in the Virtual Private Gateway
         * @summary List VPG IP address map entries
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualPrivateGatewayIpAddressMapEntries: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('listVirtualPrivateGatewayIpAddressMapEntries', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/ip_address_map`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of VPGs.
         * @summary List Virtual Private Gateways.
         * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the VPGs.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualPrivateGateways: async (tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtual_private_gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)

            if (tagName !== undefined) {
                localVarQueryParameter['tag_name'] = tagName;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag_value'] = tagValue;
            }

            if (tagValueMatchMode !== undefined) {
                localVarQueryParameter['tag_value_match_mode'] = tagValueMatchMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastEvaluatedKey !== undefined) {
                localVarQueryParameter['last_evaluated_key'] = lastEvaluatedKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open SORACOM Gate on the specified VPG.
         * @summary Open SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openGate: async (vpgId: string, configurationParameters?: OpenGateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('openGate', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/gate/open`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Puts an entry in VPG IP address map.
         * @summary Put an entry in VPG IP address map
         * @param {string} vpgId Target VPG ID.
         * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVirtualPrivateGatewayIpAddressMapEntry: async (vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('putVirtualPrivateGatewayIpAddressMapEntry', 'vpgId', vpgId)
            // verify required parameter 'putIpAddressMapEntryRequest' is not null or undefined
            assertParamExists('putVirtualPrivateGatewayIpAddressMapEntry', 'putIpAddressMapEntryRequest', putIpAddressMapEntryRequest)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/ip_address_map`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putIpAddressMapEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a host as a gate peer in the Virtual Private Gateway
         * @summary Register VPG Gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {RegisterGatePeerRequest} gatePeer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGatePeer: async (vpgId: string, gatePeer: RegisterGatePeerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('registerGatePeer', 'vpgId', vpgId)
            // verify required parameter 'gatePeer' is not null or undefined
            assertParamExists('registerGatePeer', 'gatePeer', gatePeer)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/gate/peers`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gatePeer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set configuration for Junction inspection feature
         * @summary Set configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInspectionConfiguration: async (vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('setInspectionConfiguration', 'vpgId', vpgId)
            // verify required parameter 'inspectionConfiguration' is not null or undefined
            assertParamExists('setInspectionConfiguration', 'inspectionConfiguration', inspectionConfiguration)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/set_inspection`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inspectionConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set configuration for Junction redirection feature
         * @summary Set configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRedirectionConfiguration: async (vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('setRedirectionConfiguration', 'vpgId', vpgId)
            // verify required parameter 'redirectionConfiguration' is not null or undefined
            assertParamExists('setRedirectionConfiguration', 'redirectionConfiguration', redirectionConfiguration)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/set_redirection`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirectionConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets Virtual Private Gateway outbound routing filter.
         * @summary Sets Virtual Private Gateway outbound routing filter.
         * @param {string} vpgId Target VPG ID.
         * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutingFilter: async (vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('setRoutingFilter', 'vpgId', vpgId)
            // verify required parameter 'routingFilterEntries' is not null or undefined
            assertParamExists('setRoutingFilter', 'routingFilterEntries', routingFilterEntries)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/set_routing_filter`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routingFilterEntries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the specified VPG.
         * @summary Terminate Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateVirtualPrivateGateway: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('terminateVirtualPrivateGateway', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/terminate`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unregister a gate peer from the Virtual Private Gateway
         * @summary Unregister VPG gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {string} outerIpAddress ID of the target node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterGatePeer: async (vpgId: string, outerIpAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('unregisterGatePeer', 'vpgId', vpgId)
            // verify required parameter 'outerIpAddress' is not null or undefined
            assertParamExists('unregisterGatePeer', 'outerIpAddress', outerIpAddress)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/gate/peers/{outer_ip_address}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"outer_ip_address"}}`, encodeURIComponent(String(outerIpAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unset configuration for Junction inspection feature
         * @summary Unset configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetInspectionConfiguration: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('unsetInspectionConfiguration', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/unset_inspection`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unset configuration for Junction redirection feature
         * @summary Unset configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetRedirectionConfiguration: async (vpgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('unsetRedirectionConfiguration', 'vpgId', vpgId)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/unset_redirection`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Junction mirroring peer
         * @summary Update a Junction mirroring peer
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr Mirroring peer IP address
         * @param {Array<AttributeUpdate>} updates List of attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMirroringPeer: async (vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'vpgId' is not null or undefined
            assertParamExists('updateMirroringPeer', 'vpgId', vpgId)
            // verify required parameter 'ipaddr' is not null or undefined
            assertParamExists('updateMirroringPeer', 'ipaddr', ipaddr)
            // verify required parameter 'updates' is not null or undefined
            assertParamExists('updateMirroringPeer', 'updates', updates)
            const localVarPath = `/virtual_private_gateways/{vpg_id}/junction/mirroring/peers/{ipaddr}`
                .replace(`{${"vpg_id"}}`, encodeURIComponent(String(vpgId)))
                .replace(`{${"ipaddr"}}`, encodeURIComponent(String(ipaddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-API-Key", configuration)

            // authentication api_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Soracom-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updates, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualPrivateGatewayApi - functional programming interface
 * @export
 */
export const VirtualPrivateGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualPrivateGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * Close SORACOM Gate on the specified VPG.
         * @summary Close SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeGate(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeGate(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add node in the list of Junction mirroring peers
         * @summary Add node in the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMirroringPeer(vpgId, mirroringPeer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a packet capture sessins associated the VPG
         * @summary Create Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPacketCaptureSession(vpgId, packetCaptureSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new VPG.
         * @summary Create Virtual Private Gateway.
         * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualPrivateGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualPrivateGateway(createVirtualPrivateGatewayRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a VPC peering connection for the specified VPG.
         * @summary Create VPC Peering Connection
         * @param {string} vpgId Target VPG ID.
         * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVpcPeeringConnectionRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVpcPeeringConnection(vpgId, vpcPeeringConnection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove peer from the list of Junction mirroring peers
         * @summary Remove peer from the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr IP address of mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMirroringPeer(vpgId, ipaddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a packet capture sessins associated the VPG
         * @summary Delete Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePacketCaptureSession(vpgId, sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an entry in VPG IP address map.
         * @summary Delete VPG IP address map entry
         * @param {string} vpgId Target VPG ID.
         * @param {string} key Target key to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpAddressMapEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified VPC peering connection.
         * @summary Delete VPC Peering Connection.
         * @param {string} vpgId Target VPG ID.
         * @param {string} pcxId VPC peering connection ID to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVpcPeeringConnection(vpgId, pcxId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a packet capture sessins associated the VPG
         * @summary Get Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacketCaptureSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPacketCaptureSession(vpgId, sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves information about the specified VPG.
         * @summary Get Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualPrivateGateway(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualPrivateGateway(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Gate peers registered in the Virtual Private Gateway
         * @summary List VPG Gate peers
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGatePeers(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GatePeer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGatePeers(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List packet capture sessins associated with the VPG
         * @summary List Packet Capture Sessions
         * @param {string} vpgId VPG ID
         * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
         * @param {number} [limit] Max number of results in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PacketCaptureSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPacketCaptureSessions(vpgId, lastEvaluatedKey, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Describes the list of IP addresse map entries in the Virtual Private Gateway
         * @summary List VPG IP address map entries
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IpAddressMapEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVirtualPrivateGatewayIpAddressMapEntries(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of VPGs.
         * @summary List Virtual Private Gateways.
         * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the VPGs.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualPrivateGateway>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVirtualPrivateGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Open SORACOM Gate on the specified VPG.
         * @summary Open SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openGate(vpgId, configurationParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Puts an entry in VPG IP address map.
         * @summary Put an entry in VPG IP address map
         * @param {string} vpgId Target VPG ID.
         * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpAddressMapEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVirtualPrivateGatewayIpAddressMapEntry(vpgId, putIpAddressMapEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a host as a gate peer in the Virtual Private Gateway
         * @summary Register VPG Gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {RegisterGatePeerRequest} gatePeer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatePeer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerGatePeer(vpgId, gatePeer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set configuration for Junction inspection feature
         * @summary Set configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setInspectionConfiguration(vpgId, inspectionConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set configuration for Junction redirection feature
         * @summary Set configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRedirectionConfiguration(vpgId, redirectionConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets Virtual Private Gateway outbound routing filter.
         * @summary Sets Virtual Private Gateway outbound routing filter.
         * @param {string} vpgId Target VPG ID.
         * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoutingFilter(vpgId, routingFilterEntries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the specified VPG.
         * @summary Terminate Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateVirtualPrivateGateway(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateVirtualPrivateGateway(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unregister a gate peer from the Virtual Private Gateway
         * @summary Unregister VPG gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {string} outerIpAddress ID of the target node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterGatePeer(vpgId, outerIpAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unset configuration for Junction inspection feature
         * @summary Unset configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetInspectionConfiguration(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetInspectionConfiguration(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unset configuration for Junction redirection feature
         * @summary Unset configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsetRedirectionConfiguration(vpgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsetRedirectionConfiguration(vpgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Junction mirroring peer
         * @summary Update a Junction mirroring peer
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr Mirroring peer IP address
         * @param {Array<AttributeUpdate>} updates List of attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMirroringPeer(vpgId, ipaddr, updates, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VirtualPrivateGatewayApi - factory interface
 * @export
 */
export const VirtualPrivateGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualPrivateGatewayApiFp(configuration)
    return {
        /**
         * Close SORACOM Gate on the specified VPG.
         * @summary Close SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeGate(vpgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.closeGate(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add node in the list of Junction mirroring peers
         * @summary Add node in the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): AxiosPromise<void> {
            return localVarFp.createMirroringPeer(vpgId, mirroringPeer, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a packet capture sessins associated the VPG
         * @summary Create Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): AxiosPromise<PacketCaptureSession> {
            return localVarFp.createPacketCaptureSession(vpgId, packetCaptureSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new VPG.
         * @summary Create Virtual Private Gateway.
         * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): AxiosPromise<VirtualPrivateGateway> {
            return localVarFp.createVirtualPrivateGateway(createVirtualPrivateGatewayRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a VPC peering connection for the specified VPG.
         * @summary Create VPC Peering Connection
         * @param {string} vpgId Target VPG ID.
         * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): AxiosPromise<CreateVpcPeeringConnectionRequest> {
            return localVarFp.createVpcPeeringConnection(vpgId, vpcPeeringConnection, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove peer from the list of Junction mirroring peers
         * @summary Remove peer from the list of Junction mirroring peers
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr IP address of mirroring peer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMirroringPeer(vpgId, ipaddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a packet capture sessins associated the VPG
         * @summary Delete Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession> {
            return localVarFp.deletePacketCaptureSession(vpgId, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an entry in VPG IP address map.
         * @summary Delete VPG IP address map entry
         * @param {string} vpgId Target VPG ID.
         * @param {string} key Target key to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): AxiosPromise<IpAddressMapEntry> {
            return localVarFp.deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified VPC peering connection.
         * @summary Delete VPC Peering Connection.
         * @param {string} vpgId Target VPG ID.
         * @param {string} pcxId VPC peering connection ID to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVpcPeeringConnection(vpgId, pcxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a packet capture sessins associated the VPG
         * @summary Get Packet Capture Session
         * @param {string} vpgId VPG ID
         * @param {string} sessionId Packet capture session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession> {
            return localVarFp.getPacketCaptureSession(vpgId, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information about the specified VPG.
         * @summary Get Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getVirtualPrivateGateway(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Gate peers registered in the Virtual Private Gateway
         * @summary List VPG Gate peers
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatePeers(vpgId: string, options?: any): AxiosPromise<Array<GatePeer>> {
            return localVarFp.listGatePeers(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List packet capture sessins associated with the VPG
         * @summary List Packet Capture Sessions
         * @param {string} vpgId VPG ID
         * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
         * @param {number} [limit] Max number of results in a response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<PacketCaptureSession>> {
            return localVarFp.listPacketCaptureSessions(vpgId, lastEvaluatedKey, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Describes the list of IP addresse map entries in the Virtual Private Gateway
         * @summary List VPG IP address map entries
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): AxiosPromise<Array<IpAddressMapEntry>> {
            return localVarFp.listVirtualPrivateGatewayIpAddressMapEntries(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of VPGs.
         * @summary List Virtual Private Gateways.
         * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
         * @param {string} [tagValue] Tag value of the VPGs.
         * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
         * @param {number} [limit] Maximum number of results per response page.
         * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<VirtualPrivateGateway>> {
            return localVarFp.listVirtualPrivateGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Open SORACOM Gate on the specified VPG.
         * @summary Open SORACOM Gate.
         * @param {string} vpgId Target VPG ID.
         * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.openGate(vpgId, configurationParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Puts an entry in VPG IP address map.
         * @summary Put an entry in VPG IP address map
         * @param {string} vpgId Target VPG ID.
         * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): AxiosPromise<IpAddressMapEntry> {
            return localVarFp.putVirtualPrivateGatewayIpAddressMapEntry(vpgId, putIpAddressMapEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a host as a gate peer in the Virtual Private Gateway
         * @summary Register VPG Gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {RegisterGatePeerRequest} gatePeer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): AxiosPromise<GatePeer> {
            return localVarFp.registerGatePeer(vpgId, gatePeer, options).then((request) => request(axios, basePath));
        },
        /**
         * Set configuration for Junction inspection feature
         * @summary Set configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.setInspectionConfiguration(vpgId, inspectionConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * Set configuration for Junction redirection feature
         * @summary Set configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.setRedirectionConfiguration(vpgId, redirectionConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets Virtual Private Gateway outbound routing filter.
         * @summary Sets Virtual Private Gateway outbound routing filter.
         * @param {string} vpgId Target VPG ID.
         * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): AxiosPromise<void> {
            return localVarFp.setRoutingFilter(vpgId, routingFilterEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the specified VPG.
         * @summary Terminate Virtual Private Gateway.
         * @param {string} vpgId Target VPG ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateVirtualPrivateGateway(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unregister a gate peer from the Virtual Private Gateway
         * @summary Unregister VPG gate peer
         * @param {string} vpgId Target VPG ID.
         * @param {string} outerIpAddress ID of the target node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterGatePeer(vpgId, outerIpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Unset configuration for Junction inspection feature
         * @summary Unset configuration for Junction inspection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetInspectionConfiguration(vpgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unsetInspectionConfiguration(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unset configuration for Junction redirection feature
         * @summary Unset configuration for Junction redirection feature
         * @param {string} vpgId VPG ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsetRedirectionConfiguration(vpgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unsetRedirectionConfiguration(vpgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Junction mirroring peer
         * @summary Update a Junction mirroring peer
         * @param {string} vpgId VPG ID
         * @param {string} ipaddr Mirroring peer IP address
         * @param {Array<AttributeUpdate>} updates List of attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): AxiosPromise<void> {
            return localVarFp.updateMirroringPeer(vpgId, ipaddr, updates, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualPrivateGatewayApi - interface
 * @export
 * @interface VirtualPrivateGatewayApi
 */
export interface VirtualPrivateGatewayApiInterface {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    closeGate(vpgId: string, options?: any): AxiosPromise<void>;

    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any): AxiosPromise<void>;

    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any): AxiosPromise<PacketCaptureSession>;

    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any): AxiosPromise<VirtualPrivateGateway>;

    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any): AxiosPromise<CreateVpcPeeringConnectionRequest>;

    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any): AxiosPromise<void>;

    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;

    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any): AxiosPromise<IpAddressMapEntry>;

    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any): AxiosPromise<void>;

    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    getPacketCaptureSession(vpgId: string, sessionId: string, options?: any): AxiosPromise<PacketCaptureSession>;

    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    getVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;

    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listGatePeers(vpgId: string, options?: any): AxiosPromise<Array<GatePeer>>;

    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any): AxiosPromise<Array<PacketCaptureSession>>;

    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any): AxiosPromise<Array<IpAddressMapEntry>>;

    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any): AxiosPromise<Array<VirtualPrivateGateway>>;

    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any): AxiosPromise<void>;

    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any): AxiosPromise<IpAddressMapEntry>;

    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any): AxiosPromise<GatePeer>;

    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any): AxiosPromise<void>;

    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any): AxiosPromise<void>;

    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any): AxiosPromise<void>;

    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    terminateVirtualPrivateGateway(vpgId: string, options?: any): AxiosPromise<void>;

    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any): AxiosPromise<void>;

    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unsetInspectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;

    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    unsetRedirectionConfiguration(vpgId: string, options?: any): AxiosPromise<void>;

    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApiInterface
     */
    updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any): AxiosPromise<void>;

}

/**
 * VirtualPrivateGatewayApi - object-oriented interface
 * @export
 * @class VirtualPrivateGatewayApi
 * @extends {BaseAPI}
 */
export class VirtualPrivateGatewayApi extends BaseAPI implements VirtualPrivateGatewayApiInterface {
    /**
     * Close SORACOM Gate on the specified VPG.
     * @summary Close SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public closeGate(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).closeGate(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add node in the list of Junction mirroring peers
     * @summary Add node in the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {JunctionMirroringPeer} mirroringPeer Mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public createMirroringPeer(vpgId: string, mirroringPeer: JunctionMirroringPeer, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).createMirroringPeer(vpgId, mirroringPeer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a packet capture sessins associated the VPG
     * @summary Create Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {PacketCaptureSessionRequest} packetCaptureSessionRequest A packet capture session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public createPacketCaptureSession(vpgId: string, packetCaptureSessionRequest: PacketCaptureSessionRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).createPacketCaptureSession(vpgId, packetCaptureSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new VPG.
     * @summary Create Virtual Private Gateway.
     * @param {CreateVirtualPrivateGatewayRequest} createVirtualPrivateGatewayRequest Request containing information for the new VPG to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public createVirtualPrivateGateway(createVirtualPrivateGatewayRequest: CreateVirtualPrivateGatewayRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).createVirtualPrivateGateway(createVirtualPrivateGatewayRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a VPC peering connection for the specified VPG.
     * @summary Create VPC Peering Connection
     * @param {string} vpgId Target VPG ID.
     * @param {CreateVpcPeeringConnectionRequest} vpcPeeringConnection VPC peering connection to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public createVpcPeeringConnection(vpgId: string, vpcPeeringConnection: CreateVpcPeeringConnectionRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).createVpcPeeringConnection(vpgId, vpcPeeringConnection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove peer from the list of Junction mirroring peers
     * @summary Remove peer from the list of Junction mirroring peers
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr IP address of mirroring peer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public deleteMirroringPeer(vpgId: string, ipaddr: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).deleteMirroringPeer(vpgId, ipaddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a packet capture sessins associated the VPG
     * @summary Delete Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public deletePacketCaptureSession(vpgId: string, sessionId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).deletePacketCaptureSession(vpgId, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an entry in VPG IP address map.
     * @summary Delete VPG IP address map entry
     * @param {string} vpgId Target VPG ID.
     * @param {string} key Target key to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, key: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).deleteVirtualPrivateGatewayIpAddressMapEntry(vpgId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified VPC peering connection.
     * @summary Delete VPC Peering Connection.
     * @param {string} vpgId Target VPG ID.
     * @param {string} pcxId VPC peering connection ID to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public deleteVpcPeeringConnection(vpgId: string, pcxId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).deleteVpcPeeringConnection(vpgId, pcxId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a packet capture sessins associated the VPG
     * @summary Get Packet Capture Session
     * @param {string} vpgId VPG ID
     * @param {string} sessionId Packet capture session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public getPacketCaptureSession(vpgId: string, sessionId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).getPacketCaptureSession(vpgId, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about the specified VPG.
     * @summary Get Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public getVirtualPrivateGateway(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).getVirtualPrivateGateway(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Gate peers registered in the Virtual Private Gateway
     * @summary List VPG Gate peers
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public listGatePeers(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).listGatePeers(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List packet capture sessins associated with the VPG
     * @summary List Packet Capture Sessions
     * @param {string} vpgId VPG ID
     * @param {string} [lastEvaluatedKey] ID of the last group in the previous page
     * @param {number} [limit] Max number of results in a response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public listPacketCaptureSessions(vpgId: string, lastEvaluatedKey?: string, limit?: number, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).listPacketCaptureSessions(vpgId, lastEvaluatedKey, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Describes the list of IP addresse map entries in the Virtual Private Gateway
     * @summary List VPG IP address map entries
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public listVirtualPrivateGatewayIpAddressMapEntries(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).listVirtualPrivateGatewayIpAddressMapEntries(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of VPGs.
     * @summary List Virtual Private Gateways.
     * @param {string} [tagName] Tag name of the VPG. Filters through all VPGs that exactly match the tag name. When tag_name is specified, tag_value is required.
     * @param {string} [tagValue] Tag value of the VPGs.
     * @param {'exact' | 'prefix'} [tagValueMatchMode] Tag match mode.
     * @param {number} [limit] Maximum number of results per response page.
     * @param {string} [lastEvaluatedKey] The last group ID retrieved on the current page. By specifying this parameter, you can continue to retrieve the list from the next VPG onward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public listVirtualPrivateGateways(tagName?: string, tagValue?: string, tagValueMatchMode?: 'exact' | 'prefix', limit?: number, lastEvaluatedKey?: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).listVirtualPrivateGateways(tagName, tagValue, tagValueMatchMode, limit, lastEvaluatedKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open SORACOM Gate on the specified VPG.
     * @summary Open SORACOM Gate.
     * @param {string} vpgId Target VPG ID.
     * @param {OpenGateRequest} [configurationParameters] Optional configuration parameters for Gate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public openGate(vpgId: string, configurationParameters?: OpenGateRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).openGate(vpgId, configurationParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Puts an entry in VPG IP address map.
     * @summary Put an entry in VPG IP address map
     * @param {string} vpgId Target VPG ID.
     * @param {PutIpAddressMapEntryRequest} putIpAddressMapEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public putVirtualPrivateGatewayIpAddressMapEntry(vpgId: string, putIpAddressMapEntryRequest: PutIpAddressMapEntryRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).putVirtualPrivateGatewayIpAddressMapEntry(vpgId, putIpAddressMapEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a host as a gate peer in the Virtual Private Gateway
     * @summary Register VPG Gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {RegisterGatePeerRequest} gatePeer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public registerGatePeer(vpgId: string, gatePeer: RegisterGatePeerRequest, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).registerGatePeer(vpgId, gatePeer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set configuration for Junction inspection feature
     * @summary Set configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionInspectionConfiguration} inspectionConfiguration Inspection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public setInspectionConfiguration(vpgId: string, inspectionConfiguration: JunctionInspectionConfiguration, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).setInspectionConfiguration(vpgId, inspectionConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set configuration for Junction redirection feature
     * @summary Set configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {JunctionRedirectionConfiguration} redirectionConfiguration Redirection configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public setRedirectionConfiguration(vpgId: string, redirectionConfiguration: JunctionRedirectionConfiguration, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).setRedirectionConfiguration(vpgId, redirectionConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets Virtual Private Gateway outbound routing filter.
     * @summary Sets Virtual Private Gateway outbound routing filter.
     * @param {string} vpgId Target VPG ID.
     * @param {Array<RoutingFilterEntry>} routingFilterEntries List of routing filter entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public setRoutingFilter(vpgId: string, routingFilterEntries: Array<RoutingFilterEntry>, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).setRoutingFilter(vpgId, routingFilterEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the specified VPG.
     * @summary Terminate Virtual Private Gateway.
     * @param {string} vpgId Target VPG ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public terminateVirtualPrivateGateway(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).terminateVirtualPrivateGateway(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unregister a gate peer from the Virtual Private Gateway
     * @summary Unregister VPG gate peer
     * @param {string} vpgId Target VPG ID.
     * @param {string} outerIpAddress ID of the target node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public unregisterGatePeer(vpgId: string, outerIpAddress: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).unregisterGatePeer(vpgId, outerIpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unset configuration for Junction inspection feature
     * @summary Unset configuration for Junction inspection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public unsetInspectionConfiguration(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).unsetInspectionConfiguration(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unset configuration for Junction redirection feature
     * @summary Unset configuration for Junction redirection feature
     * @param {string} vpgId VPG ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public unsetRedirectionConfiguration(vpgId: string, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).unsetRedirectionConfiguration(vpgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Junction mirroring peer
     * @summary Update a Junction mirroring peer
     * @param {string} vpgId VPG ID
     * @param {string} ipaddr Mirroring peer IP address
     * @param {Array<AttributeUpdate>} updates List of attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualPrivateGatewayApi
     */
    public updateMirroringPeer(vpgId: string, ipaddr: string, updates: Array<AttributeUpdate>, options?: any) {
        return VirtualPrivateGatewayApiFp(this.configuration).updateMirroringPeer(vpgId, ipaddr, updates, options).then((request) => request(this.axios, this.basePath));
    }
}


